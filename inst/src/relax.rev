% upload by konquerer!! 17.6.2005 19.00
% Copyright (C) 2005 Hans Peter Wolf
% --------------------------------------------------------------------------
% RELAX: R Editor for Literate Analysis and lateX
% former name:
% RWINED --- eine full screen Oberflaeche fuer R,  ab VERSION R-2.0.0
% --------------------------------------------------------------------------
%
% Paketerstellung:
% cd /home/wiwi/pwolf/work/relax
% notangle relax.rev > $HOME/work/relax/install.dir/relax/R/relax.R
% R CMD check relax;  R CMD build relax
% R CMD INSTALL --library=lib relax_0.991.tar.gz
% cd lib; zip -r relax.zip relax
%
% Pakettest:
% cd /home/wiwi/pwolf/work/relax
% echo "library(relax,,,'lib'); relax()" | R --vanilla
%
% Paketverteilung fuer Rechner:
%38:   cd /usr/lib/R/library/relax;cp -rp $HOME/work/relax/install.dir/lib/relax/* .
%20/21:   cd /usr/lib/R/library/relax;cp -rp $HOME/work/relax/install.dir/lib/relax/* .
%102: cd /usr/lib/R/library/relax;cp -rp $HOME/work/relax/install.dir/lib/relax/* .
%38:   cd /usr/lib/R/lib/R/library/relax;cp -rp $HOME/work/relax/install.dir/lib/relax/* .
%
%21:   cd /usr/lib/R-2.0.1/library/relax;cp -rp $HOME/work/relax/install.dir/lib/relax/* .
% cp -rp /home/wiwi/pwolf/work/relax/install.dir/lib/relax/* .
% library(relax,lib.loc="/home/wiwi/pwolf/work/relax/install.dir/lib");relax()
%
% Paketbeschaffung über Netz:
% download.file("http://www.wiwi.uni-bielefeld.de/~wolf/software/revweb/PACKAGES/relax_0.991.tar.gz","relax_0.991.tar.gz")
%
% Dokumentationserstellung:
% cd /home/wiwi/pwolf/work/relax
% noweave -delay -index relax.rev > relax.tex; latex relax
% save.window data; save.window wizardry; save.window options; save.window edit; save.window file
% convert file.jpg file.ps; convert edit.jpg edit.ps; convert options.jpg options.ps; convert data.jpg data.ps
% convert methods.jpg methods.ps; convert wizardry.jpg wizardry.ps
%
% Vorarbeiten:
% notangle -RLaTeX-head relax.rev > $HOME/work/relax/install.dir/relax/inst/lib/LaTeX-head.tex
% --------------------------------------------------------------------------
%
% Changes:
% LaTeX.head erweitert
% UNDO OPTION!!!!: % text .t; pack .t; .t configure -undo 1
% Strg PageDown:   tkmark.set(tworkwin, "insert", "end") zur Platzierung des Cursors.
% TO DO - DONE - LIST
%  ?? suchen und ersetzen??
%  ?? wiederholte Code-Chunk-Beginns ohne @ zulassen??
%      headmenufunktionen pruefen
%      Umlaute testen / auch unter windows
%      Plots nur im sichtbaren Bereich einbinden / rein / raus?
%  ?? connections - input/output
%  ?? mehrfache Aktivierungen!?, sowie Numerierungen (eher nein)?,
%  ?? Texte german - Englisch anpassen
\documentclass[twoside]{article}
\usepackage{graphicx}
  \usepackage{gnoweb}% \usepackage[roman8]{inputenc}
  \noweboptions{webnumbering,smallcode,longchunks,longxref}\language1
 \usepackage[T1]{fontenc}
 \input{uml-ok.tex}  % \newcommand{\includegraphics}[1]{{#1}} %win
 \def\nwendcode{\endtrivlist\endgroup\vfil\penalty10\vfilneg}\let\nwdocspar=\smallbreak
\sloppy \textheight=25cm\topmargin=-3cm\oddsidemargin=0mm\evensidemargin=0mm
\textwidth=165mm \parindent=0mm
\begin{document} \renewcommand{\contentsname}{Inhaltsverzeichnis}
\title{[[relax]] --- eine Oberfläche für R\\implementiert mittels [[Tcl/Tk]]}
\author{H. P. Wolf}\date{[[pwd:pwolf/work/relax/relax.rev]], Druck: \today} \maketitle

@
%% ============================================================== %%
<<Version von [[relax]]>>=
"relax 1.00 - 050624"
@
<<relax>>=
"relax"

@
\tableofcontents

@
\paragraph{Vorweg}
The windows version uses some ingredients of
\begin{itemize}
\item[noweb] [[ / noweb.sty]]: system of Norman Ramsey
--- [[http://www.eecs.harvard.edu/~nr/noweb/intro.html]]%
\footnote{
Noweb is copyright 1989-1999 by Norman Ramsey. All rights reserved.
You may use and distribute noweb for any purpose, for free. You may modify noweb and create derived works,
provided you retain the copyright notice, but the result may not be called noweb without my written consent.
You may do anything you like with programs created with noweb. You may even sell noweb itself, for example,
as part of a CD-ROM distribution, provided that what you sell is the true, complete, and unmodified noweb.)}
\item[img:] of Jan Nijtmans --- [[http://www.xs4all.nl/~nijtmans/img.html]]%
\footnote{Copyright (c) 1995-2003 Jan Nijtmans [[<nijtmans@users.sourceforge.com>]]\\
  see: [[http://sourceforge.net/docman/display_doc.php?docid=6025&group_id=1]],\\
  [[http://www.opensource.org/docs/definition.php]],\\
  [[http://aspn.activestate.com/ASPN/docs/ActiveTcl/img/doc/img.html]]\\
  [[http://aspn.activestate.com/ASPN/docs/ActiveTcl/at.license.html]]}
\item[gawk:] --- [[http://www.gnu.org/software/gawk/gawk.html]] (nur in älteren Versionen verwendet.)%
\footnote{
    gawk is GNU: This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

    Here you get the text via internet: http://www.gnu.org/licenses/gpl.txt
}
\end{itemize}

@
\section{Ziel und Weg}
Dieser Full-Screen-Editor soll
\begin{itemize}
\item
einen reportorientierten Arbeitsstil,
\item
den Umgang mit wiederbelebbaren Papieren,
\item
die Erstellung von wiederbelebbaren Materialien
\end{itemize}
unterstützen.
Das Erscheinungsbild, die Mächtigkeit und die nötigen Arbeitsschritte
sollen dabei so sein, daß sowohl der Anfänger als
auch der Fortgeschrittene auf seine Kosten kommt. Viele der hier angebotenen
zentralen Funktionalitäten entsprechen denen
der Funktion {\sc revive} bzw.\ der R-Bibliothek {\sc rrevive}.
Hinzugekommen ist eine neue Oberfläche. Diese zeigt
dem Anwender die Arbeitsdokumente direkt an und gestattet es,
in den Dokumenten zu navigieren und in ihnen zu arbeiten.
Weitere einleitende Bemerkungen sind dem Papier
zum Reportmanager zu entnehmen.


@
\section{Evaluierung von Anweisungen}

@
\subsection{Einfachste Arbeitsform}

Es sollte möglich sein,
quick and dirty mit Datensätzen herumzuspielen und gegebenenfalls
einige Service-Funktionen der Oberfläche in Anspruch zu nehmen.
Mit diesen Funktionen könnten zum Beispiel
Zugriffe auf zurückliegende Anweisungen
erleichtert werden, und es sind Funktionen denkbar, die nach
Themenberei\-chen geordnet dem Anwender zu dem richtigen Einsatz von
statistischen Funktionen hinführen --- die Hilfen anbieten.

@
\subsection{Sprachelemente}

\subsubsection{Arbeitsfenster: [[workwin]]}
Absolut notwendig für die Ausführung statistischer Arbeitsschritte ist ein
Texteingabefeld, in dem der Anwender seine Gedanken und Anweisungen
niederschreiben kann und in das die berechneten Ergebnisse ausgegeben werden.
Texte werden --- wie allgemein üblich ---
über Tastatur in das Eingabefeld eingebracht.
Dieses Fenster wird im Folgenden {\em Arbeitsfenster} genannt.
Wie beim normalen Schreiben soll das Textfeld nur nach unten hin
verlängern werden. Nach einem Beschreibungstext, auch Text-Chunk genannt,
folgt ein Abschnitt mit auszuführenden Anweisungen, die dem Interpreter zur
Auswertung übergeben werden.

Nach der Evaluierung der Anweisungen (des Code-Chunk)
werden die Ergebnisse in einem zweiten Textfenster,
dem Output-Fenster, an die dort schon befindlichen Einträge angefügt.
Auf Wunsch können diese Ergebnisse in das Arbeitsfenster übernommen werden.
Damit besteht der Inhalt des Arbeitsfensters aus einer
Aneinanderreihung von Anwender-Texten, Anweisungen für R und
Berechnungsergebnissen. Es ist zweckmäßig, Anweisungen und Ergebnisse als
unterschiedliche Qualitäten deutlich von einander abzugrenzen.
Anders formuliert bedarf es bestimmter Sprachelemente, damit
Anwender aber auch die verarbeitenden Werkzeuge
die unterschiedlichen Typen passend verstehen. Hierfür gelten folgende
Regeln\footnote{Diese Regeln gehen wesentlich auf die
Regeln des [[noweb]]-Systems zurück, das
zur Unterstützung des literaten Programmierstils entworfen wurde.}.

@
\paragraph{Beginn eines Text-Chunks.}
Ein [[@]]-Zeichen am Beginn einer Zeile als einziges Zeichen
leitet einen Textabschnitt oder Text-Chunk ein.
Text-Chunks sind also die Einheiten, die die Gedanken in verbaler
Form aufnehmen.
@
\paragraph{Abgrenzung von Ergebnissen.}
Übernommene
Ergebnisse werden in Form eines Text-Chunk abgelegt, wobei sie zusätzlich
durch die Zeichenketten \verb+output-start+ und \verb+output-end+ umklammert
werden.
@
\paragraph{Abgrenzung von Anweisungsfolgen.}
Zusammen auszuführende Anweisungssequenzen müssen
durch die Zeichenkette \verb+@<<*>>=+ eingeleitet werden.
Damit erhält die Lösung der Hello-World-Print-Aufgabe folgende Gestalt.
\begin{quote}
\verb+@+\\
\verb+Drucke die Zeichenkette "Hello World" aus+\\
\verb+@<<*>>=+\\
\verb+print("Hello World")+
\end{quote}

@
Mit dem Beginn des nächsten
Text-Chunks oder spätestens mit dem Ende des Arbeitsfeldes
endet der sogenannte Code-Chunk. Die auszuwertenden Zeilen befinden
sich also zwischen dem Code-Chunk-Namen und dem nächsten [[@]] oder
dem Textfeldende.
Nach der Auswertung wird das Ergebnis im Outputfeld angezeigt und kann
übernommen werden, so dass im Arbeitsfeld zu sehen ist:
\begin{quote}
\verb+@+\\
\verb+Drucke die Zeichenkette "Hello World" aus+\\
\verb+@<<*>>=+\\
\verb+cat("Hello World\n")+\\
\verb+@+\\
\verb+output-start+\\
\verb+Hello World+\\
\verb+output-end+
\end{quote}

@
Hiernach lassen sich weitere Gedanken anfügen, die jeweils wieder mit einem
alleinstehenden [[@]] eingeleitet werden (sollten).
\begin{quote}
\verb+@+\\
\verb+Drucke die Zeichenkette "Hello World" aus+\\
\verb+@<<*>>=+\\
\verb+cat("Hello World\n")+\\
\verb+@+\\
\verb+output-start+\\
\verb+Hello World+\\
\verb+output-end+
\verb+@+\\
\verb+... neuer Gedanke ...+
\end{quote}

@
Der Code-Chunk-Name [[*]] kann durch einen sprechenden
Name ersetzt werden. Hierdurch kann der
Code über den Namen referenziert werden, d.h.\
in einer anderen Code-Sequenz verwendet werden.
Es ist zu beachten, daß der {\em Name} des Code-Chunk
keine Zeilenumbrüche enthalten darf:
\begin{quote}
{\small
\verb+@+\\
\verb+Drucke die Zeichenkette "Hello World" aus+\\
\verb+@<<drucke "Hello World" aus>>=+\\
\verb+cat("Hello World\n")+\\
\verb+@+\\
\verb+Im Rahmen der Ergebnisausgabe soll die ganze Welt angesprochen werden+
\verb+@<<*>>=+\\
\verb+@<<drucke "Hello World" aus>>+\\
\verb+cat("Hier das Ergebnis:\n")+\\
\verb+print(42)+
} %end of small
\end{quote}



@
\subsubsection{Knöpfe:  [[PlanRCode]], [[EvalRCode]], [[TrashROutput]], [[Up]], [[Down]],
                        [[Help.R:]]}

\paragraph{[[EvalRCode]]: Aktivierung von Anweisungen.}
Für die Aktivierung von Code-Sequenzen bedarf es eines Sprachelements.
Dieses wird durch einen Aktivierungsknopfes sowie der Verabredung umgesetzt,
daß dieser Knopf immer nur die Anweisung(en) aus dem Arbeitsfenster
umsetzt, auf die der Cursor zeigt.

@
\paragraph{[[PlanRCode]]: Text- und Code-Chunk in leerer Form bereitstellen.}
Für die Vorbereitung eines neuen Arbeitsschrittes ist ein Knopf eine gute Hilfe, der
das Muster einer leeren Text-Code-Chunk-Einheit ins Arbeitsfenster
schreibt. Wird der Knopf [[PlanRCode]] gedrückt, erscheint in der Nähe des
Cursors:
\begin{quote}
\verb+@+\\
\verb+ +\\
\verb+@<<*>>=+\\
\verb+ +
\end{quote}


@
\paragraph{[[TrashROutput]]: Entfernung des letzten Output.}
Die Arbeit mit den ersten Testversionen hat gezeigt, daß
immer wieder Fehlversuche gemacht werden, die nicht weiter aufbewahrenswert
sind. Um bequem übernommene Ausgaben zu löschen wird der
Knopf [[TrashROutput]] angeboten. Er entfernt die Ergebnisse
wieder aus dem Arbeitsfenster, auf die der Cursor zeigt.

@
\paragraph{[[Down]]: Bewegung der Schreibmarke zum nächsten Code-Chunk.}
Zur erleichterten Navigation kann der Anwender durch Druck auf den Knopf
[[Down]] die Schreibmarke auf den nächst folgenden Code-Chunk
positionieren.

@
\paragraph{[[Up]]: Bewegung der Schreibmarke zum vorherigen Code-Chunk.}
Durch Druck auf den Knopf
[[Up]] kann der Anwender zur vorherigen Schreibmarke zurückblättern.


@
\paragraph{[[Help.R:]] Start einer Hilfe.}
Als kleine Hilfe wird (oben rechts) ein Hilfeknopf definiert, mit dem die
R-Hilfe angestoßen werden kann.

@
\paragraph{Short cuts für Knöpfe.}
Zur Vereinfachung der Bedienung von Knöpfen soll es für den geübten
Anwender möglich sein, die Operationen
auch über {\sc Alt}-Tastenkombinationen, also über sogenannte short cuts,
auszulösen.

@
\subsubsection{Meldungsanzeige: [[Info]]}
\paragraph{[[Info:]] Anzeige von Meldungen.}
Eine Zeile für Fehler-, Zustands- und Informationsmeldungen wird immer
benötigt.

@
\paragraph{[[Strg Pagedown]] Kopieren ans Ende.}
Um nicht schon einmal eingegebene Anweisungen
neu eintippen zu müssen, soll die Tastenkombination
[[Strg Pagedown]], wenn das Reportfenster aktiv ist, den
Code-Chunk, dessen Beginn sich vor der Cursor-Position befindet,
ans Ende kopieren, ihn aber nicht ausführen.

Damit haben wir auch die Überleitung zu der nächsten Frage:
Welche wesentlichen Operationen will der Statistiker
während seiner Arbeit neben der Eingabe von Texten und
der Beschreibungen von Berechnungen und Datenmanipulationen
umgesetzt bekommen?
Zur Auslösung entsprechender Prozesse werden im Folgenden eine Reihe
von Funktions-Knöpfen entworfen.



@
\subsubsection{Operationen für das Outputfeld:
[[RemoveOut]], [[Insert]], [[SavePlot]]}
Bisher sind drei elementare Operationen für das Outputfeld
im Angebot:

\paragraph{[[RemoveOut]]: Entfernung des Inhalts.}
Mit diesem Knopf lässt sich der Inhalt aus dem Outputfenster entfernen.

\paragraph{[[Insert]]: Verschieben des Inhalts ins Arbeitsfenster.}
Mit diesem Knopf lässt sich der Inhalt ins Arbeitsfenster hinter die
Schreibmarke verschieben. Dannach ist das
Outputfenster leer.

\paragraph{[[SavePlot]]: Sichert Plot.} 
Sichert den Inhalt eines graphischen Device
als Postscript- und JPEG-Datei und stellt Plot im Arbeitsfenster dar.


@
\subsubsection{Menüs: [[File]], [[Edit]], [[Options]]}

\paragraph{[[File]]: Datei- und andere dateinahe Operationen.}
Dateioperationen werden bei vielen
Softwareprodukten in der Kopfzeile angeboten, so daß sich auch hier ein
entsprechendes Pull-Down-Menü mit den Namen [[File]] anbietet.
Unter diesem werden Auf\-listungs, Lade- und Speicheroperationen
angeboten.
Auch wenn die Überschrift für die Programmbeendigung wenig sinnig im
Datei-Menü untergebracht ist, soll [[Exit]] unter den Dateioperationen
subsummiert werden, wie es auch bei vielen anderen Oberflächen üblich ist.

@
\paragraph{[[Edit]]: Suchen nach Dingen und andere arbeitsfensterbezogene
Operationen.}
Für die Navigation bietet sich ein zweites Menü für spezielle Bearbeitsschritte,
zum Beispiel für Suchfunktionen an. So kommt immer wieder der Wunsch auf,
nach Textstrings zu suchen. Weiter könnte man nach Code-Chunks suchen wollen.
\paragraph{[[CopyToEnd]]: Verschieben des Outputs ans
Ende des Arbeitsfensters.} Mit diesem Knopf wird der Inhalt des Outputfeldes ans
Ende des Arbeitsfensters verschoben. Inzwischen als Menüeintrag unter
[[Edit]].

@
\paragraph{[[Options]]: Veränderung von Einstellungen.}
Die Veränderung der Schrift
und einigen anderen Dingen dürfte wünschenswert sein. Für solche
Setzungen eignet sich ein Options-Menü.
Auch muß es eine Möglichkeit geben, um die Größe von Postscript-Bildern
zu setzen.
Wie sich mit der Zeit herausgestellt hat, kann es passieren, daß
ein ungeschickter Auftrag zu einer sehr langen aber,
unbrauchbaren Ausgabe führt. Die Festlegung einer Output-Obergrenze
ist damit ein weiterer Kandidat für das Options-Menü.

@
\paragraph{[[Wizardry]]: Dokumentverarbeitung.}
Rohreports wollen schön gesetzt sein. Dafür werden unter diesem 
Menü verschiedene Punkte angeboten: weave, tangle, latex, view *dvi,
Präambel einfügen usw.

@
\paragraph{[[Data]]: hilft bei der Auswahl von Daten.}

@
\paragraph{[[Methods]]: zeigt die Syntax einfacher Operationen.}


@
\paragraph{[[CopyToEnd]]: Verschieben des Outputs ans
Ende des Arbeitsfensters.} Mit diesem Knopf wird der Inhalt des Outputfeldes ans
Ende des Arbeitsfensters verschoben. Inzwischen als Menüeintrag unter
[[Edit]].


@
\subsubsection{Zusammenfassung}
Für die elementaren Arbeiten sind zusammenfassend
ein Text-Eingabefeld, ein Ausgabefeld, neun Knöpfe, drei Menüs
und eine Meldungsleiste beschrieben worden. Hier die Übersicht:
\begin{itemize}
\item[[EvalRCode]] --- aktiviere letzte Anweisungen
\item[[PlanRCode]] --- stelle leere Text-Code-Chunk-Einheit bereit
\item[[TrashROutput]] --- entferne letzten Output
\item[[Down]] --- gehe zum nächsten Code-Chunk
\item[[Up]] --- gehe zum vorherigen Code-Chunk
\item[[Help.R]] --- starte R-Hilfe
\item[[Info]] --- Meldungsanzeigefeld
\item[[File]] --- Menü mit dateinahen Operationen und Ausgang
\item[[Edit]] --- Menü zum Suchen und fensterbezogenen Operationen
\item[[Options]] --- Veränderung spezieller Einstellungen
\item[[workwin]] --- Arbeitsfenster
\item[[outwin]] --- Outputfenster
\item{\sc Alt} --- short cuts für Knöpfe
\item [[Strg Pagedown]] zur Kopie von Codesequenzen
\item[[@]] und [[@<<...>>=]] --- zur Abgrenzung von Texten und Code
\end{itemize}

Die genannten Elemente werden in dem hier vorgestellten Instrument
mit folgendem Erscheinungsbild umgesetzt.
In Voraussicht ist schon ein Feld mit dem Reportnamen ergänzt worden.
Weiterhin sind Menüs mit dem Titel [[Data]] und [[Methods]]
zu erkennen, diese werden weiter unten diskutiert.

@
Der Kopfbereich entspricht im Design
vielen bekannten Oberflächen. Hierdurch soll der Suchaufwand
für die im allgemeinen dort untergebrachten Operationen klein bleiben.
Der Rest ist der Anordnung einer PC-Anlage nachempfunden,
bei der die Tastatur unterhalb des Bildschirm zu finden ist.
Das Eingabefenster entspricht dabei dem Bildschirm. Es befindet sich über
den zentralen, als winzige Tastatur interpretierbare Knöpfen für die Eingabe.
Ausgaben erscheinen zunächst unten, wie auch ein per Hand beschriebenes
Papier in der Regel unten verlängert wird.
Die Arbeitsschritte werden dadurch oft zu einem sich wiederholenden
Perspektivenwechsel führen:
\begin{enumerate}
\item Lesen der alten Inhalte (z.B.\ Ergebnisse),
\item Anfügungen von neuem Text,
\item Entwurf eines neuen Code-Chunk,
\item Aktivierung des Code.
\item Übernahme oder Löschung der Ergebnisse
\end{enumerate}
@
\begin{center}

\includegraphics[height=8cm]{PS/relax-win.ps}

%rawhtml% \begin{rawhtml}<p><img src="win1.gif"><p>\end{rawhtml}

\end{center}

@
\section{Reportorientiertes Arbeiten}

\subsection{Arbeitsform}
Ein reportorientiertes Arbeiten erfordert alle Dinge, die schon
unter der Überschrift {\em Evaluierung von Anweisung} aufgelistet
sind. Das Eingabefenster wandelt sich bei diesem Arbeitsstil
von einem Arbeits- zu einem {\em Reportfenster}. Dieses muß zu keinen
Änderungen der Oberfläche führen.
Als funktionale Neuerung dürfte die Möglichkeit
der Verwendung von benannten Code-Sequenzen in einem auszuführenden
Code-Chunk vorteilhaft sein.
Dieses erfordert bei der Aktivierung des letzten
Code-Chunk einen lokalen {\sc Tangle}-Prozeß,
dessen Umsetzung weiter unten näher diskutiert wird.
Da über diesen Mechanismus auch externe Code-Chunks
--- also welche, die sich in anderen Dateien befinden ---
referenziert werden können sollen, ergibt sich ein Lösungsvorschlag zu
drei Problemkreisen:
Erstens können so im Report wiederverwendbare Code-Sequenzen
aus externen Bibliothekspapieren eingebunden werden,
zweitens lassen sich für wiederbelebbare Papiere
Anhänge mit Funktionsdefinitionen in separaten Dateien halten und
drittens können Reports von Reaktivierungen erstellt werden, die nicht vor Code
bersten.

Neben dieser konzeptionellen Erweiterung müssen die typischen
Operationen zur Verwaltung und Verarbeitung von Reports, wie Ortswahl,
Laden, Speichern und Dokumenterstellung hinzukommen.
Wenn ein halbfertiger Report erneut zur weiteren Arbeit geladen wird,
muß es die Möglichkeit geben, den gesamten alten Code zu wiederholen,
um die Umgebung in den alten Zustand zu versetzen.

Damit ist ein grober Rahmen in Form von Anforderungen umrissen.
Für Textstruktur und Inhalt bleibt der Anwender jedoch selbst verantwortlich.


@
\subsection{Sprachelemente}

Als wesentliche Erweiterung müssen definiert werden:
\begin{itemize}
\item
[[SaveReport]] --- speichere einen erarbeiteten Report
\item
[[OpenReport]] --- öffne einen noch unfertigen Report, hänge ihn
unten an das Report-Fenster an
\end{itemize}
Zur Begleitung dieser beiden Aufgaben sollte als Service-Funktion
zum Verzeichniswechsel angeboten werden.
\begin{itemize}
\item
[[SetWorkPath]] --- lege das Arbeitsverzeichnis Reporterstellung fest
\end{itemize}
Nach der Abspeicherung müssen die Rohreports betrachtet werden können,
so daß auch hierfür etwas angeboten werden muss.
Für den Anfänger genügt die gespeicherte Html-Version.
Derjenige mit einer größeren Erfahrung muss weitergehende
Verarbeitungsschritte selbst entwerfen.
Zum Betrachten wird angeboten:
\begin{itemize}
\item
[[ViewReport.html]] --- zeige Report (Html-Version) mit einem Browser an
\end{itemize}
In dem Menü [[Edit]] sind noch einige Einträge zur Erleichterung
der Arbeit an einem Report vorgesehen. Es sind damit folgende
Einträge zu finden:
\begin{itemize}
\item
[[FindRFns]] --- suche nach R-Funktionen aufgrund eines Stichwortes
\item
[[FindReportText]] --- suche im bisherigen Report nach einer Zeichenkette
\item
[[FindReportCode]] --- suche nach einem Code-Chunk
\item
[[FindLaTeXSection]] --- suche  eine \LaTeX-Sektion.
\item
[[EditReport]] ---
starte einen Editor, mit dem der Anwender hoffentlich alle
die Dinge einfach erledigen kann, die ihm direkt mit dem Reportfenster
nicht gelingen. Für Spezialisten sei erwähnt, daß
der Name des Editors auf einer
Variable mit dem Namen [[editor.sys]] abgelegt ist. Diese läßt sich
durch einen geeigneten Funktions-Aufruf setzen.
\item 
[[CopyToEnd]] --- kopiert Ausgabefensterinhalt ans Ende.
%\item
%[[SaveDiffReport]] --- speichert Veränderungen zum Ausgangsfile.
\item
[[RunAll]] --- löse alle Start- und Stern-Code-Chunks
eines Reports aus, damit zum Beispiel
nach dem Laden eines halbfertigen Reports möglichst der Zustand
bei der Speicherung wieder hergestellt wird.
\item
[[DeleteAll]] --- lösche den Inhalt des Reportfensters.
\item
[[UnDo]] --- stelle den Zustand vor der letzten [[EvalRCode]]-Operation her.
Dieses kann sehr wichtig sein, wenn versehentlich wichtige Dinge gelöscht
worden sind. Der Zustand der Variablen wird dabei jedoch nicht zurückgesetzt.
\end{itemize}
@
\paragraph{[[SavePlot]]: Speicherung eines Bildes.}
Wer möchte nicht gern in seinem Report die Abdrucke der gelungenen
Graphiken eingefügt haben? Zu diesem Zweck müssen sie auf\-findbar als Dateien
abgelegt werden. Die Betätigung von [[SavePlot]] erstellt zu
einem Bild eine [[PS]]- und eine
[[JPG]]-Datei und blendet es bei entsprechender Installation im Arbeitsfenster ein.
Das leichte Kopieren eines Bildes in das Dokument
in Form einer Postscript- und einer [[JPG]]-Datei wird sicher auch reportophobe
Anwender erfreuen.
Natürlich wird diese Operation im reportorientierten Arbeitsstil
an Relevanz gewinnen.

@
Für den lokalen {\sc Tangle}-Prozeß bedarf es noch einer sprachlichen
Fixierung:
\begin{itemize}
\item {\sc Tangle}-Prozeß:
In einem Code-Chunk dürfen auch {\em externe Code-Chunks} adressiert werden.
Für diese gilt die Syntax:
\begin{quote}
[[#<file:]]$\langle${\em Pfad}$\rangle$[[/]]%
$\langle${\em Dateiname}$\rangle$[[:]]%
$\langle${\em Code-Chunk-Nummer}$\rangle$[[>#]]
\end{quote}
oder
\begin{quote}
[[#<file:]]$\langle${\em Pfad}$\rangle$[[/]]%
$\langle${\em Dateiname}$\rangle$[[:]]%
$\langle${\em Referenz des Code-Chunk}$\rangle$[[>#]]
\end{quote}
\end{itemize}
Für die Auswertung muß der Code-Chunk-File -- also die Datei mit der
Endung [[R]] -- zugreifbar sein.

@
% Bei der Generierung eines Reports wird als Pfad der Inhalt von
% [[revpath.sys]] abgelegt.

@
Es ist nicht erforderlich, auf der obersten Ebene weitere Oberflächenelemente
zu ergänzen. Jedoch müssen in dem Menü [[Edit]] die neuen Punkte
aufgenommen werden.


@
Hier noch die Anzeige der einzelne Menü der Kopfleiste:

\begin{itemize}

\item{Das Datei-Menü:}

{\centering\includegraphics[height=4cm]{PS/file.ps}}

@
\item{Das Bearbeiten-Menü}

{\centering\includegraphics[height=5cm]{PS/edit.ps}}

@
\item{Das Optionen-Menü}

{\centering\includegraphics[height=4cm]{PS/options.ps}}

@
\item{Das Wizardry-Menü}

{\centering\includegraphics[height=5cm]{PS/wizardry.ps}}
@
\item{Das Methoden-Menü}

{\centering\includegraphics[height=3cm]{PS/methods.ps}}
@
\item{Das Daten-Menü}

{\centering\includegraphics[height=4cm]{PS/data.ps}}

\end{itemize}

@
\section{Überblick über Umgebungen, Objekte und Funktionen}
Bevor die Oberfläche mit ihren Elementen definiert werden kann,
muß die große Linie festgelegt werden.
Die Fragen:
{\em Welche Objekte sind wo zu finden,
was muß an welcher Stelle abgelegt werden,
was ist wie zu finden?\/} müssen zweckmäßigerweise
vorher beantwortet werden. Natürlich hat sich die
genaue Struktur mit der Zeit entwickelt. Dennoch sind einige
wesentliche Entscheidungen über alle bisherigen Versionen
stabil geblieben. Diese werden in diesem Kapitel zusammengefaßt.

\subsection{Der R-Editor als R-Paket}

Der R-Editor soll  isoliert als R-Paket mit dem Namen [[relax]]
bereitgestellt werden.
% Dann soll eine Vereinigung mit der Bibliothek [[rtrevive]] angestrebt werden.
Also müssen alle hier definierten Dinge --- also Funktionen und
Initialisierungsanweisungen --- in einer [[R]]-Codedatei zusammengefaßt
werden. Für ihre Anordnung sind dabei Reihenfolgebedingungen zu beachten.
Für die Aktivierung soll es ausreichen, das Paket mit dem
Namen [[relax]] zu laden und die Oberflächenfunktion [[relax()]]
zu starten.
Durch diesen Aufruf müssen dann
\begin{itemize}
\item ggf.\ das [[Tcl/Tk]]-Paket angeschlossen,
\item die Oberfläche aufgebaut,
\item die Elemente der Oberfläche mit den nötigen Funktionalitäten
      ausgestattet und
\item die Verwaltung für Anwender- und Systemobjekte eingerichtet
\end{itemize}
werden.
Dabei sind Unterschiede für verschiedene Plattformen zu berücksichtigen.

@
\subsection{Über die Objektverwaltung}
Für die Übersicht werden alle Anwenderobjekte von den Systemobjekten getrennt
in einer eigenen Umgebung [[revive.env]] abgelegt. In dieser finden auch die
durch den Anwender ausgelösten Evaluierungsprozesse statt.
Hierdurch wird vermieden, daß
die vom Anwender erarbeiteten Ergebnisse mit Dingen des Systems kollidieren.
Die Umgebung des Anwenders [[revive.env]] wird beim Anschluß des
Pakets mit [[new.env]] eingerichtet, sofern sie noch nicht existiert.
Damit auch nach einem Absturz auf Anwenderdaten zugegriffen werden kann,
wird die Adresse zu der Umgebung auf der globalen Variablen
[[revive.env]] abgelegt.

In dieser Umgebung wird als einziges System-Objekt die
Variablen [[revive.sys]] generiert, die die Verbindung zu der Umgebung hält,
in der alle Objekte des Systems abgelegt sind.

Damit gibt es vier Orte zu unterscheiden:
\begin{itemize}
\item das [[relax]]-Paket -- hier befinden sich alle prozeduralen
      Beschreibungen zum Start des Managers sowie die Funktionen
      zur Überlagerung der R-Input-/Output-Funktionen
\item die globale Umgebung -- hier wird das Objekt [[revive.env]] abgelegt,
      der Link zu den Anwenderobjekten bzw.\ zu der Anwenderumgebung
\item die Umgebung [[revive.env]] -- hier befinden sich
      die vom Anwender geschaffenen Objekte und als einziges Systemobjekt
      der Link zur Umgebung des Report-Manager-Betriebs: [[revive.sys]]
\item die Umgebung [[revive.sys]] -- hier residieren alle internen Objekte des
      Report-Managers, die sich zur Laufzeit ändern und zum Betrieb des
      Managers erforderlich sind, wie auch Kopien aller
      Funktionen aus dem Paket.
\end{itemize}

Es folgt die Umsetzung: ggf.\ Schaffung der Umgebung [[new.env()]]
sowie die Definition der Umgebung für Systemdinge, die unter dem
Namen [[revive.sys]] in der Anwenderumgebung abgelegt wird.

Dieser Chunk wird beim Aufruf des Report-Managers aktiviert.
Es ergab sich die Schwierigkeit, daß beim zweiten Aufruf des
Managers aus dem Report-Fenster heraus verschiedene Objekte
aus dem ersten statt aus dem zweiten Aufruf gefunden wurden.
Dieses lag daran, daß diese Objekte in einem Speicherbereich
gefunden wurden, der gar nicht für die Verwaltung gedacht war.
Aus unbekannten Gründen wurde beim zweiten Versuch auf diesen
veralteten Bereich zugegriffen. Zur Abhilfe wird jetzt
als Vater-Umgebung von [[revive.env]] explizit [[.GlobalEnv]]
definiert und es werden beim zweiten Start -- wenn also [[revive.env]]
existiert -- alle Objekte aus [[revive.sys]] gelöscht.
Möglicherweise wäre es geschickter nur die sensiblen Dingen
zu entfernen, jedoch wird auf diese Weise ein hoher Grad an
tabula rasa realisiert.
<<generiere eine neue Umgebung für die Anwenderdaten>>=
if(!exists("revive.env")){
  revive.env<<-revive.env<-new.env(parent=.GlobalEnv)
} else {
  revive.sys<-get("revive.sys",envir=revive.env)
  rm(list=ls(env=revive.sys),  envir=revive.sys)
}
revive.sys<-environment()
assign("revive.sys", revive.sys, envir=revive.env)

@
\subsection{Der Ausgangspunkt für die Oberfläche}

Zunächst muß ein Fenster der obersten Ebene mit einem Titel geschaffen werden.
Damit Fenster und andere Oberflächenelemente angesprochen werden können,
wird für jedes Element mit seiner Erschaffung eine Variable erstellt.
Die Variable für das Toplevelfenster heißt [[TopW]]. Wie bereits
ausgeführt wurde, werden solche Variablen und alle Funktionen der Oberfläche
in der Umgebung [[revive.sys]] gehalten, so daß sie nicht mit den
Objekten des Anwenders kollidieren können.
[[wm protocol . WM_DELETE_WINDOW { puts "kein ordentlicher Ausstieg" }]]
<<generiere Top-Level-Fenster mit verschiedenen Frames>>=
TopW<-tktoplevel(); tkwm.geometry(TopW,"+0+0")
tkwm.title(TopW,paste("RELAX -- R Editor for Literate Analysis and lateX:",
                      <<Version von [[relax]]>>))
tkwm.protocol(TopW,"WM_DELETE_WINDOW",function(){
                   <<sichere letzten Zustand unter [[report-UnDo-bak.rev]]>>
		   cat("... not a nice way to exit relax !!!\n")
		   cat("backup file: report-UnDo-bak.rev\n")
		   if( <<das OS ist Windows>> ){
                      cat("--> to proceed the R session try: Quit R, then don't quit!\n")
                   }
                   if(<<das OS ist Linux>>) cat("-- try: <Ctrl-C> to proceed the R session!\n")
		   set.tclvalue("tvexit","fertig"); tkdestroy(TopW)
           }
)

@
In dieses Top-Level-Fenster werden verschiedene Frames eingebracht,
die im weiteren Verlauf mit Ober\-flächen\-ele\-menten gefüllt werden.

@
\subsection{Das Erstellungs-Modell für einen Knopf}
Knöpfe werden wiederholt zum Einsatz kommen. Für diese bietet sich
eine Standardisierung an, um Wartung und Pflege zu vereinfachen.

@
Die Definition eines Knopfes umfaßt
\begin{itemize}
\item die Festlegung der Wirkung durch eine Knopf\-funktion,
\item die Plazierung dieser Funktion in die richtige Umgebung,
\item die Definition eines virtuellen Events,
\item die Definition des Knopfes mit Einbau in die Oberfläche,
\item die Vereinbarung der Wirkungsfunktion als Knopf-Kommando
\item sowie die Verbindung der Wirkungsfunktion mit dem virtuellen Event.
\end{itemize}

Anhand eines Testknopfes soll das Vorgehen zur Erstellung eines
Knopfes beschrieben werden.

Die Wirkungsfunktion wird außerhalb des Oberflächenmanagers erstellt.
Sie könnte folgende Gestalt haben.
<<definiere Testknopf\-funktion>>=
fTest<-function(){
  melde("fTest",1)
  cat("Hallo Welt\n")
  news <- "\n@\nTestknopftest"
  <<schreibe [[news]] ans Ende des Arbeitstextes>>
  melde("fTest",2)
}

@
Dann wird nach Aufruf des R-Editors beim Aufbau der Oberfläche
--- nachdem die Systemumgebung [[revive.sys]] eingerichtet worden ist ---
der Knopf\-funktion die Umgebung [[revive.sys]] zugeordnet.
Damit wird bei Aktivierung des Knopfes die Wirkungsfunktion gefunden,
welche wiederum alles findet, was in [[revive.sys]] abgelegt ist.
<<setze Umgebung für Testknopf\-funktion>>=
environment(fTest)<-revive.sys

@
Es wird das virtuelle Ereignis [[@<<Test>>]] für die Tastenkombination ALT-T,
definiert. Unter Unix war der Tastatur-Code anders, so dass eine
Zuweisung in Abhängigkeit vom Betriebssystem erforderlich war.
<<definiere Testknopf-Ereignis>>=
tkevent.add("@<<Test>>",  "<Alt_L><t>")

@
Der Knopf selbst wird
mit der Service-Funktion [[implement.but]] eingerichtet.
Diese Funktion besitzt verschiedene Argumente:
Argument eins zeigt den Knopfnamen an. Der Name der
Wirkungsfunktionsnamen ergibt sich durch Voranstellen des Buchstaben [[f]]
vor den Knopfnamen. Das zweite Argument bezeichnet
den gewählten Frame. Das dritte eine kurze Beschreibung, die als Kurzhilfetext
eingeblendet wird.
<<implementiere Testknopf>>=
implement.but("Test", "fworkcmds", "Dies ist ein Testknopf" )

@
Zum Schluß wird die Funktion [[fTest]] als Knopfkommando vereinbart und
mit dem virtuellen Event verbunden.
<<implementiere Eigenschaften vom Testknopf>>=
tkconfigure(Test,command=fTest)
tkbind(TopW, "@<<Test>>", fTest)

@
\subsubsection{Eine Funktion zur Implementation von Knöpfen.}
Da im folgenden noch verschiedene Knöpfe benötigt werden, werden diese
mit der Funktion [[implement.but]] erzeugt, deren Definition als Vorarbeit
hier abgehandelt wird.
In einer solchen Funktion lassen sich Design-Merkmale für alle
Knöpfe der Oberfläche pflegeleicht festlegen.
Das erste Argumente beschreibt zugleich den Knopfnamen und seine Beschriftung,
das zweite seine Frame-Zugehörigkeit, das
dritte eine Kurzhilfe, das vierte seine Positionierung im zugehörigen
Widget, das fünfte die Darstellungsart und das sechste, ob für einen
short cut durch die
{\sc Alt}-Taste der erste Buchstabe unterstrichen werden soll.

@
Das Ergebnis --- die Variable mit der Verbindung zu einem Knopf ---
muß in der Umgebung [[revive.sys]] abgelegt werden, damit jederzeit
ein Zugriff möglich ist.
@
<<definiere [[Implement.but]]>>=
implement.but<-
function(but,frame,mess=" ",side="right",relief="raised",short.cut=T,bwf=1){
  if(is.character(frame)) frame<-eval(parse(text=frame))
  b<-tkbutton(frame, text=but, relief=relief, pady=<<negativer y-Platz>>,
  	      width=floor(<<Knopfbreite>>*bwf), font=<<Font für Knöpfe>>)
  if(short.cut) tkconfigure(b,underline=0)
  tkbind(b,"<Enter>",function()set.tclvalue("tvmess",mess))
  tkbind(b,"<Leave>",<<relax-zeige-Funktion>>)
  tkpack(b, side=side)
  assign(but, b, envir=revive.sys)
}
@
vorher: -1
<<negativer y-Platz>>=
"-3"

@
Damit haben wir eine Standardisierung für Knöpfe vorgenommen.

@
\section{Reportloses Arbeiten --- Implementation}
\subsection{Implementation der Oberflächenelemente}

In diesem Abschnitt werden die Elemente der Oberfläche definiert, die
für den reportlosen Arbeitsstil erforderlich sind.

@
\subsubsection{Frames für das reportlose Arbeiten}
Das Top-Level-Fenster wird in horizontale Streifen aufteilt.
Diese werden als {\sc Tk}-Frames definiert.
Der oberste Streifen ([[fhead]]) dient dem Anstoß von Datei-Operationen,
Konfigurationsveränderungen und anderen allgemeinen Dingen. Als zweites
kommt ein Bereich, in dem der für Steuerungsfragen notwendige
Informationsaustausch abgewickelt wird: [[finfo]].
Dann folgt das Arbeitsfenster ([[fworkwin]]) selbst, in dem die Texte und
R-Aufträge niedergeschrieben werden.
Direkt zum Reportfenster / Arbeitsfenster gehörende
Information und Knöpfe werden im dritten Streifen ([[fworkcmds]]%
\footnote{Zuerst besaßen dieser Frame und auch verschiedene andere Objekte
den Namensbestandteil [[rep]] statt [[work]]. Als Folge führte die
Namensnähe zu [[rev]] wiederholt zu zeitaufwendigen Fehlersuchen.})
angebracht. Es folgt die Kommando-Leiste für das
Outputfeld und das Outputfeld selbst.

@
\paragraph{Veränderung der Text-Fenstergrößen}
Der gangbare Weg, um die beiden Fenster dynamisch zu vergrößern
bzw.\ verkleinern ist zunächst direkt mit Tcl/Tk probiert worden. Dabei
ergab sich folgender Entwurf:
\begin{verbatim}
button .b1
button .b2
frame .mitte -height 300 -width 900
pack  .b1
pack  .mitte -fill both -expand 1
pack  .b2
#ok
frame .mitte.top
frame .mitte.bottom
frame .mitte.handle -bd 2 -relief raised -bg red -cursor sb_v_double_arrow
place .mitte.top    -relwidth 1 -rely 0 -height -1 -anchor nw
place .mitte.bottom -relwidth 1 -rely 1 -height -1 -anchor sw
place .mitte.handle -relx 0.05 -width 10 -height 10 -anchor e
#ok

. configure -bg blue
bind . <Configure> {
  set H [winfo height .mitte].0
  set Y0 [winfo rooty .mitte]
}
bind .mitte.handle <B1-Motion> {
  set fract [expr (%Y -$Y0)/$H]
  if { $fract < 0.2 } {
    set fract 0.2
  }
  if { $fract > 0.8 } {
    set fract 0.8
  }
  place .mitte.top -relheight $fract
  place .mitte.handle -rely $fract
  place .mitte.bottom -relheight [expr 1.0 - $fract]
}

set fract 0.5
place .mitte.top -relheight $fract
place .mitte.handle -rely $fract
place .mitte.bottom -relheight [expr 1.0 - $fract]

frame .mitte.bottom.f1
text .mitte.bottom.f1.tt -yscrollcommand ".mitte.bottom.f1.scroll set"
scrollbar .mitte.bottom.f1.scroll -command ".mitte.bottom.f1.tt yview"
pack .mitte.bottom.f1.scroll -side right -fill y

frame .mitte.bottom.f2
frame .mitte.bottom.f3
button .mitte.bottom.f2.b1 -text "left: text.mitte.bottom.f2.b1"
button .mitte.bottom.f2.b2 -text "right: text.mitte.bottom.f2.b2"
button .mitte.bottom.f3.b1 -text "left: text.mitte.bottom.f3.b1"
button .mitte.bottom.f3.b2 -text "right: text.mitte.bottom.f3.b2"
pack .mitte.bottom.f2.b1 -side left
pack .mitte.bottom.f2.b2 -side right
pack .mitte.bottom.f3.b1 -side left
pack .mitte.bottom.f3.b2 -side right
pack .mitte.bottom.f2 -fill x
pack .mitte.bottom.f3 -fill x
pack .mitte.bottom.f1 .mitte.bottom.f1.tt -fill x
.mitte.bottom.f1.tt insert 0.0 [exec cat $env(HOME)/doof.rev]

# frame .mitte.top.f1
text .mitte.top.tt -yscrollcommand ".mitte.top.scroll set"
scrollbar .mitte.top.scroll -command ".mitte.top.tt yview"
pack .mitte.top.scroll -side right -fill y
pack .mitte.top.tt -fill x
.mitte.top.tt insert 0.0 [exec cat $env(HOME)/test.rev]
\end{verbatim}
Diesen Entwurf werden wir jetzt auf [[relax]] übertragen.

Zunächst benötigen wir folgende Frames:
[[fhead]] für die Menüleiste, [[finfo]] für Meldungen, [[finout]] für die
Textfenster und die Kommandoknöpfe.
<<generiere Top-Level-Fenster mit verschiedenen Frames>>=
fhead   <- tkframe(TopW, relief="raised", bd="1")
finfo     <- tkframe(TopW)
finout   <- tkframe(TopW,height="700",width="400")
tkpack(fhead, side="top",fill="x")
tkpack(finfo,   side="top")
tkpack(finout, side="top",fill="both",expand="1")

@
Der Frame [[finout]] wird in drei weitere Frames zerlegt: [[fworkwin]], [[fhandle]] und
[[fout]]:
<<generiere Top-Level-Fenster mit verschiedenen Frames>>=
fworkwin<-tkframe(finout)
fout        <-tkframe(finout)
fhandle   <-tkframe(finout,bd="2",relief="raised", bg="#BEE3D2",   # #87ff9D",
                                   cursor="sb_v_double_arrow")
tkplace(fworkwin, relwidth="1",rely="0",height="-1",anchor="nw")
tkplace(fout, relwidth="1",rely="1",height="-1",anchor="sw")
tkplace(fhandle, relx="1",width="1500",height="6",anchor="e")

@
Wenn sich bestimmte Verschiebungen ereignen, müssen die
Fenster angepasst werden.
<<generiere Top-Level-Fenster mit verschiedenen Frames>>=
proc<-paste(
  paste("bind ",TopW$ID," <Configure> {" ),
      paste("set H [winfo height ",finout$ID, "].0" ),
      paste("set Y0  [winfo rooty ",finout$ID, "]" ),
  "}",
  paste("bind",fhandle$ID," <B1-Motion> {"),
    "set fract [expr (%Y -$Y0)/$H]",
    "if { $fract < 0.1 } {",
    "  set fract 0.1",
    "}",
    "if { $fract > 0.95 } {",
    "  set fract 0.95",
    "}",
    paste("place ",fworkwin$ID," -relheight $fract"),
    paste("place ",fhandle$ID," -rely $fract"),
    paste("place ",fout," -relheight [expr 1.0 - $fract]"),
  "}",
  sep="\n")
.Tcl(proc)

@
Die Anfangsgrößenverteilung wird festgelegt.
<<generiere Top-Level-Fenster mit verschiedenen Frames>>=
fract<- 0.5
tkplace(fworkwin, relheight=fract)
tkplace(fhandle, rely=fract)
tkplace(fout, relheight=1-fract)

@
Jetzt können wir das Arbeitsfenster andenken. Dieses wird weiter unten
(siehe: [[tktext(fworkwin,...)]]) mit einem entsprechenden Scrollbar versehen.

@
Der untere Bildteil [[fout]] besteht aus drei Teilen:
dem Frame für die Arbeitsfenster-Kommandos:
[[fworkcmds]], dem für die Output-Fenster-Kommandos: [[foutcmds]] und
dem Frame für das Output-Text-Fenster [[foutwin]].
<<generiere Top-Level-Fenster mit verschiedenen Frames>>=
fworkcmds<-tkframe(fout, relief="raised", bd="0")
foutcmds<-tkframe(fout, relief="raised", bd="0") # ,background="#37D70F")
foutwin   <- tkframe(fout)
tkpack(fworkcmds,foutcmds,fill="x")
tkpack(foutwin,fill="both",expand="yes")

@
\subsubsection{[[fhead]]: [[File]], [[Edit]], [[Options]], [[Help.R]]}
Für Dateioperationen wird ein [[tkmenubutton]] links im Frame [[fhead]]
definiert. Daneben folgen weitere für Navigationsaufgaben und
Konfigurationseinstellungen.
Oben rechts erscheint ein Button zum Zugriff auf die R-Hilfe ([[Help.R]]).

@
\paragraph{Zum Kopf-Frame.}
Die notwendigen Menü-Knöpfe werden mit Hilfe von [[tkmenubutton]]
erzeugt. Die Objekte bekommen einen Namen, aus dem ihre Qualität
wie auch ihre Aufgabe zu ersehen ist. [[mb]] steht kurz für
[[menubutton]] und zum Beispiel [[Edit]] für das Menü zum Finden von
Dingen. Auf der Konstanten
@<<Knopfbreite>> ist eine standardisierte Breite einer
Box und auf @<<Font für Knöpfe>> ein Font abgelegt.
Es wird vereinbart, welche kurze Erklärung im Informationsfeld
angezeigt werden soll, wenn der Cursor auf den hier definierten Widgets steht.
Für Profis steht noch ein Menü mit Revweb-Funktionalitäten bereit.
Nach der Erzeugung der Elemente werden sie in den
bei der Generierung vereinbarten Frame von links nach rechts gepackt.
Zuerst die Menüelemente:
<<definiere Kopf-Frame>>=
mbFile<-tkmenubutton(fhead, text="File", font=<<Font für Knöpfe>>,
                     relief="flat", width=<<Knopfbreite>>) # alternativ groove
mbEdit<-tkmenubutton(fhead, text="Edit", font=<<Font für Knöpfe>>,
                     relief="flat", width=<<Knopfbreite>>)
mbOptions<-tkmenubutton(fhead, text="Options", font=<<Font für Knöpfe>>,
                        relief="flat", width=<<Knopfbreite>>)
if(but.Wizardry){
  mbRevweb<-tkmenubutton(fhead, text="Wizardry", font=<<Font für Knöpfe>>,
                        relief="flat", width=<<Knopfbreite>>)
}

@
Für die Kurzhilfe sei eine kleine Hilfsfunktion beschrieben,
die eine Funktion zur Setzung der kurze Hilfe als Funktion definiert.
Sie wird eingesetzt zur Definition der Folge des Event: Cursor betritt Feld.
In einem solchen Fall wird die Kurzhilfe gezeigt.
Im Falle des Verlassens muß eine Rücksetzung erfolgen.
<<definiere Kopf-Frame>>=
f<-function(mess) function()set.tclvalue("tvmess",mess)
tkbind(mbFile, "<Enter>", f("file operations and exit"))
tkbind(mbEdit, "<Enter>", f("searching and other operations"))
tkbind(mbOptions,  "<Enter>", f("change settings"))
if(but.Wizardry)  tkbind(mbRevweb,  "<Enter>", f("process document and specials"))
tkbind(mbFile, "<Leave>", <<relax-zeige-Funktion>>)
tkbind(mbEdit, "<Leave>", <<relax-zeige-Funktion>>)
tkbind(mbOptions, "<Leave>", <<relax-zeige-Funktion>>)
if(but.Wizardry)tkbind(mbRevweb, "<Leave>", <<relax-zeige-Funktion>>)
tkbind(finfo, "<Enter>", f("activate interactive icon"))
tkbind(finfo, "<Leave>", <<relax-zeige-Funktion>>)

@
<<relax-zeige-Funktion>>=
function(){ set.tclvalue("tvmess","relax") }
@
Zum Schluß können die neuen Elemente in den Frame gepackt werden.
<<definiere Kopf-Frame>>=
tkpack(mbFile,mbEdit,mbOptions,side="left")
if(but.Wizardry)tkpack(mbRevweb,side="left")
implement.but("Help.R", "fhead", "show online documentation of R object")

@
\paragraph{Datei- und andere dateinahe Operationen.}
Ein sauberer Ausstieg wird immer benötigt. Hierfür wird ein
Menüeintrag geschaffen.

@
Das Menü muss zunächst initialisiert werden.
<<definiere Kopf-Frame>>=
mbFile.menu<-tkmenu(mbFile,font=<<Font für Knöpfe>>)
tkconfigure(mbFile, menu=mbFile.menu)

@
Jetzt lässt sich der Menüeintrag zur Programmbeendigung eintragen.
<<definiere Datei-Menü-Eintrag zur Programmbeendigung>>=
tkadd(mbFile.menu, "command", label="Exit:   quit RELAX",
      command=Exit)
@
Die Beschreibung der zugehörigen Wirkungsfunktion
befindet sich im Abschnitt Implementationen.

@
\paragraph{Bearbeitungsoperationen -- Unterpunkte von [[Edit]].}
Gesucht werden könnten im Arbeitsfenster Zeichenketten oder Namen von
Code-Chunks oder aber ausgehend von Keywords nach R-Funktionen.
Dieses führt zu drei Einträgen im [[Edit]]-Menü.
<<definiere Kopf-Frame>>=
mbEdit.menu<-tkmenu(mbEdit,font=<<Font für Knöpfe>>)
tkconfigure(mbEdit, menu=mbEdit.menu)
tkadd(mbEdit.menu, "command", command=ShowAboutRwined,
      label="ShowAboutRwined:   what's relax?")
tkadd(mbEdit.menu, "separator")
tkadd(mbEdit.menu, "command", command=ShowShortCuts,
      label="ShowShortCuts:   show short cuts for text field")
tkadd(mbEdit.menu, "separator")
tkadd(mbEdit.menu, "command", command=FindRFns,
      label="FindRFns:   search R function by keyword")
tkadd(mbEdit.menu, "command", command=FindReportText,
      label="FindReportText:   search text string in text field  (Crtl+F)")
tkadd(mbEdit.menu, "command", command=FindReportChunk,
      label="FindReportChunk:   search code chunk in text field")
tkadd(mbEdit.menu, "command", command=FindLaTeXSection,
      label="FindLaTeXSection:   search for \\section, \\subsection and \\subsubsection")
tkadd(mbEdit.menu, "command", command=GoToLine,
      label="GoToLine:   go to line ... ")
tkadd(mbEdit.menu, "separator")
tkadd(mbEdit.menu, "command", command=InsertLaTeXEnv,
      label="InsertLaTeXEnv:   insert LaTeX environment")

@
<<unused>>=
tkadd(mbEdit.menu, "separator")
tkadd(mbEdit.menu, "command", command=InsertPlot,
      label="InsertPlot:   copy plot to ps / jpeg-file")
tkadd(mbEdit.menu, "command", command=InsertTeX,
      label="InsertTeX:    insert TeX-formated lines")
tkadd(mbEdit.menu, "separator")

@
\paragraph{Optionale Parameter.}
Zu den wichtigen Parametern, die unbedingt beeinflußbar sein sollten, zählen
Größe des Zeichensatzes, die Veränderung von Postscript-Bildmaßen
und die maximale Größe des Outputs.
<<definiere Kopf-Frame>>=
mbOptions.menu<-tkmenu(mbOptions, font=<<Font für Knöpfe>>)
tkconfigure(mbOptions, menu=mbOptions.menu)
tkadd(mbOptions.menu,"command", command=SetOutputLength,
      label="SetOutputLength: define maximal lines of output")
tkadd(mbOptions.menu, "separator")
tkadd(mbOptions.menu,"command", command=SetFontType,
      label="SetFontType:   define font type")
tkadd(mbOptions.menu,"command", command=SetFontSize,
      label="SetFontSize:   define font size")
tkadd(mbOptions.menu, "separator")
tkadd(mbOptions.menu,"command", command=SetPlotHeight,
      label="SetPlotHeight:  define height of plot (-> latex)")
tkadd(mbOptions.menu,"command", command=SetPSDesignWidth,
      label="SetPSWidth:   define width of ps-graphics")
tkadd(mbOptions.menu,"command", command=SetPSDesignHeight,
      label="SetPSHeight:  define height of ps-graphics")
tkadd(mbOptions.menu, "separator")
tkadd(mbOptions.menu,"command", command=ConfigRelax,
      label="Configure Relax: view or change parameters of relax")
@
<<unused>>=
tkadd(mbOptions.menu,"command", command=SetPSWidth,
      label="SetPlotWidth:   define width of plot (-> latex)")
tkadd(mbOptions.menu,"command", command=SetPSWidth,
      label="SetPlotWidth:   define width of plot (-> latex)")

@
\paragraph{Revweb-Funktionalitäten.}
Die logische Variable [[but.Wizardry]] wird über den Funktionsaufruf gesetzt.
<<definiere Kopf-Frame>>=
if(but.Wizardry){
 mbRevweb.menu<-tkmenu(mbRevweb,font=<<Font für Knöpfe>>)
 tkconfigure(mbRevweb, menu=mbRevweb.menu)
 tkadd(mbRevweb.menu,"command", command=ProcessReport,
      label="ProcessReport:  SaveReport, WeaveReport, and LatexReport")
 tkadd(mbRevweb.menu,"command", command=ViewReport,
      label="ViewReport:   show formated report")
 tkadd(mbRevweb.menu, "separator")
 tkadd(mbRevweb.menu,"command", command=LaTeX.head,
      label="LaTeX.head:   include simple LaTeX head")
 tkadd(mbRevweb.menu,"command", command=WebReport,
      label="WebReport:   weave and tangle source file")
 tkadd(mbRevweb.menu,"command", command=LatexReport,
      label="LatexReport:   format Latex file")
 tkadd(mbRevweb.menu,"command", command=ShowLogFile,
      label="ShowLogFile:   open Latex log file by editor")
 tkadd(mbRevweb.menu,"command", command=DvipdfReport,
      label="DvipdfReport:   translate dvi- in pdf-file")
 ##tkadd(mbRevweb.menu, "separator")
 ##definiere ggf.\ Eintrag [[FormatTeXLines]]##
 ##erstelle Menüeintrag für Funktionstasten-Puffer##
 ## tkadd(mbRevweb.menu, "separator")
 ## tkadd(mbRevweb.menu,"command", command=LoadRwtools,
     ## label="LoadR-wtools:   load some functions: stem.leaf, ... and some data sets")
}

@
<<definiere ggf.\ Eintrag [[FormatTeXLines]]>>=
FTL.ok<-FALSE
if( <<das OS ist Windows>> ){
      libpath<-file.path(relax.path,"lib")
      if(file.exists(file.path(libpath,"pnmcrop.exe")) &&
         file.exists(file.path(libpath,"ppmtojpeg.exe")) &&
	 file.exists(file.path(libpath,"netpbm.dll")) &&
	 file.exists(file.path(libpath,"libjpeg.dll"))) FTL.ok<-TRUE
}
if(<<das OS ist Linux>>){
   if(0<length(system("which convert",TRUE,TRUE)) &&
      0<length(system("which dvips",TRUE,TRUE))) FTL.ok<-TRUE
  }
if(FTL.ok){
  tkadd(mbRevweb.menu, "command", command=FormatTeXLines,
            label="FormatTeXLines:   format text chunk by LaTeX and insert  jpeg-file")
  tkadd(mbRevweb.menu, "separator")
}

@
\subsubsection{[[finfo]]: Der Frame für den Informationsaustausch}

Zwischen dem Kopf\-frame und dem zur Steuerung des Arbeitsfensters
ist ein schmaler Streifen für den Informationsaustausch vorgesehen.
In diesem sollen zum Beispiel die Erklärungstexte zu den Knöpfen oder
Zustandsmeldungen erscheinen.
Die Info-Zeile besteht aus dem Schlüsselwort [[Info:]] und
aus einem Label-Widget [[linfo]], das die jeweilige Nachricht anzeigt.
<<definiere Info-Frame>>=
linfo.name <- tklabel(finfo, text=" ", font=<<Font für Knöpfe>>)
linfo      <- tklabel(finfo, text=" ", textvariable="tvmess",
                      width=<<Infofeldbreite>>, relief="ridge")
<<plaziere [[linfo.name]] und [[linfo]] in den Infoframe>>
tkbind(linfo,"<ButtonPress>",<<generiere interaktives icon>>)
@
brelax<-tkbutton(finfo,relief="flat",text="icon",command=<generiere interaktives icon>)
tkpack(brelax,side="left")

@
<<generiere interaktives icon>>=
function(){
  res<-tkmessageBox(message=if(language=="german") "Soll das interaktive Icon aktiert werden?"
	    else "Do you want to activate interactive icon?",
                    title="RELAX-ICON",icon="warning",type="yesnocancel",default="no")
  if("externalptr"==mode(res))  res<-tclvalue(res)
  if(res=="cancel") return()
  if(res=="no") return()

chair<-function(xcenter=1.2,xspread=1,ycenter=1.2,yspread=1,lwd=4){
  # cat("chair: ", xcenter,xspread,ycenter,yspread)
  x<-seq(0,1.6,length=(n<-40))
  xshift<-.5;ystretch<-1.2; height<-.4/yspread
  y<-0.5*cosh(ystretch*x-xshift);
  y<-scale(y-y[1]-.06,-ycenter,1/yspread)
  x<-scale(x/1.6,-xcenter,1/xspread)
  segments(x[1],y[1],x[1]*.1+x[n]*.9,y[1]-height,lwd=lwd)
  segments(x[1],y[1]-height,x[n],y[n],lwd=lwd)
  lines(x,y,lwd=lwd)
}
tree<-function(xcenter=.51,xspread=1.5,ycenter=0,yspread=2,lwd=3,n=5,n.l=10){
  # cat(xcenter,xspread,ycenter,yspread)
  yspread<-yspread/2.5; ycenter<-ycenter+.15
  leaf<-function(von,start,delta,len,n.l=10,krum.par){
   xy.mat<-matrix(von,2,n.l)
   h<-start*2*pi/360
   xy.delta<-c(cos(h),sin(h))/n.l
   delta<-delta*2*pi/360*len/n.l
   for(i in 2:n.l){
    w<-delta
    xy.delta<-matrix(c(cos(w),-sin(w),sin(w),cos(w)),2,2)%*%xy.delta
    xy.mat[,i]<-xy.mat[,i-1]+xy.delta
   }
   delta.y<-qbeta((0:n.l)/n.l,2,3)
   delta.y<-.04*cumsum(sin((0:(n.l-1))/(n.l)*2*pi))
   xy<-t(xy.mat) # +von-xy.mat[,1])
   xy[,1]<-scale(xy[,1]*xspread/2,-xcenter,1)#2/xspread)
   xy[,2]<-(xy[,2]*yspread+ycenter)
   delta.y<-(delta.y*yspread)
   #lines(xy[,1],xy[,2],lwd=3) #lines(xy[,1],xy[,2]+delta.y,lwd=3)
   polygon(c(xy[,1],rev(xy[,1])),c(xy[,2],rev(xy[,2]+delta.y)),col="green",border=NA,xpd=NA)
  }
  x<-seq(-50,90,length=floor(n/2))
  for(i in x){
    leaf(von=c(0,0),start=i,delta=5,len=10,n.l=n.l)
    x<-seq(-50,90,length=ceiling(n/2))
  }
  for(i in x) leaf(von=c(0,0),start=190-i,delta=-5,len=10,n.l=n.l)
  segments(xcenter-0.02*xspread,ycenter,
           xcenter-0.05*xspread,ycenter-1.5*yspread,lwd=1)
  segments(xcenter+0.02*xspread,ycenter,
           xcenter+0.05*xspread,ycenter-1.5*yspread,lwd=1)
} # end of tree
redo<-function(...){
  ytrsc<-xtrsc<-slider(no=1); xchsc<-slider(no=2)
  ychsc<-slider(no=3);hori<-slider(no=4);n.leafs<-slider(no=5)
  leaf.sty=slider(no=6)
  h<-slider(obj.name="tree.center"); xtrcenter<-h[1]; ytrcenter<-h[2]
  h<-slider(obj.name="chair.center"); xchcenter<-h[1]; ychcenter<-h[2]
  a<-par(family="mono")
  plot(-2:2,-2:2,type="n",axes=F,xlab="",ylab=""); # text(.6,1.8,"relax",cex=4)
  polygon(2*c(-2,-2,2,2),c(hori,-3,-3,hori),col="#fcf1a2",border=NA,xpd=NA)
  polygon(2*c(-2,-2,2,2),c(hori,3,3,hori),col="#c8e6f2",border=NA,xpd=NA)
  text(0.5,-.5,"relax",cex=4)
  tree(xcenter=xtrcenter,xspread=xtrsc,n=n.leafs,n.l=leaf.sty,
       ycenter=ytrcenter,yspread=ytrsc,lwd=3)
  chair(xcenter=xchcenter,xspread=xchsc,
        ycenter=ychcenter,yspread=ychsc,lwd=3)
  par(family=a)
}
  slider(obj.name="tree.center",obj.value=c(-1.1,.8))
  slider(obj.name="chair.center",obj.value=c(.3,-1.2))
  set.tree<-function(...){
    xy<-locator(n=1)
    slider(obj.name="tree.center",obj.value=c(xy$x,xy$y))
    redo()
  }
  set.chair<-function(...){ #   xy<-locator(n=1); xy<-c(xy$x,xy$y)
    xy<-c(runif(1,-1,1),runif(1,-1.5,0))
    slider(obj.name="chair.center",obj.value=xy)
    redo()
  }
  slider(redo,
    c("tree scale factor", "x scale chair",
      "design of chair", "size of beach",
      "number of leafs", "style of leafs"),
    c(.1,.1,.1,-2,7,5),c(5,2.4,2.4,2,17,30),
    c(.1,.1,.1,.1,1,1),c(3.5,1.2,1.2,-0.7,9,12),
    list(set.tree,set.chair),
    but.names=c("tree location","new chair location")
  )
  "relax"
}

@
Da dieser Frame für unterschiedliche Dinge genutzt wird, muß
zur Normalisierung dieser wieder reinitialisiert werden. Deshalb wird
das Packen als isolierter Chunk bereitgestellt.
<<plaziere [[linfo.name]] und [[linfo]] in den Infoframe>>=
tkpack(linfo.name,linfo,side="left",fill="x")

@
Außerdem sollen im Frame [[finfo]]
Antworten auf Steuerungsfragen, wie Dateinameneingabe, abgehandelt werden.
Für solche Dialoge werden dann temporär das Label-Widget [[linfo.tmp]]
für den Frage-Text und das Entry-Widget [[einfo.tmp]]
für das Eingabefeld in den Info-Frame gepackt.
Das Eingabefeld wird mit der Variable [[tvinfo]] verbunden.
Diese Elemente erscheinen aber nur im Bedarfsfall.
<<definiere Info-Frame>>=
einfo.tmp <- tkentry(finfo,textvariable="tvinfo",background="#7ff",
                     width=floor(as.numeric(<<Infofeldbreite>>)*3/5))
linfo.tmp <- tklabel(finfo)

@
\subsubsection{[[fworkcmds]]: [[Up]], [[Down]], [[TrashROutput]], [[PlanRCode]],
               [[EvalRCode]]}
Die wesentliche Arbeit wird im Arbeitsfenster, das im Folgenden auch als
Reportfenster bezeichnet wird, geschehen.
Über diesem sollen sich Knöpfe für Aktionen befinden, die unmittelbar
für die Arbeit mit dem Report wichtig sind.
Weiterhin erscheint als Information der aktuelle Name des Reports.

Die Kommandos zur Speicherung von Bildern, zum Kopieren eines alten Code-Chunk,
zur Vorbereitung eines neuen Code-Chunk und zum Start des letzten Code-Chunk
werden von rechts beginnend in den Frame gepackt.
Die Variable [[workname.sys]] speichert den Reportnamen,
[[lworkname.sys]] den Namen des Labelfeldes, in dem der Name angezeigt wird.

<<definiere Report-Aktionsframe>>=
implement.but("TrashROutput", "fworkcmds", "remove output the mouse is pointing at from report" )
implement.but("EvalRCode",   "fworkcmds", "evaluate code chunk of cursor" )
implement.but("PlanRCode",    "fworkcmds", "insert new code chunk" )

tkpack(tklabel(fworkcmds, text=" Report:",
       pady=<<negativer y-Platz>>,font=<<Font für Knöpfe>>),
       # ipady=7,
       side="left")
lworkname.sys<-tklabel(fworkcmds, text=workname.sys,
                    pady=<<negativer y-Platz>>, relief="ridge")
tkpack(lworkname.sys, side="left")

implement.but("Down",   "fworkcmds", "jump forwards",side="left",bwf=0.40 )
implement.but("Up",   "fworkcmds", "jump backwards",side="left",bwf=0.40 )

implement.but("RemoveOut",foutcmds,"remove output from output field")
implement.but("SavePlot",foutcmds,
          "save plot as jpeg and postscript file and insert it into report field")
implement.but("Insert",foutcmds,"insert output into report")
tkpack(tklabel(foutcmds, text=" Result(s):",pady=<<negativer y-Platz>>,
	font=<<Font für Knöpfe>>), 
	#ipady=7, 
	side="left")


@
\subsubsection{[[fworkwin]]: Der Frame zur Reportbearbeitung}
Als Fenster zur Bearbeitung des aktuellen Reports dient ein einfaches
Text-Widget.
Die Breite des Fensters wurde zunächst
über die {\sc Tcl}-Variable [[twinwidth]]
gesteuert, die Höhe über [[tworkheight]].
Jedoch erwies sich die explizite Eingabe der Maße als zu lästig, so daß
jetzt das Arbeitsfenster über Mausaktionen verändert werden kann.
Das Report-Fenster paßt sich in der Breite und der Höhe automatisch an.
Weiterhin wird für Windows-Freunde PASTE über [[Crtl-v]] realisiert.
<<definiere Report-Text-Frame>>=
tworkwin<-tktext(fworkwin, background="#c81e6ff23", font=tfont.sys, undo=1)#cff#d0f0ff
workbar<-tkscrollbar(fworkwin)
tkconfigure(tworkwin,yscrollcommand=function(...) tkset(workbar,...))
tkconfigure(workbar, command=function(...) tkyview(tworkwin,...))
tkpack(workbar ,side="right",fill="y")
tkpack(tworkwin,fill="both",expand="yes")
tkinsert(tworkwin,"0.0",paste("% New Report:",date(),"\n"))
### CLIPBOARD-Funktion PASTE a la windows
tkevent.add("@<<Paste>>",   "<Control_L><v>")
tkbind(tworkwin,"@<<Paste>> { catch {%W insert insert [selection get -selection CLIPBOARD] } }")


@
<<alte Version: Verwendung von [[.Tk.ID]]>>=
#tkconfigure(tworkwin,yscrollcommand=paste(.Tk.ID(workbar) ,"set"))
#tkconfigure(workbar,        command=paste(.Tk.ID(tworkwin),"yview"))
@
Es sei noch aufgelistet, wie die Editor-Kommandos funktionieren:
\begin{verbatim}
D-5: Cut, Copy and Paste in the Tcl Console Window

The Tcl Console window uses the default bindings for the Tcl text widget, 
which is not compatible with the Windows standard of

    * Ctrl-x: cut
    * Ctrl-c: copy
    * Ctrl-v: paste

Instead, the Tcl Console window (by default) uses the following bindings:

    * Ctrl-x: deletes selected text
    * Ctrl-w: cut
    * Alt-w: copy
    * Ctrl-y: paste

-Eric Foster-Johnson
Quelle:
http://ourworld.compuserve.com/homepages/efjohnson/tclwin.htm
\end{verbatim}

@
\subsubsection{[[foutwin]]: Der Frame zur Ergebnisanzeige}
Als Fenster zur Anzeige von Ergebnissen reicht ebenfalls ein einfaches
Text-Widget. Die Konstruktion ist identisch zu der des Report-Frame.
Dem üblen Gummi-Effekt unter manchen Windows-Versionen,
wird auch in diesem Chunk zu Leibe gerückt.
<<definiere Report-Text-Frame>>=
toutwin<-tktext(foutwin,height=8,background="#fc8f16a23", font=outfont.sys) #fff080
outbar<-tkscrollbar(foutwin)
tkconfigure(toutwin,yscrollcommand=function(...) tkset(outbar,...))
tkconfigure(outbar,        command=function(...) tkyview(toutwin,...))
tkpack(outbar ,side="right",fill="y")
tkpack(toutwin,fill="both",expand="yes")
if(<<das OS ist Windows>>) #{}
{ # 110505
# fout<-get("fout",env=revive.sys); toutwin<-get("toutwin",env=revive.sys)
 tkbind(fout,"<Configure>","")
 config.fns<-function(...){
  if("1"==tclvalue(tkwinfo("ismapped",toutwin))){
      tkpack("forget",toutwin) #; tkbind(toutwin,"<Configure>","")
      Sys.sleep(.01)
      if("0"==tclvalue(tkwinfo("ismapped",toutwin))){
        tkpack(toutwin,fill="both",expand="yes")
      }
  }
 }
 tkbind(fout,"<Configure>",config.fns)
}

@
<<definiere Report-Text-Frame, neu aber mit Gummieffekt>>=
toutwin<-tktext(foutwin,height=8,background="#fc8f16a23", font=outfont.sys) #fff080
outbar<-tkscrollbar(foutwin)
tkconfigure(toutwin,yscrollcommand=function(...) tkset(outbar,...))
tkconfigure(outbar,        command=function(...) tkyview(toutwin,...))
tkpack(outbar ,side="right",fill="y")
tkpack(toutwin,fill="both",expand="yes")
if(<<das OS ist Windows>>)
{ # 260405
 config.fns<-function(...){
  if("1"==tclvalue(tkwinfo("ismapped",toutwin))){
      tkpack("forget",toutwin) # ;tkbind(outbar,"<Configure>","")
      Sys.sleep(.2)
      if("0"==tclvalue(tkwinfo("ismapped",toutwin))){
        tkpack(toutwin,fill="both",expand="yes")
      }
  }
 }
 tkbind(outbar,"<Configure>",config.fns)
}
@
<<definiere Report-Text-Frame-old>>=
toutwin<-tktext(foutwin,height=8,background="#fc8f16a23", font=outfont.sys) #fff080
outbar<-tkscrollbar(foutwin)
tkconfigure(toutwin,yscrollcommand=function(...) tkset(outbar,...))
tkconfigure(outbar,        command=function(...) tkyview(toutwin,...))
tkpack(outbar ,side="right",fill="y")
tkpack(toutwin,fill="both",expand="yes")
if(<<das OS ist Windows>>){
 config.fns<-function(...){
  if("1"==tclvalue(tkwinfo("ismapped",toutwin))){
      tkpack("forget",toutwin);tkbind(TopW,"<Configure>","")
  }
 }
 tkbind(TopW,"<Configure>",config.fns)
 tkbind(TopW,"<Motion>",function(...){
  if("0"==tclvalue(tkwinfo("ismapped",toutwin))){
    width <-tclvalue(tkwinfo("width", TopW))
    height<-tclvalue(tkwinfo("height",TopW))
    Sys.sleep(.05)
    if(height==tclvalue(tkwinfo("height",TopW))
       &width==tclvalue(tkwinfo("width",TopW))){
      tkpack(toutwin,fill="both",expand="yes")
      tkbind(TopW,"<Configure>",config.fns)
    }
  }
 })
}

@
Zur Abhebung von Texten und Code-Stücken sollen die unterschiedlichen
Qualitäten in etwas unterschiedlicher Weise dargestellt werden.
Farbegestaltung: Text $\to$ schwarz, Code $\to$ rot, Output $\to$ blau,
Code-Chunk-Header $\to$ dunkelrot und etwas emporgehoben.
Dazu helfen die {\sc Tcl/Tk}-Prozeduren [[emphline]] (z.Z.\ unbenutzt),
[[marklinetypes]] (zur Feststellung der Qualität einer Zeile) und
[[markclear]] (zur Entfernung von Markierungen für Aktualisierungen).
Früher wurde die Funktion [[markreport]] der Handlichkeit wegen definiert
-- sie wurde nur an dieser Stelle verwendet. Inzwischen
wurde sie durch eine namenslose ersetzt.

@
Durch den Aufruf [[.Tcl(proc)]] werden die Prozeduren an [[Tcl/Tk]]
übergeben.
<<definiere Report-Text-Frame>>=
( # def. namenslose Funktion:
function(tworkwin){
 tktag.configure(tworkwin,"tld",   foreground="#C8162315126C", relief="raised",
                 borderwidth="2") # alternativ: #aaa222111
 tktag.configure(tworkwin,"tex",   background="#fffffffff", relief="raised",
                 borderwidth="2")
 tktag.configure(tworkwin,"code",  foreground="#d21", font=outfont.sys) # ddd222222
 tktag.configure(tworkwin,"output",foreground="#111222999", font=outfont.sys)
 tktag.configure(tworkwin,"emph",  background="#999999999")
 proc<-paste(
  "proc emphline {w mustera musterz} {",
    "scan [$w index end] %d anzzeilen", "set emphline 0\n",
    "for {set i 1} {$i < $anzzeilen} {incr i} {",
      "set actline [$w get $i.0 $i.end]",
      "if {[regexp $mustera $actline]} {",
        "if {[regexp $musterz $actline]} {",
          "uplevel $w tag add emph $i.0 $i.end",
        "}",
      "}",
    "}",
  "}", # type-semantics: 0=text, 1=tld, 2=code, 3=output
  "proc marklinetypes {w} {",
    "scan [$w index end] %d anzzeilen",
    "set type 0\n",
    "for {set i 1} {$i < $anzzeilen} {incr i} {",
     "set zeile [$w get $i.0 $i.end]",
     "if {$type==1}                           {\n set type 2\n}",
     "if {[regexp \"^@\"             $zeile]} {\n set type 0\n}",
     "if {[regexp \"^@<<.*>>=\"     $zeile]} {\n set type 1\n}",
     "if {[regexp \"^\\\\\\\\s(u|e)\" $zeile]} {\n set type 4\n}",
     "if {[regexp \"^output-start\"  $zeile]}  {\n set type 3\n}",
     "if {[regexp \"^\\\\\\\\begin\\{verbatim\\}\" $zeile]} {\n set type 3\n}",
     "if {$type==1} {\n uplevel $w tag add tld     $i.0 $i.end \n}",
     "if {$type==2} {\n uplevel $w tag add code    $i.0 $i.end \n}",
     "if {$type==3} {\n uplevel $w tag add output  $i.0 $i.end \n}",
     "if {$type==4} {\n uplevel $w tag add tex     $i.0 $i.end",
                                                 "; set type 0 \n}",
     "if {[regexp \"^output-end\"  $zeile]} {\n set type 0\n}",
     "if {[regexp \"^\\\\\\\\end\\{verbatim\\}\" $zeile]} {\n set type 0\n}",
    "}",
  "}",
  "proc markclear w {",
    "$w tag remove tld    1.0 end",
    "$w tag remove tex    1.0 end",
    "$w tag remove code   1.0 end",
    "$w tag remove output 1.0 end",
  "}", sep="\n")
  .Tcl(proc)
}  # und Aufruf der namenslosen Funktion:
)(tworkwin)

@
Zunächst werden die alten Setzungen entfernt. Dann wird für alle
Fälle der Output-Font neu gesetzt, denn für den Output wurde er
im Rahmen der Tag-Festlegung vereinbart.
<<aktualisiere Texthervorhebungen>>=
melde("ak texthervor",1)
tkcmd("markclear",tworkwin)
tktag.configure(tworkwin,"output",foreground="#111222999", font=outfont.sys)
tktag.configure(tworkwin,"code",  foreground="#ddd222222", font=outfont.sys)
tkcmd("marklinetypes",tworkwin)
melde("ak texthervor",2)

@
\nopagebreak
Damit ist die Oberfläche für ein normales Arbeiten skizziert.
Jetzt müssen die Wirkungen implementiert werden.

@
\subsection{Implementation der Funktionalitäten}

In der Kopfzeile sind Menüeinträge vorbereitet worden,
mit denen einige Einstellungen verändert werden können, die das Auf\-finden
verschiedener Dinge unterstützen sollen, und damit das Programm ordnungsgemäß
verlassen werden kann. Genauer sind die Funktionen zu den Punkten
[[File]], [[Edit]], [[Options]] und [[Help.R]] zu definieren.
Für die Steuerung des Arbeitsfeldes müssen die Funktion zu den Knöpfen
[[EvalRCode]], [[PlanRCode]], [[Up]], [[Down]] sowie
[[TrashROutput]] definiert werden.

@
\paragraph{Technische Bemerkungen:}
Vorwegschickt sei, dass später eine Funktion [[melde]] definiert wird,
die für Debugging-Zwecke anzeigt, welche Funktion gerade arbeitet oder
gibt einfach nur Text-Strings aus.
[[melde( xyz ,"cmd.msg")]] legt den Befehl [[xyz]] auf einem Befehlsspeicher
ab, so dass die zuletzt durchgeführte Operation rekonstruierbar ist.
Weiter zeigt eine Tcl-Variable [[tvexit]] an, ob [[relax]] beendet worden ist.
Die Tcl-Variable [[tvinfo]] speichert vom Anwender eingebene Namen,
Größen oder Texte.
Die Funktion [[set.tclvalue]] hilft bei der Setzung von Tcl/Tk-Variablen.

@
\subsubsection{Kopfzeile: [[File]]}

Als einziger Eintrag in dem Aktionsmenü ist bisher [[Exit]] beschreiben worden.

@
\subsubsection{Kopfzeile: [[File]] --- [[Exit]]}
\paragraph{[[Exit]] zur Beendigung des Programms.}

Die wesentliche Arbeit für die Programmbeendigung leistet die Funktion
[[tkdestroy]]. Für alle Fälle wird die Variable [[tvexit]] neu
gesetzt, so daß sich davon abhängige Widgets beenden können.
Wie auch bei allen weiteren Funktionen wird zur Erleichterung von
Fehleruntersuchungen am Beginn und am Ende mit Hilfe der Funktion
[[melde]] eine Zustandsinformation festgehalten.
Mit Hilfe der Konstruktion [[melde("q","cmd.msg")]] wird die Exit-Operation
in wiederholbarer Form kodiert.
@
<<definiere Kopf-Zeilen-Funktionen>>=
Exit<-function(){
  melde("Exit",1)
  res<-tkmessageBox(message=
            if(language=="german") "Report-Manager ohne erneute Speicherung beenden?"
	    else "Quit RELAX without saving again?",
                    title="Exit",icon="warning",type="yesnocancel",default="no")
  if("externalptr"==mode(res))  res<-tclvalue(res)
  if(res=="cancel") return()
  if(res=="no") SaveReport()
  set.tclvalue("tvexit","fertig"); tkdestroy(TopW)
  remove("print",pos=which(.path.package("relax")==searchpaths()))
  melde("==================================================\n")
  melde("RELAX --- EXIT                    \n")
  # melde("copy of report saved as: \n")
  # melde(" report-UnDo-bak.rev                           \n")
  melde("restart RELAX by: \n relax()           \n")
  melde("==================================================\n")
  melde("q","cmd.msg")
  melde("Exit",2)
}

@
\subsubsection{Kopfzeile: [[Optionen]]}
Für das Menü zur Änderung von Parametern sind folgende fünf Funktionen
zu definieren:
[[SetPSWidth]],
[[SetPlotHeight]],
[[SetFontType]],
[[SetFontSize]] und
[[SetOutputLength]].

\subsubsection{Kopfzeile: [[Optionen]] --- [[SetPSWidth]] und [[SetPlotHeight]]}
\paragraph{[[SetPSWidth]] und [[SetPlotHeight]]
           zur Veränderung der Breite und Höhe einer PS-Graphik.}
Diese Funktionen befragen den Anwender und setzen die Variablen
[[pswidth.sys]] und [[psheight.sys]] in der Umgebung [[revive.sys]] neu.
Hier ist zum ersten Mal ein Dialog zu erkennen. Nach Belegung von
[[frage]] und nach Speicherung des alten Wertes auf [[tvinfo]]
wird die Antwort erfragt.
Außerdem wird dafür Sorge getragen, daß bei einem {\sc Escape}-Druck sich
der Normalzustand wieder einstellt.
An einen {\sc Return}-Druck wird eine Rücksetzung gebunden und außerdem
wird die eingelesene Information auf der Variablen
[[pswidth.sys]] abgelegt. Zum Schluß erfolgt eine wiederholbare
Kodierung des ausgeführten Befehls.
<<definiere Kopf-Zeilen-Funktionen>>=
SetPSDesignWidth<-function(){
  melde("SetPSDesignWidth",1)
  frage<-"ps design width?"; set.tclvalue("tvinfo",psdesignwidth.sys)
  <<frage [[frage]], biete [[tvinfo]] als Antwort an>>
  tkbind(TopW,"<Return>",
    function(){
      <<setze Manager nach {\sc Return} in Normalzustand>>
      h<-as.numeric(tclvalue("tvinfo"))
      assign("psdesignwidth.sys",h,env=revive.sys)
      melde(paste('> assign("psdesignwidth.sys","',psdesignwidth.sys,'",env=revive.sys)',sep="")
                , "cmd.msg")
    }
  )
  melde("SetPSDesignWidth",2)
}
@
Die Weite wird nicht mehr explizit gesetzt, sondern von \LaTeX\ angepasst.
<<unused>>=
SetPSWidth<-function(){
  melde("SetPSWidth",1)
  frage<-"ps width?"; set.tclvalue("tvinfo",pswidth.sys)
  <<frage [[frage]], biete [[tvinfo]] als Antwort an>>
  tkbind(TopW,"<Return>",
    function(){
      <<setze Manager nach {\sc Return} in Normalzustand>>
      pswidth.sys<-tclvalue("tvinfo")
      assign("pswidth.sys",pswidth.sys,env=revive.sys)
      melde(paste('> assign("pswidth.sys","',pswidth.sys,'",env=revive.sys)',sep="")
                , "cmd.msg")
    }
  )
  melde("SetPSWidth",2)
}

@
Möglicherweise kann später als Erweiterung eine Funktion
[[SetPSWidth.bat]] mit angeboten werden, mit der sich
die Variable [[pswidth.sys]] direkt setzen läßt. Entsprechendes
läßt sich auch für andere Knöpfe erfinden. Hier das Muster:
<<unused: future version>>=
SetPSWidth.bat<-function(pswidth.sys){
      assign("pswidth.sys",pswidth.sys,env=revive.sys)
      melde(paste("> pswidth.sys <-",pswidth.sys),"cmd.msg")
}
environment(SetPSWidth.bat)<-revive.sys


@
Viele der im folgenden definierten Funktionen haben einen sehr ähnlichen
Aufbau. Deshalb bietet es sich an, einige wiederkehrende Sequenzen als
Code-Chunks zu definieren.

Zur Veränderung des
Arbeitsfeldes sollte dem Anwender eine entsprechende Frage gestellt
und ein Defaultwert angeboten werden. Durch Definition eines
Frage-Antwort-Moduls werden
weitere Frage-Antwort-Situationen wartungsfreundlich gelöst.
Als Kanal dient -- wie bereits angekündigt -- die {\sc Tcl}-Variable [[tvinfo]].

In dem Moment, in dem der Anwender eine Eingabe machen kann, wird die
Wirkung der {\sc Return}-Taste umdefiniert
(siehe dazu in der letzten Sektion: [[tkbind(TopW,"<Return>",...]]).
Durch Druck der {\sc Escape}-Taste soll die Eingabe ohne schädliche Wirkung
verlassen werden.

Die Fragestellung führt zur Umdefinition des Inhalts des zweiten Streifens.
Die gestellte Frage wird eingeblendet, ebenso der Defaultwert der Eingabe.
Außerdem wird {\sc Escape} zum vorzeitigen Verlassen der Eingabeauf\-forderung
definiert.
<<frage [[frage]], biete [[tvinfo]] als Antwort an>>=
tkconfigure(linfo.tmp,text=frage)
tkpack("forget",linfo.name,linfo)
tkpack(linfo.tmp,einfo.tmp,side="left")
tkfocus(einfo.tmp)
<<definiere {\sc Escape} bei Texteingabe als Notausgang>>

@
{\sc Escape} setzt den Info-Frame zurück.
<<definiere {\sc Escape} bei Texteingabe als Notausgang>>=
tkbind(TopW,"<Escape>",function(){
    <<setze Manager nach {\sc Return} in Normalzustand>>
  }
)

@
Zurücksetzen bedeutet, das Eingabefeld und die Frage zu entfernen
und die ursprünglichen Widgets in den Frame hineinzupacken.
<<setze Manager nach {\sc Return} in Normalzustand>>=
tkbind(TopW,"<Return>","")
tkpack("forget",einfo.tmp,linfo.tmp)
<<plaziere [[linfo.name]] und [[linfo]] in den Infoframe>>

@
[[SetPlotHeight]] sieht entsprechend aus.
<<definiere Kopf-Zeilen-Funktionen>>=
SetPlotHeight<-function(){
  melde("SetPlotHeight",1)
  frage<-"ps height?"; set.tclvalue("tvinfo",psheight.sys)
  <<frage [[frage]], biete [[tvinfo]] als Antwort an>>
  tkbind(TopW,"<Return>",
    function(){
      <<setze Manager nach {\sc Return} in Normalzustand>>
      psheight.sys<-tclvalue("tvinfo")
      assign("psheight.sys",psheight.sys,env=revive.sys)
      melde(paste('> assign("psheight.sys","',psheight.sys,'",env=revive.sys)',sep="")
            ,"cmd.msg")
    }
  )
  melde("SetPlotHeight",2)
}
SetPSDesignHeight<-function(){
  melde("SetPSDesignHeight",1)
  frage<-"ps design width?"; set.tclvalue("tvinfo",psdesignheight.sys)
  <<frage [[frage]], biete [[tvinfo]] als Antwort an>>
  tkbind(TopW,"<Return>",
    function(){
      <<setze Manager nach {\sc Return} in Normalzustand>>
      h<-as.numeric(tclvalue("tvinfo"))
      assign("psdesignheight.sys",h,env=revive.sys)
      melde(paste('> assign("psdesignheight.sys","',psdesignheight.sys,'",env=revive.sys)',sep="")
                , "cmd.msg")
    }
  )
  melde("SetPSDesignHeight",2)
}

@
\subsubsection{Kopfzeile: [[Optionen]] --- [[SetFontType]]}
\paragraph{[[SetFontType]] zur Auswahl eines Zeichensatzes.}
Dem Anwender werden nur die beiden Möglichkeiten
gegeben, die Größe und den Typ des Zeichensatzes zu verändern.
Dabei darf er wiederum jeweils nur aus einer begrenzten Menge
Möglichkeiten wählen. Um die Mißverständnisse klein zu halten,
sind in dem Optionenmenü deshalb zwei Eintragungen vorgesehen worden.

Besonders muß bei der Veränderung dieser Funktionen auf die Unterstützung
deutscher Umlaute geachtet werden. Für andere Anlagen kann der folgende
Vorschlag natürlich Anpassungen erfordern.

Der eingestellte Zeichensatz wird auf der Variablen [[tfont.sys]]
gehalten. Durch eine einfache Substitution wird gemäß der Anwenderwahl
eine neue Teilzeichenkette transplantiert. Bei dieser handelt es sich im
Fall des Typs zum Beispiel um [[helvetica]], im anderen um [[24-240]].
<<definiere Kopf-Zeilen-Funktionen>>=
SetFontType<-function(){
  melde("SetFontType",1)
  choices<-c("helvetica","courier","new century schoolbook","times")
  activate<-which(strsplit(tfont.sys,"-")[[1]][3]==choices)
  <<zeige Menü von [[choices]], Vorschlag:[[activate]], liefere [[choice]] ab>>
  if(choice!=0){
    font<-choices[choice]
    tfont.sys<-sub("be-.+-Me",paste("be-",font,"-Me",sep=""),tfont.sys)
    tkconfigure(tworkwin,font=tfont.sys)
    assign("tfont.sys",tfont.sys,env=revive.sys)
    if(exists("trevwin")) tkconfigure(trevwin, font=tfont.sys)
  }
  melde(paste("> font type changed"))
  melde("SetFontType",2)
}
@
Das Anzeigen der Wahlmöglichkeiten soll über einen eigenen Chunk erfolgen,
da es an anderer Stelle noch gebraucht wird.
<<zeige Menü von [[choices]], Vorschlag:[[activate]], liefere [[choice]] ab>>=
menuwidget <- tkmenu(TopW); set.tclvalue("tvchoice","0")
for(i in choices) tkadd(menuwidget,"radiobutton",label=i,variable="tvchoice")
tkpost(menuwidget,"0","0"); tkactivate(menuwidget,activate)
tkbind(menuwidget,"<Escape>",function(){
       tkdestroy(menuwidget);set.tclvalue("tvchoice","0")})
<<warte, falls das OS NICHT Windows ist>>
choice <- tclvalue("tvchoice")
choice <- if(choice!="0") choice<-which(choice==choices) else 0

@
Die Festlegung der Größe der Zeichen verläuft entsprechend.
<<definiere Kopf-Zeilen-Funktionen>>=
SetFontSize<-function(){
  melde("SetFontSize",1)
  sizes<-c("8-80","10-100","12-120","14-140","18-180","24-240","*-2000")
  choices<-c("1 tiny","2 very small","3 small","4 normal","5 large",
             "6 very large","7 huge")
  activate<-which(substring(sub("(.*)Normal..","",tfont.sys),1,3)==substring(sizes,1,3))
  <<zeige Menü von [[choices]], Vorschlag:[[activate]], liefere [[choice]] ab>>
  if(choice!=0){
    size<-sizes[choice]
    tfont.sys<-sub("al--.+-.+-\*",paste("al--",size,"-*",sep=""),tfont.sys)
    tkconfigure(tworkwin,font=tfont.sys)
    assign("tfont.sys",tfont.sys,env=revive.sys)
    outfont.sys<-sub("al--.+-.+-\*",paste("al--",size,"-*",sep=""),outfont.sys)
    assign("outfont.sys",outfont.sys,env=revive.sys)
    <<aktualisiere Texthervorhebungen>>
    tkconfigure(toutwin,font=outfont.sys)
    melde(paste("> font size changed"))
  }
  melde("SetFontSize",2)
}

@
\subsubsection{Kopfzeile: [[Optionen]] --- [[SetOutputLength]]}
\paragraph{[[SetOutputLength]] zur Festsetzung der maximalen Outputlänge.}
Die Festlegung der
maximalen Output-Länge wird wie die der PS-Größen abgehandelt.
Wieder dient [[tvinfo]] als Kanal.
<<definiere Kopf-Zeilen-Funktionen>>=
SetOutputLength<-function(){
  melde("SetOutputLength",1)
  frage<-"maximum number of output character?"; set.tclvalue("tvinfo",maxol.sys)
  <<frage [[frage]], biete [[tvinfo]] als Antwort an>>
  tkbind(TopW,"<Return>",
    function(){
      <<setze Manager nach {\sc Return} in Normalzustand>>
      h<-as.numeric(tclvalue("tvinfo"))
      if(!is.na(h)) assign("maxol.sys",h,env=revive.sys)
      melde(paste("> maxol.sys <-",maxol.sys),"cmd.msg")
    }
  )
  melde("SetOutputLength",2)
}

@
\subsubsection{Kopfzeile: [[Optionen]] --- [[ConfigRelax]]}
\paragraph{[[ConfigRelax]] zur Setzung von Configurationsparametern.}
<<definiere Kopf-Zeilen-Funktionen>>=
ConfigRelax<-function(){
  melde("ConfigRelax",1)
      .newl<-tktoplevel();tkwm.geometry(.newl,"+0+0");tkpack(tt<-tktext(.newl))
      tkpack(fcmd<-tkframe(.newl))
      Save<-tkbutton(fcmd,width=15,text="save settings",command=function(){
		 newsettings<-paste(tclvalue(tkget(tt,"0.0","end")),"\n")
		 filename<-file.path(.path.package("relax"),"config/settings.relax")
		 try(cat(file=filename,newsettings))
		 tkmessageBox(title="", icon="warning",
                          message="to get new settings work, relax has to be restarted")
		 print("new settings saved")
      })
      Exit<-tkbutton(fcmd,width=15,text="Exit",command=function(){
		 tkdestroy(.newl); set.tclvalue("tvscandone",2)
      })
      ReloadOld<-tkbutton(fcmd,width=15,text="reload old",command=function(){
		 settings<-get("settings",env=revive.sys)
		 tkdelete(tt,"0.0","end")
                 try(tkinsert(tt,"0.0",paste(settings,collapse="\n")))
      })
      LoadOrig<-tkbutton(fcmd,width=15,text="load original",command=function(){
	filename<-file.path(.path.package("relax"),"config/settings.init")
        settings<-scan(file=filename,what="",sep="\n")
        try(tkinsert(tt,"0.0",paste(settings,collapse="\n")))
      })
      tkpack(Save,ReloadOld,LoadOrig,Exit,side="left")
      tkwm.title(.newl,"view and change settings of relax: config/settings.relax")
      filename<-file.path(.path.package("relax"),"config/settings.relax")
      settings<-scan(file=filename,what="",sep="\n")
      assign("settings",settings,env=revive.sys)
      try(tkinsert(tt,"0.0",paste(settings,collapse="\n")))
      tkbind(.newl,"<Escape>", function(){
		 tkdestroy(.newl); set.tclvalue("tvscandone",2)
	       })
      tkfocus(.newl)
      set.tclvalue("tvmess","relax")
  melde("ConfigRelax",2)
}
@
\subsubsection{Kopfzeile: [[Edit]]}
Bislang gibt es drei Einträge für Recherchen. Für diese sind
[[FindReportText]],
[[FindReportChunk]] und
[[FindRFns]]
zu definieren.

@
\subsubsection{Kopfzeile: [[Edit]] --- [[FindReportText]]}
\paragraph{[[FindReportText]] zur Erleichterung der Navigation im
Arbeitsfenster.}
Zunächst wird von der aktuellen Zeile nach unten gesucht.
Wird dort nichts gefunden, beginnt die Suche am Anfang des Dokumentes.
Wird der eingegebene Suchstring gefunden, wird die Schreibmarke am Fundort
plaziert.
<<definiere Kopf-Zeilen-Funktionen>>=
FindReportText<-function(){
  melde("FindReportText",1)
  frage<-"text string to be searched?"; set.tclvalue("tvinfo",string.sys)
  <<frage [[frage]], biete [[tvinfo]] als Antwort an>>
  tkbind(TopW,"<Return>", function(){
      <<setze Manager nach {\sc Return} in Normalzustand>>
      set.tclvalue("tvmess","relax")
      such<-string.sys<-tclvalue("tvinfo")
      assign("string.sys",string.sys,env=revive.sys)
      <<lese Arbeitsfenster auf [[worktext]] ein>>
      if(length(found<-grep(such,worktext))>0){
        line <- floor(as.numeric(tkindex(tworkwin,"insert")))
        line <- if(any(found>line)) found[found>line][1] else found[1]
        tksee(tworkwin,paste(line,".1",sep=""))
        h<-worktext[line]
        h<--1+charmatch(such,substring(h,1:nchar(h))); if(is.na(h)) h<-0 # 060605
        h<-paste(line,".",h,sep="")
        tkmark.set(tworkwin, "insert", h); tkfocus(tworkwin)
      } else set.tclvalue("tvmess",paste("Warning: search string >",tclvalue("tvinfo"),"< not found!!!"))
    } # end of function
  )
  melde("FindReportText",2)
}

@
<<implementiere Eigenschaften der allgemeinen Knöpfe>>=
tkbind(TopW, "@<<FindReportText>>", FindReportText)

@
<<definiere Kopf-Zeilen-Funktionen>>=
GoToLine<-function(){
  melde("GoToLine",1)
  if(!exists("revive.sys")) revive.sys<-get("revive.sys",envir=revive.env)
  tworkwin<-get("tworkwin",envir=revive.sys)
  <<bestimme Cursorzeile [[line]] von [[tworkwin]]>>
  frage<-"GOTO line?"; set.tclvalue("tvinfo",line)
  <<frage [[frage]], biete [[tvinfo]] als Antwort an>>
  tkbind(TopW,"<Return>", function(){
      <<setze Manager nach {\sc Return} in Normalzustand>>
      line<-string.sys<-tclvalue("tvinfo")[1]
      assign("string.sys",string.sys,env=revive.sys)
      line<-as.numeric(line)
      if(!is.na(line)){
        tksee(tworkwin,h<-paste(line,".1",sep=""))
        tkmark.set(tworkwin, "insert", h); tkfocus(tworkwin)
      } else set.tclvalue("tvmess",paste("Warning: line",tclvalue("tvinfo"),"< not found!!!"))
    } # end of function
  )
  melde("GoToLine",2)
}

@
\subsubsection{Kopfzeile: [[Revweb]]: [[LaTeX.head, WebReport, LatexReport, ViewReport]]}
Für die Verarbeitung zum \LaTeX-Dokument werden verschiedene
Menüpunkte für Profis angeboten. Dazu muss [[latex]] und [[yap]] sowie
eine Spezialform des noweb-Systems unter Windows installiert sein.

\paragraph{Web-Funktionalitäten.}
<<definiere Kopf-Zeilen-Funktionen>>=
if(but.Wizardry){
 WebReport<-function(){
  melde("WebReport",1)
  if(!file.exists(workname.sys)){
    cat(paste("Error: File",workname.sys,"not found!!!"));return()
  }
  try(weaveR(workname.sys));try(tangleR(workname.sys))
  melde("WebReport",2)
 }
 LaTeX.head<-function(){
  melde("LaTeX.head",1)
  # news<-scan(file=paste(.path.package("relax"),"lib/LaTeX-head.tex",sep="/"),what="",sep="\n")
  news<-readLines(paste(.path.package("relax"),"lib/LaTeX-head.tex",sep="/")) # 2.1.0
  news<-sub("NOWEBSTYLEFILE",file.path(relax.path,"lib","noweb"),news)
  news<-sub("JOBPATH",getwd(),news); news<-c(news,"")
  <<lese Arbeitsfenster auf [[worktext]] ein>>
  line<-"2.0"
  <<schreibe [[news]] hinter [[line]]>>
  melde("LaTeX.head",2)
 }
 LatexReport<-function(){
  melde("LatexReport",1)
  n<-nchar(filename<-workname.sys)
  filename<-sub("rev$","tex",filename)
  if(is.null(n)||5>n||substring(filename,n-3,n)!=".tex"){
    cat("ERROR: file",filename,"not compatible!!!\n");return()
  }
  if(!file.exists(filename)){
    cat("ERROR: file",filename,"not found!!!\n");return()
  }
  melde("latex process starts, messages: see output window\n")
  if(<<das OS ist Windows>>){
      latex<-paste(latex.command.windows," ",filename,sep="")
      ok<-try(shell(latex,wait=T))
      if(ok!=0){ cat("!!!ERROR in LaTeX process !!!\n-- for details look at log file\n") }
  }else{
      latex<-paste(latex.command.linux," ",filename,sep="")
      ok<-try(system(latex))
      if(ok!=0){ cat("!!!ERROR in LaTeX process !!!\n-- for details look at log file\n") }
  }
  cat("latex process finished")
  melde("LatexReport",2)
 }
 ShowLogFile<-function(){
  melde("ShowLogFile",1)
  n<-nchar(filename<-workname.sys)
  filename<-sub("rev$","log",filename)
  if(is.null(n)||5>n||substring(filename,n-3,n)!=".log"){
    cat("ERROR: file",filename,"not compatible!!!\n");return()
  }
  if(!file.exists(filename)){ cat("ERROR: file",filename,"not found!!!\n");return() }
  cmd <-paste(editor.sys, filename)
  if(<<das OS ist Windows>>){
      try(shell(cmd,wait=FALSE))
  }else{
      try(system(paste(cmd," &")))
  }
  melde("ShowLogFile",2)
 }
 ViewReport<-function(){
  melde("ViewReport",1)
  n<-nchar(filename<-workname.sys)
  filename<-sub("rev$","dvi",filename)
  if(is.null(n)||5>n||substring(filename,n-3,n)!=".dvi"){
    cat("ERROR: file",filename,"not compatible!!!\n");return()
  }
  if(!file.exists(filename)){
    cat("ERROR: file",filename,"not found!!!\n");return()
  }
  if(<<das OS ist Windows>>){
      view<-paste(view.command.windows," ",filename,sep="")
      try(shell(view,wait=F))
  }else{
      view<-paste(view.command.linux,"  ",filename," &",sep="")
      try(system(view))
  }
  melde("ViewReport",2)
 }
 DvipdfReport<-function(){  #050607
  melde("DvipdfReport",1)
  n<-nchar(filename<-workname.sys)
  filename<-sub("rev$","dvi",filename)
  if(is.null(n)||5>n||substring(filename,n-3,n)!=".dvi"){
    cat("ERROR: file",filename,"not compatible!!!\n");return()
  }
  if(!file.exists(filename)){
    cat("ERROR: file",filename,"not found!!!\n");return()
  }
  if(<<das OS ist Windows>>){
      dvipdf<-paste(dvipdf.command.windows," ",filename,sep="")
      try(shell(dvipdf,wait=F))
  }else{
      dvipdf<-paste(dvipdf.command.linux,"  ",filename," &",sep="")
      try(system(dvipdf))
  }
  cat("\"",dvipdf,"\" has been started!\n")
  melde("DvipdfReport",2)
 }
 ProcessReport<-function(){
    if(file.exists(filename<-file.path(getwd(),workname.sys))){
       res<-tkmessageBox(message=
                 if(language=="german") paste("Datei",filename,"existiert. Soll sie ersetzt werden?")
	         else paste(filename,"exists. Do you want to replace it?"),
               title="Save File",icon="warning",type="yesnocancel",default="yes")
      if("externalptr"==mode(res))  res<-tclvalue(res)
      if(res=="cancel")return()
      if(res=="no"){msg<-SaveReport(); if(msg=="cancel") return()}  #050607
    }
    <<lese Arbeitsfenster auf [[worktext]] ein>>
    if(0==length(grep("documentclass", worktext)))
      cat("Warning: there is no \\documentclass-command in the file:",
           "LaTeX needs a preamble for processing tex-files!",sep="\n")
    <<speichere [[worktext]] als Rev-File ab, Indikator: [[ok]]>>
    if(ok){
      melde(paste("report file",filename,"saved\n"),0)
      melde(paste("w",workname.sys),"cmd.msg")
    } else {
      cat("ERROR: write operation failed!!!\n")
    }
    Sys.sleep(0.25)
    try(weaveR(workname.sys)); Sys.sleep(0.5)
    LatexReport()
 }
}

@
<<implementiere Eigenschaften der allgemeinen Knöpfe>>=
tkbind(TopW, "@<<ProcessReport>>", ProcessReport)

@
Hier ist ein Vorschlag für einen Kopf eines LaTeX-Dokumentes:
<<LaTeX-head>>=
\documentclass{article}
\usepackage{a4,graphicx,mathpazo,courier,alltt,amssymb}
% \usepackage{NOWEBSTYLEFILE}\noweboptions{webnumbering,smallcode}
\usepackage[scaled=.95]{helvet}
\usepackage[T1]{fontenc}
\title{Report: \rule{30mm}{.1mm}}
\author{File: \jobname.rev\\in: JOBPATH}
\begin{document}\maketitle

@
Früher wurde über die Variable [[rtrevweb.home]] festgelegt, in welchem Paket sich unter
Windows das Verzeichnis mit den noweb-Funktionen befindet.
Der Inhalt des Verzeichnisses ist an anderer Stelle beschrieben, siehe
zum Beispiel: rw.rev.

Die alte rtrevweb-Lösung mittels noweb:
<<old definition of [[rtrevweb]]>>=
 rtrevweb<-function(name,DIR=getwd(),binpath){
  # cat(paste("Aufruf: rtrevweb(name=\"",name,"\",DIR=\"",DIR,"\")\n",sep=""))
  scan<-get("scan",pos="package:base"); formals(scan)$comment.char<-""
  name<-sub(".rev$","",name)
  revname<-paste((name<-paste(DIR,name,sep="/")),"rev",sep=".")
  if(!file.exists(revname)){
    cat(paste("Error: File",revname,"not found!!!"));return()
  }
  if( <<das OS ist Windows>> ){
    if(missing(binpath)){
      binpath<-paste(.path.package(<<relax>>),"rtrevweb",sep=.Platform$file.sep)
      binpath<-gsub("/","\\\\",binpath)
    }
    vol<-strsplit(binpath,":")[[1]]
    vol<-if(1==length(vol)) "c:" else vol[1]

    tmpfile<-scan(revname,what="",sep="\n",blank.lines.skip=T)
    cat(tmpfile,file=paste(binpath,"work.rev",sep="/"),sep="\n")
    if(!file.exists(paste(binpath,"/rtrevweb.bat",sep=""))){
      cat("Error: rtrevweb.bat not found!!!"); return()
    }
    try(system(paste(binpath,"/rtrevweb ",binpath," ",vol,sep=""),T))
    tmpfile<-scan(paste(binpath,"work.sch",sep="/"),what="",sep="\n")
    cat(tmpfile,file=paste(name,"sch",sep="."),sep="\n")
    tmpfile<-scan(paste(binpath,"work.tex",sep="/"),
                  what="",sep="\n",blank.lines.skip=T)
    cat(tmpfile,file=paste(name,"tex",sep="."),sep="\n")
    tmpfile<-scan(paste(binpath,"work.htm",sep="/"),what="",sep="\n")
    cat(tmpfile,file=paste(name,"htm",sep="."),sep="\n")
    cat("fertig\n")
  }else { # LINUX:
    if(0==system(paste("which",path.revweb))&&!exists("weaveR.flag")){
     try(system(paste(path.revweb," ",name)))
    }else{
     try(weaveR(revname));try(tangleR(sub(".rev$","",revname)))
    }
  }
 } # end of old rtrevweb



@
Windows Only: Konfigurationen.
Für die Verarbeitung von Papieren müssen verschiedene Service-Programme
angestoßen werden. Deren Ort kann nicht allgemein festgelegt werden.
Deshalb wurde zuerst eine Konfigurationsfunktion ([[get.config()]]) entworfen, mit der
verschiedene spezielle Setzungen ermittelt werden können.
Inzwischen stehen spezielle Pfade usw.\ unter [[config/settings.relax]].

@
\subsubsection{Kopfzeile: [[Edit]] --- [[FindReportChunk]]}
\paragraph{[[FindReportChunk]] zur Erleichterung der Navigation im
Arbeitsfenster.}
Zum Auf\-finden eines Code-Namen müssen zunächst die verwendeten Namen
festgestellt werden. Dann werden sie in einem vom Top-Level abhängigen
Menü mit [[Radiobuttons]] aufgelistet. Der Anwender kann dann durch
Anklicken seinen gesuchten Chunk-Namen erreichen.
Neue Version mit [[listbox]].
<<definiere Kopf-Zeilen-Funktionen>>=
FindReportChunk<-function(){
  melde("FindReportChunk",1)
  <<lese Arbeitsfenster auf [[worktext]] ein>>
  no <- grep("^@<<(.*)>>=",worktext); if(0==length(no)) return()

  choices<-paste(worktext[no],worktext[no+1],sep=": ")
  choices<-substring(choices,1,pmin(nchar(choices),60))
  <<bestimme Cursorzeile [[line]] von [[tworkwin]]>>
  actual.chunk<-min(max(1,c(which(line<no),length(no)+1)[1]-1),length(no))

  newtop<-tktoplevel();tkwm.title(newtop,"code chunk? -- Esc=Exit, Return=Selection")
  scr <- tkscrollbar(newtop, command=function(...)tkyview(tl,...))
  tl<-tklistbox(newtop,height=min(20,length(no)),width=60,selectmode="single",
              yscrollcommand=function(...)tkset(scr,...),background="white")
  for(ch in choices) tkinsert(tl,"end",ch)
  tkselection.set(tl,actual.chunk-1)  # Default
  tksee(tl,max(actual.chunk-10,0))
  tkpack(tl,side="left",expand="yes",fill="y"); tkpack(scr,side="left",expand="yes",fill="y")
  tkbind(newtop,"<Escape>",function()tkdestroy(newtop))
  tkbind(newtop,"<Return>",function(){
     line<-no[as.numeric(tkcurselection(tl))+1]; tkdestroy(newtop)
     if(!is.na(line)){
       tksee(tworkwin,paste(line,".1",sep=""))
       tkmark.set(tworkwin, "insert", paste(line,".1",sep=""))
       tkfocus(tworkwin)
     }
  })
  melde("FindReportChunk",2)
}

@
<<definiere Kopf-Zeilen-Funktionen>>=
InsertLaTeXEnv<-function(){
  melde("InsertLaTeXEnv",1)
  newtop<-tktoplevel();tkwm.title(newtop,"LaTeX-environment? -- Esc=Exit, Return=Selection")
  tkwm.geometry(newtop,"+0+0")
  scr <- tkscrollbar(newtop, command=function(...)tkyview(tl,...))
  tl<-tklistbox(newtop,height=7,width=70,selectmode="single",
              yscrollcommand=function(...)tkset(scr,...),background="white")
  choices<-c("center","quote","itemize","enumerate","eqnarray","verbatim")
  for(ch in choices) tkinsert(tl,"end",ch)
  tkpack(tl,side="left",expand="yes",fill="y"); tkpack(scr,side="left",expand="yes",fill="y")
  tkbind(newtop,"<Escape>",function()tkdestroy(newtop))
  tkbind(newtop,"<Return>",function(){
     choice<-as.numeric(tkcurselection(tl))+1; tkdestroy(newtop)
     if(!is.na(choice) && any(choice==1:6)){
       news<-c("\\begin{center}\n\n\\end{center}\n",
                      "\\begin{quote}\n\n\\end{quote}\n",
		      "\\begin{itemize}\n\\item\n\\item\n\n\\end{itemize}\n",
		      "\\begin{enumerate}\n\\item\n\\item\n\n\\end{enumerate}\n",
		      "\\begin{eqnarray*}\n\n\\end{eqnarray*}\n",
		      "\\begin{verbatim}\n\n\\end{verbatim}\n")[choice]
       <<bestimme Cursorzeile [[line]] von [[tworkwin]]>>
       line <- paste(line+1,"0",sep=".")
       <<schreibe [[news]] hinter [[line]]>>
     }
     if(!is.na(line)){
       tksee(tworkwin,line)
       tkmark.set(tworkwin, "insert", line)
       tkfocus(tworkwin)
     }
  })
  melde("InsertLaTeXEnv",2)
}
@
\subsubsection{Kopfzeile: [[Edit]] --- [[FindLaTeXSection]]}
\paragraph{[[FindLaTeXSection]] zur Suche nach einer LaTeX-Section.}
<<definiere Kopf-Zeilen-Funktionen>>=
FindLaTeXSection<-function(){
  melde("FindLaTeXSection",1)
  <<lese Arbeitsfenster auf [[worktext]] ein>>
  no <- grep("\\\\s(.*)ection",worktext); if(0==length(no)) return()

  choices<-paste(worktext[no],worktext[no+1],sep=": ")
  choices<-substring(choices,1,pmin(nchar(choices),60))
  <<bestimme Cursorzeile [[line]] von [[tworkwin]]>>
  actual.chunk<-min(max(1,c(which(line<no),length(no)+1)[1]-1),length(no))

  newtop<-tktoplevel();tkwm.title(newtop,"code chunk? -- Esc=Exit, Return=Selection")
  scr <- tkscrollbar(newtop, command=function(...)tkyview(tl,...))
  tl<-tklistbox(newtop,height=min(20,length(no)),width=60,selectmode="single",
              yscrollcommand=function(...)tkset(scr,...),background="white")
  for(ch in choices) tkinsert(tl,"end",ch)
  tkselection.set(tl,actual.chunk-1)  # Default
  tksee(tl,max(actual.chunk-10,0))
  tkpack(tl,side="left",expand="yes",fill="y"); tkpack(scr,side="left",expand="yes",fill="y")
  tkbind(newtop,"<Escape>",function()tkdestroy(newtop))
  tkbind(newtop,"<Return>",function(){
     line<-no[as.numeric(tkcurselection(tl))+1]; tkdestroy(newtop)
     if(!is.na(line)){
       tksee(tworkwin,paste(line,".1",sep=""))
       tkmark.set(tworkwin, "insert", paste(line,".1",sep=""))
       tkfocus(tworkwin)
     }
  })
  melde("FindLaTeXSection",2)
}

@
\subsubsection{Kopfzeile: [[Edit]] --- [[ShowShortCuts]]}
\paragraph{[[ShowShortCuts]] Anzeige von speziellen Short-Cuts.}
<<definiere Kopf-Zeilen-Funktionen>>=
ShowAboutRwined<-function(){
  melde("ShowShortCuts",1)
  doc<-c("relax() is designed to support the process of data analysis, report writing,",
               "presentation, and programming. On start it creates a new window for writing",
	       "code and text at the same time. You are allowed to evaluate R code chunks",
	       "as well as to write down interpretations of the results.",
	       "This style of working will result in correct reports.",
	       "The reports can be reloaded again in cause of presentation, modification",
	       "and checking of the results. Have a look at the help page of relax and",
	       "http://www.wiwi.uni-bielefeld.de/~wolf/software/relax/relax.html","",
	       "Copyright (C) 2005 Hans Peter Wolf.","",
	       "This software is licensed under the GPL (version 2 or newer) terms.",
               "It is free software and comes with ABSOLUTELY NO WARRANTY.","",
               "The windows version uses some ingredients",
	      # "of the noweb system",
	      # " (Norman Ramsey -- http://www.eecs.harvard.edu/~nr/noweb/intro.html),",
	       "of the Img package of Jan Nijtmans (http://www.xs4all.nl/~nijtmans/img.html)",
	      # "and gawk (http://www.gnu.org/software/gawk/gawk.html)",
	       "-- notice the copyright declarations of this software.","","",
	       "---------------------------------------------------------","",""
               )
  try(doc<-c(doc,scan(file=paste(.path.package("relax"),"lib/gpl.txt",sep="/"),what="",sep="\n")))
  .newl<-tktoplevel();tkwm.geometry(.newl,"+0+0")
  tkpack(tt<-tktext(.newl,height=length(doc)))
  tkwm.title(.newl,paste("What's relax? ","Exit by Return or Escape!"))
  try(tkinsert(tt,"0.0",paste(doc,collapse="\n")))
  abbruch<-function(){tkdestroy(.newl); set.tclvalue("tvscandone",2)}
  tkbind(.newl,"<Escape>", function(){
               tkdestroy(.newl)
  })
  tkbind(.newl,"<Return>", function(){
               tkdestroy(.newl)
  })
  tkfocus(.newl)
  melde("ShowAboutRwined",2)
}

ShowShortCuts<-function(){
  melde("ShowShortCuts",1)
  keys<-c("Shortcuts of relax:","",
                "Alt-D:  move cursor one code chunk DOWN",
                "Alt-U:  move cursor one code chunk UP",
                "Alt-P:  plan new code chunk",
                "Alt-E:  eval code chunk",
                "Alt-T:  delete output of text field",
                "Alt-S:  copy plot and generate postscript / JPEG file",
                "Alt-R:  clear output field",
                "Alt-H:  R help",
		"Crtl-F:  Find text in report field",
		"Crtl-S:  Save Report",
		"Crtl-P:  Process Report: save, weave, and latex Report",
		"Crtl-Page-down:  copy code chunk to end",
		"","Shortcuts of tcltk, may depend on tcl/tk version:","",
                "Crtl-Z:  UNDO",
                "Crtl-C:  copy marked text",
                "Crtl-V:  paste marked text",
                "Crtl-Y:  paste marked text (=Crtl-V)",
		"Crtl-X:  delete marked text",
                "Crtl-W:  copy and delete marked text",
                "Crtl-Shift-7:  mark all",
               # "Crtl-F:  unmark text",
               # "Crtl-A:  unmark text",
               # "Crtl-P:  unmark text",
                "Crtl-O:  break line",
                "Crtl-E:  move cursor to the end of line",
                "Crtl-A:  move cursor to the beginning of line",
                "Crtl-B:  move cursor one character to the left",
                "Crtl-F:  move cursor one character to the right",
                "Crtl-N:  move cursor to the next line",
                "Crtl-Pos1:  move cursor to the beginning of text",
                "Crtl-End:  move cursor to the end of text",
                "Crtl-P:  move cursor one line back",
		"Crtl-I:  insert tab",
		"Crtl-T:  exchange characters",
                "Crtl-D:  delete character right of cursor",
                "Crtl-H:  delete character left of cursor",
                "Crtl-K:  delete characters from cursor to end of line"     )
  .newl<-tktoplevel();tkwm.geometry(.newl,"+0+0")
  tkpack(tt<-tktext(.newl,height=length(keys)))
  tkwm.title(.newl,paste("shortcuts of relax and text field,","Exit by Return or Escape!"))
  try(tkinsert(tt,"0.0",paste(keys,collapse="\n")))
  abbruch<-function(){tkdestroy(.newl); set.tclvalue("tvscandone",2)}
  tkbind(.newl,"<Escape>", function(){
               tkdestroy(.newl)
  })
  tkbind(.newl,"<Return>", function(){
               tkdestroy(.newl)
  })
  tkfocus(.newl)
  melde("ShowShortCuts",2)
}



@
\subsubsection{Kopfzeile: [[Edit]] --- [[FindRFns]]}
\paragraph{[[FindRFns]] zum Auf\-finden einer R-Funktion.}
Zum Auf\-finden einer R-Funktion aufgrund eines Suchbegriffs wird die
R-Funktion [[help.search]] mißbraucht. Dazu wird sie als lokale Funktion
vereinbart und so verändert, daß der Output zugreifbar wird.
Der Output wird in einem temporären neuen Widget angezeigt,
das nach getaner Arbeit wieder entfernt wird. Bei
einer Änderung von [[help.search]] muß natürlich [[FindRFns]]
auch verändert werden!
<<definiere Kopf-Zeilen-Funktionen>>=
FindRFns<-function(){
  melde("FindRFns",1)
  frage<-"keyword for function search?"; set.tclvalue("tvinfo",string.sys)
  <<frage [[frage]], biete [[tvinfo]] als Antwort an>>
  tkbind(TopW,"<Return>", function(){
      such<-tclvalue("tvinfo")
      <<setze Manager nach {\sc Return} in Normalzustand>>
      set.tclvalue("tvmess",paste(tclvalue("tvinfo"),": bitte etwas Geduld!"))
      found<-help.search(such)[[4]][,1:2]
      found<-paste(paste(found[,1],
                         substring("         ",1,pmax(1,10-nchar(found[,1]))),
                         found[,2]),collapse="\n")
      .newl<-tktoplevel();tkwm.geometry(.newl,"+0+0");tkpack(tt<-tktext(.newl))
      tkwm.title(.newl,paste("zu >",such,"< gefundene Funktionen, ",
                             "Beendigung durch Escape oder Return!"))
      try(tkinsert(tt,"0.0",paste(found,collapse="\n")))
      abbruch<-function(){tkdestroy(.newl);set.tclvalue("tvndone",2)}
      tkbind(.newl,"<Return>",abbruch);tkbind(.newl,"<Escape>",abbruch)
      tkfocus(.newl);tkwait.variable("tvndone")
      set.tclvalue("tvmess","relax")
    } # end of function
  )
  melde("FindRFns",2)
}

@
\subsubsection{Kopfzeile: [[Edit]] --- [[SavePlot]]}
\paragraph{[[SavePlot]] zur Speicherung von Graphiken als PS-Datei
und als [[Jpeg]]-Datei.}
Im Moment wird die Speicherung mittels [[dev.copy]] realisiert.
Falls der eingegebene Name die Endung [[.ps]] trägt, wird diese abgespalten.
Dann werden für die Formate die entsprechenden Endungen ergänzt.
In den Report wird ein für \LaTeX\ verständlicher Link eingetragen,
so daß später das Bild automatisch in das Dokument integriert wird.
Für die Ergänzung des Reports wird ein Chunk verwendet,
der den Inhalt von [[news]] in den Arbeitstext nahe des Cursor schreibt.

Zunächst die bekannte Struktur:
<<definiere Funktion für Knopf: [[SavePlot]]>>=
fSavePlot<-function(){
  melde("fSavePlot",1)
  h<-strsplit(gsub(":","",date())," ")[[1]]
  bildname<-paste("p",h[5],"-",h[2],h[3],"-",h[4],".ps",sep="")
  <<lege Bild unter [[bildname]] ab>>
  <<zeige Bilder im Textfenster an>>
  melde("fSavePlot",2)
}

@
Die einzelnen Schritte: Namen überarbeiten, Vermerk im Report einfügen,
[[dev.copy]] einsetzen, ggf.\ Fehlerbehandlung --- sowohl für die PS-
als auch für die Jpeg-Schiene.
Für die Einfügung im Report wird wegen wiederholter Verwendbarkeit ein
eigener Chunk konzipiert.
[[bw]], [[bh]] am 05.07.01 um Faktor 2 vergrößert.
[[ppmraw]] erzeugt ein [[ppm]]-Format, das von {\sc Tcl/Tk} auch ohne
Erweiterung integriert werden kann.
Auf [[bildname]] darf ein Name mit oder ohne Endung [[.ps]] angegeben werden.
<<lege Bild unter [[bildname]] ab>>=
if(!is.null(bildname)&&nchar(bildname)>0){
  n<-nchar(bildname<-gsub(" ","",bildname))
  bildname<-sub(".ps$","",bildname)
# Postscript:
  psname <-paste(bildname,".ps", sep="")
  news<-paste("@\n \\begin{center}","\\includegraphics[",
                        "height=",psheight.sys,"]{",psname,"}\\end{center}\n",sep="")
  <<lese Arbeitsfenster auf [[worktext]] ein>>
  <<schreibe [[news]] hinter aktuellen Chunk>>
  try.res<-try({dev.copy(postscript,psname,horizontal=F,
                      width=psdesignwidth.sys,height=psdesignheight.sys);dev.off()})
  <<lege auf [[ok]] ab, ob [[try.res]] Fehler zeigt>>
  if(!ok) cat("Error: *ps file not generated by dev.copy!!!\n")
# jpeg:
  jpgname<-paste(bildname,".jpg",sep="")
  news<-paste('\n% <p><img src="',jpgname,'">\n@\n', sep="" )
  <<schreibe [[news]] hinter aktuellen Chunk>>
  if(<<das OS ist Windows>>){
    try.res<-try({dev.copy(jpeg,jpgname);dev.off()})
  }else{
    try.res<-try({dev.copy(bitmap,type="jpeg",jpgname);dev.off()})
  }
  <<lege auf [[ok]] ab, ob [[try.res]] Fehler zeigt>>
  if(!ok) cat("Error: *jpg file not generated by dev.copy!!!\n")
  melde(paste("p", psname), "cmd.msg")
}

@
Für die Anzeige der Bilder in einem Fenster wurde
die Funktionen [[show.plots]] entworfen.
Diese sucht im Text nach [[includegraphics]], extrahiert die Namen der Bilder
und intergriert sie mit Hilfe der {\sc Tcl/Tk}-Prozedur [[showimage]].
Diese Prozedur wird vorher definiert.
Dieser Prozedur ist der Name des Text-Widget, der Name des Image (Bildes)
und die Stelle mitzugeben.
Die Funktion [[exclude.plots]] entfernt die Graphiken aus dem Reportfenster.
Falls verbesserte
Graphiken generiert worden sind, müssen die alten zunächst entfernt werden.
Falls durch die Aufrufoption [[no.plots=T]] gewünscht wurde,
werden keine Bilder im Manager angezeigt. Das kann für
Speicherprobleme hilfreich sein.
<<zeige Bilder im Textfenster an>>=
<<lese Arbeitsfenster auf [[worktext]] ein>>
if(!no.plots && length(grep("<img src=",worktext))>0)
    { exclude.plots(tworkwin); show.plots(tworkwin) }

@
Falls [[jpg]]-Dateien nicht vorhanden sind können sie aus den
[[ps]]-Dateien mittels [[ghostscript]] generiert werden. Hier zunächst die Erzeugung
von [[ppm]]-Dateien.
\begin{verbatim}
  gs -dBATCH -sDEVICE=ppmraw -sOutputFile=tmp1.ppm -quit -dNOPAUSE tmp1.ps
\end{verbatim}
Für das Laden von [[relax]] vor dem Laden von [[Tcl/Tk]] muß der
Aufruf von [[.Tcl]] innerhalb einer Funktion stehen. Darum wird
die Prozedur [[.Tcl]] innerhalb [[show.plots]] aufgerufen.
<<definiere Funktion für Knopf: [[SavePlot]]>>=
show.plots<-function(textwidget,is.reportwin=T,path.of.plots){
 try(.Tcl( paste(
  "proc showimage {w im place} {",
   "$w image create $place -image [image create photo -format jpeg -file $im]",
  "}", sep="\n") ) )
  if(is.reportwin){
    tworkwin <- textwidget
    <<lese Arbeitsfenster auf [[worktext]] ein>>
    rows   <-grep("<img src=",worktext)
    if(0==length(rows))return()
    jpgnames  <-unlist(lapply(strsplit(worktext[rows],"<img src=\""), ## vorher "figure="
                    function(x){ x<-x[2]; strsplit(x,"\"")[[1]][1] }))
  }
#  print(jpgnames)
  for(i in seq(along=rows)){
    if(file.exists(sub(".jpg$",".ps",jpgnames)[i])&(!file.exists(jpgnames[i]))){
      pstojpg(sub(".jpg$",".ps",jpgnames)[i],jpgnames[i])
    }
    if(file.exists(jpgnames[i]))
      try(tkcmd("showimage",textwidget,jpgnames[i],paste(rows[i]-1,".0",sep="")))
  }
}
exclude.plots<-function(tworkwin){
  <<lese Arbeitsfenster auf [[worktext]] ein>>
  rows   <-grep("<img src=",worktext)
    if(0==length(rows))return()
  names  <-unlist(lapply(strsplit(worktext[rows],"<img src=\""), ## vorher "figure="
                  function(x){ x<-x[2]; strsplit(x,"\"")[[1]][1] }))
  rows <- rows - 1   # + 1
  for(i in seq(along=rows)){
    anf<-paste(rows[i],".0",sep=""); end<-paste(rows[i],".end",sep="")
    a<-tclvalue(tkget(tworkwin,anf,end))
    tkdelete(tworkwin,anf,end)
    tkinsert(tworkwin,anf,paste(a,collapse="\n")) # 040922
#    tkdelete(tworkwin,paste(rows[i],".0",sep=""),paste(rows[i],".1",sep=""))
  }
}

@
Falls Bilder nur im ps-Format vorhanden sind, müssen Repräsentationen
im [[jpg]]-Format nachgebaut werden.
\begin{verbatim}
  gs -dBATCH -sDEVICE=jpeg -sOutputFile=tmp1.jpg -quit -dNOPAUSE tmp1.ps
\end{verbatim}
<<definiere Funktion für Knopf: [[SavePlot]]>>=
pstojpg<-function(psname,jpgname){
  return() # im Moment nicht im Dienst
  if(<<das OS ist Linux>>){
    gsexe <- Sys.getenv("R_GSCMD")
    if(is.null(gsexe) || nchar(gsexe) == 0) {
      gsexe <- "gs"; rc <- system(paste(gsexe, "-help > /dev/null"))
      if (rc != 0) return()
    }
  }
  if(<<das OS ist Windows>>){
    if(exists("ghostscript")) gsexe<-ghostscript else return()
  }
  type<-"jpeg"; width<-height<-13; res<-30
  cmd <- paste(gsexe, " -dNOPAUSE -dBATCH -q -sDEVICE=", type,
                      " -r", res,
                      " -g",ceiling(res*width),"x",ceiling(res*height),
                      " -sOutputFile=", jpgname, "  ",psname, sep = "")
  try(system(cmd)); invisible()
}

@
Für Windows mußten einige Handstände mehr als für Linux absolviert werden.
Ziel ist es, einen Text-Chunk auf Knopfdruck zu formatieren und eine entsprechende
Graphik im jpeg-Format zu erstellen. Die einzelnen Schritte lauten:
\begin{enumerate}
\item ermittle Code-Chunk
\item formatiere Zeilen: erstelle dvi-Datei, erstelle PS-Datei, erstelle jpeg-Datei
\item erstelle jpg-Bild
\item integriere Bild
\end{enumerate}

Unter Windows ist die Erstellung der jpeg-Datei etwas aufwendiger,
da die PS-Datei von ihrem weißen Rahmen befreit werden muss.
Dazu wird zunächst eine riesige ppm-Datei mit [[ghostscript]] erstellt,
dann mit [[ppmcrop]] der Rahmen entfernt, um zum Schluss mittels [[ppmtojpeg]]
die ersehnte jpeg-Datei zu erhalten. Dazu sind folgende Hilfsprogramme
die im Verzeichnis [[../relax/lib]] abgelegt sind, erforderlich:
%[[libjpeg.dll]], [[ppmtojpeg]] in [[netPBM_v10.6_win32.zip]]
%über [[http://prdownloads.sourceforge.net/exoops/netPBM_v10.6_win32.zip?download]]

Erforderlich sind:
[[pnmcrop.exe]], [[netpbm.dll]], [[ppmtojpeg.exe]], [[libjpeg.dll]].
Diese müssen in [[library/relax/lib]] liegen.

Diese Programme scheinen miteinander verträglich zu sein.
Die Programme wurden gefunden über:\\
\verb+http://www.e-xoops.com/public/modules/mydownloads/singlefile.php?lid=27+\\
\verb+http://prdownloads.sourceforge.net/exoops.com/netPBM_v10.6_win32.zip?downloads+\\
\verb+http://prdownloads.sourceforge.net/exoops.com/netPBM_v10.6_win32.zip?use_mirror=heanet+\\
-- mit der neuesten netpbm-Version gelang kein Erfolg.

@
weitere Links zu dem Thema:\\
\verb+http://prdownloads.sourceforge.net/gallery/+\\
\verb+netpbm1.1-gallery1.0-win32.tgz?use_mirror=cesnet+\\
\verb+http://web.mit.edu/windows-graphics/bin/+
<<definiere Kopf-Zeilen-Funktionen>>=
FormatTeXLines<-function(){
  melde("FormatTeXLines",1)
  # ermittle neue Zeilen:
  <<lese Arbeitsfenster auf [[worktext]] ein>>
  <<bestimme Cursorzeile [[line]] von [[tworkwin]]>>
  text.start<-h<-grep("^@",c(worktext,"@"))
  texbegin<-rev(text.start[text.start<line])[1]; if(is.na(texbegin)) return()
  texend<-text.start[text.start>line][1]
  code.start<-grep("^@<<(.*)>>=",worktext)
  c.start<-rev(code.start[code.start<line])[1]
  if(!is.na(c.start) &&  c.start>texbegin ) return()
  c.end<-code.start[code.start>line][1];  if(!is.na(c.end))texend<-min(texend,c.end)
  ttext<-worktext[(texbegin+1):(texend-1)]
  # formatiere Zeilen
  ttext<-c("\\documentclass{article}\\pagestyle{empty}\\parindent0mm",
           "\\begin{document}\\LARGE",ttext,"\\end{document}")
  cat(ttext,file="tmptmp.tex",sep="\n")
  # erstelle jpg-bild
  h<-gsub(" ","",gsub(":","",date())); h<-substring(h,4:nchar(h),4:nchar(h))
  jpgname<-paste(c("t",h[6:11],h[4:5],h[1:2],h[14:15],".jpg"),collapse="")
  if(<<das OS ist Linux>>){
    system("echo q | latex tmptmp.tex; dvips -E tmptmp.dvi")
    system(paste("convert tmptmp.ps ",jpgname))
    system("rm tmptmp.tex tmptmp.aux tmptmp.log tmptmp.dvi tmptmp.ps")
  }
  if(<<das OS ist Windows>>){
       if(!exists("ghostscript")) return()
       if(!file.exists(paste(ghostscript,".exe",sep=""))){
          cat("ERROR: sorry, ghostscript not found!!!\n"); return()
       }
       ft.path<-file.path(relax.path,"lib")
       ft.path<-ft.path[file.exists(ft.path)][1]
       try(shell("echo q | latex tmptmp.tex"))
       try(shell("dvips -E tmptmp.dvi"))
       try(shell(paste(ghostscript,
  " -dBATCH -sDEVICE=ppm -quit -sOutputFile=tmptmp.ppm -dNOPAUSE tmptmp.ps", sep="")))
       try(shell(file.path(ft.path,"\\pnmcrop   tmptmp.ppm   > tmptmp.crp")))
       try(shell(paste(ft.path,"\\ppmtojpeg tmptmp.crp   > ",jpgname,  sep="")))
       try(shell("del tmptmp.tex tmptmp.aux tmptmp.log tmptmp.ppm tmptmp.crp tmptmp.dvi tmptmp.ps"))
  }
  # passe workttext an, integriere Bild
  news<-paste("\n%    end-latex-->\n\n% <p><img src=\"",jpgname,"\">\n",sep="")
  line<-paste(texend,".0",sep="")
  <<schreibe [[news]] hinter [[line]]>>
  line<-paste(texbegin+1,".0",sep=""); news<-"%<!--begin-latex\n"
  <<schreibe [[news]] hinter [[line]]>>
  <<zeige Bilder im Textfenster an>>
  melde("FormatTeXLines",2)
}

@
<<schreibe [[news]] hinter [[line]]>>=
<<hole ggf. [[tworkwin]]>>
<<lese Arbeitsfenster auf [[worktext]] ein>>
try(tkinsert(tworkwin,line,paste(news,collapse="\n")))
melde("inserted characters: \n",3,substring(news[1:min(7,length(news))],1,80))


@
\subsubsection{Kopfzeile: [[Edit]] --- [[InsertTeX]]}
\paragraph{[[InsertTeX]] zur Ersetzung von Abschnitten durch TeX-Formatierungsergebnis.
Speicherung des Ergebnisses als PS-Datei
und als [[Jpeg]]-Datei.}
<<definiere Funktion für Knopf: [[InsertTeX]]>>=
InsertTeX<-function(){
  melde("InsertTeX",1)
  h<-gsub(" ","",gsub(":","",date()))
  h<-substring(h,4:nchar(h),4:nchar(h))
  bildname<-paste(c("p",h[6:11],h[4:5],h[1:2],h[14:15]),collapse="")
  <<hole ggf. [[tworkwin]]>>
  <<bestimme Cursorzeile [[line]] von [[tworkwin]]>>
  <<lese Arbeitsfenster auf [[worktext]] ein>>
  start<-grep("begin-tex-code",worktext)
  start<-rev(start[start<line])[1]
  ende<-grep("end-tex-code",worktext)
  ende<-ende[ende>start][1]
  h<-worktext[start+1:ende-1]
  h<-c("\\documentclass{article}\\begin{document}",h,"\\end{document}")
  cat(h,file=tmptmp.tex,sep="\n")
  if(version$os=="linux-gnu") system("echo q|latex tmptmp.tex;dvips tmptmp.dvi")
  ##lege Bild unter [[bildname]] ab>>
  <<zeige Bilder im Textfenster an>>
  melde("InsertTeX",2)
}

@
\subsubsection{Kopfzeile: [[Help.R]]}
Als letzte Funktion muß [[Help.R]] für den Hilfeknopf definiert werden.

\paragraph{[[Help.R]] zum Start der Hilfe.}
Die Wirkungen der Knöpfe müssen natürlich auch noch festgelegt werden.
Als Vereinbarung soll gelten, daß die Anweisungen eines Knopfes
durch eine Funktion umgesetzt wird, deren Name sich
durch ein vor den Widget-Namen vorgestelltes [[f]] ergibt.

Der Druck von {\sc Alt-H} soll die gleiche Wirkung wie das Drücken des
Knopfes haben. Deshalb wird für das gesamte Top-Level-Fenster vereinbart,
bei dem Event [[<yen>]] (unter Unix) die Funktion [[fHelp.R]] auszuführen.
Inzwischen wurde das {\em physikalische} Ereignis [[<yen>]] gegen das
virtuelle [[@<<Help.R>>]] ausgetauscht. Dieses wird im Abschnitt über
plattformabhängige Dinge für {\sc unix} mit Hilfe von [[<yen>]] definiert.
Übrigens liefert der {\sc Tcl/Tk}-Interpreter die richtigen Tastatur-Codes
mit [[bind . <KeyPress> {puts  {%%K=%K}}]].
Wird ein Hilfetext gefunden, wird dieser jetzt nicht mehr in einem neuen Top-Level-Fenster
dargestellt, sondern mit Hilfe des Browsers. Die Verzögerung verhindert, dass
[[help.start()]] durch [[help(xyz)]] überholt wird.
<<definiere Funktion für Knopf: [[Help.R]]>>=
fHelp.R<-function(){
  melde("fHelp.R",1)
  frage<-"name of R function?"; set.tclvalue("tvinfo",string.sys)
  <<frage [[frage]], biete [[tvinfo]] als Antwort an>>
  tkbind(TopW,"<Return>", function(){
      <<setze Manager nach {\sc Return} in Normalzustand>>
      # help.start(browser=browser.sys); Sys.sleep(0.1);
      fns<-tclvalue("tvinfo")
      mess<-paste("documentation of",fns,"appears in the R window;",
			    "click \"ok\" and change to the R window")
      res<-tkmessageBox(message=mess,title="Help",icon="info",type="ok")
      try.res<-try(eval(parse(text=
        paste("get(\"print\",\"package:base\")(help(\"",fns,"\",htmlhelp=FALSE))",sep=""))))
      if(length(try.res)==0){
        mess<- paste("Warning: no documentation for",fns,"found!")
	res<-tkmessageBox(message=mess,title="Help",icon="info",type="ok")
      }
      mess<-paste("relax"); set.tclvalue("tvmess",mess)
    } # end of function
  )
  melde("fHelp.R",2)
}

@
<<unused>>=
fHelp.R<-function(){
  melde("fHelp.R",1)
  frage<-"name of R function?"; set.tclvalue("tvinfo",string.sys)
  <<frage [[frage]], biete [[tvinfo]] als Antwort an>>
  tkbind(TopW,"<Return>", function(){
      <<setze Manager nach {\sc Return} in Normalzustand>>
    #  help.start(browser=browser.sys); Sys.sleep(0.1);
      fns<-tclvalue("tvinfo")
      try.res<-try(helpcall<-eval(parse(text=(help.cmd<-paste("help(\"",fns,"\")",sep="")))))
      if(length(try.res)==0){
        mess<- paste("Warning: no documentation for",fns,"found!")
	set.tclvalue("tvmess",mess)
      }	else {
            #   if(##das OS ist Windows##){
       #    mess<-paste("view documentation of",fns,"appears in R window")
	# }
         #if(##das OS ist Linux##){
  	  mess<-paste("documentation of",fns,"appears in browser if it is running")
	  assign("cmds",paste(">",help.cmd,sep=""),env=revive.env)
	  out<-tclvalue(tkget(toutwin,"0.0","end"))
          <<lese Arbeitsfenster auf [[worktext]] ein>>
	  report<-worktext
	    <<generiere ein Ereignis zur Abarbeitung von [[cmds]]>>
	  Sys.sleep(0.1)
	  worktext<-report
	  <<schreibe [[worktext]] ins Arbeitsfenster>>
          <<aktualisiere Texthervorhebungen>>
	  worktext<-out
          <<schreibe [[worktext]] ins Outputfenster>>
	# }
      }
      set.tclvalue("tvmess",mess)
    } # end of function
  )
  melde("fHelp.R",2)
}

@
<<alter Code>>=
 such<-paste(R.home(),"library/base/help",tclvalue("tvinfo"),sep="/")
        if(!file.exists(such))return()
        sys.cmd<-if(<<das OS ist Windows>>) "type" else "cat"
        out<-try(system(paste(sys.cmd,such),T))
        out<-out[-grep("^_",out)]
        .newl  <- tktoplevel(); tkwm.geometry(.newl,"+0+0")
        tkwm.title(.newl,paste("help text found: >",such,"< -- ",
                              "quit by Escape or Return!"))
        tkpack(tt<-tktext(.newl))
        try(tkinsert(tt,"0.0",paste(out,collapse="\n")))
        tkbind(.newl,"<Return>",function(){
                                 tkdestroy(.newl);set.tclvalue("tvndone",2)})
        tkbind(.newl,"<Escape>",function(){
                                 tkdestroy(.newl);set.tclvalue("tvndone",2)})
        tkwait.variable("tvndone")


@
Nachdem die Funktion entworfen ist, muß sie noch als [[command]]-Eigenschaft
des Knopfes vereinbart werden. Außerdem wird in einem Rutsch der short cut
mit Hilfe des virtuellen Ereignisses [[@<<Help.R>>]] festgelegt.
<<implementiere Eigenschaften der allgemeinen Knöpfe>>=
tkconfigure(Help.R,command=fHelp.R)
tkbind(TopW, "@<<Help.R>>", fHelp.R)


@
\subsubsection{An- und Einfügungen an Felder und sonstige Kleinigkeiten}
Da Einfügeoperationen an verschiedenen Stellen notwendig sind,
wollen wir hier für Einfügezwecke einige Chunks anbieten.

Anfügungen mit [[output-start]]- und [[-end]]-Klammer.
<<schreibe [[news]] ans Ende des Arbeitstextes>>=
<<hole ggf. [[tworkwin]]>>
pos.to.insert<-"end"
if(0<length(grep("output-start",news))){
  tail<-rev(strsplit(tclvalue(tkget(tworkwin,"end - 3 lines","end")),"\n")[[1]])
  ltail<-length(tail)
  if( (0==length(grep("@<<[*]>>=",tail[1:ltail]))) &&
      any(h<-("output-end"==substring(tail[1:ltail],1,11)))){
     news<-sub(".*output-start\n","",news)
     news<-sub("output-end","",news)
     h<-seq(along=h)[h][1]
     pos.to.insert<-paste("end -",h,"lines")
  }
}
try(tkinsert(tworkwin,pos.to.insert,paste(news,collapse="\n")))
tksee(tworkwin,"end - 0 lines")
melde("appended characters: \n",3,substring(news[1:min(7,length(news))],1,80))

@
Einfache Anfügung an das Outputfeld:
<<schreibe [[news]] ans Ende des Outputfeldes>>=
if(!exists("toutwin"))
  toutwin<-get("toutwin",envir=get("revive.sys",envir=revive.env))
pos.to.insert<-"end"
news<-paste(gsub("\n+","\n",news),collapse="\n")
try(tkinsert(toutwin,pos.to.insert,news))
tksee(toutwin,"end - 0 lines")
melde("appended characters: \n",3,substring(news[1:min(7,length(news))],1,80))


@
Einfügung von [[news]] hinter den aktuellen Code-Chunk:
<<schreibe [[news]] hinter den aktuellen Code-Chunk>>=
<<hole ggf. [[tworkwin]]>>
<<bestimme Cursorzeile [[line]] von [[tworkwin]]>>
<<lese Arbeitsfenster auf [[worktext]] ein>>
if(0==length(insertline<-grep("^@",worktext))||
   0==length(insertline<-insertline[insertline>line])){
    try(tkinsert(tworkwin,"end","\n"))
    insertline<-"end"
  }else{
    insertline<-paste(insertline[1],"0",sep=".")
  }
try(tkinsert(tworkwin,insertline,paste(news,collapse="\n")))
tksee(tworkwin,insertline)
melde("inserted characters: \n",3,substring(news[1:min(7,length(news))],1,80))

@
<<bestimme Cursorzeile [[line]] von [[tworkwin]]>>=
line <-floor(as.numeric(tkindex(tworkwin,"insert")))

@
Für [[PlanRCode]] wurde dieser Chunk entworfen, mit dem [[news]]
hinter den aktuellen Chunk, also Code- oder Text-Chunk geschrieben wird.
<<schreibe [[news]] hinter aktuellen Chunk>>=
##hole ggf. [[tworkwin]]>>
<<bestimme Cursorzeile [[line]] von [[tworkwin]]>>
##lese Arbeitsfenster auf [[worktext]] ein>>
textstart<-grep("^@",worktext)-1; textstart<-textstart[textstart>=line][1]
codestart<-grep("^@<<(.*)>>=",worktext)-1; codestart<-codestart[codestart>=line][1]
if(is.na(codestart))codestart<-Inf; if(is.na(textstart))textstart<-Inf
insertline<-if(codestart==textstart) NA else min(codestart,textstart)
anzrows<-length(unlist(strsplit(news,"\n")))
if(is.na(insertline)){
    insertline<-"end"
    try(tkinsert(tworkwin,"end","\n"))
    try(tkinsert(tworkwin,"end",paste(news,collapse="\n")))
    tkmark.set(tworkwin, "insert","end - 2 lines")
    tksee(tworkwin,"end")  # paste(insertline+anzrows,"0",sep="."))
}else{
  # in einem Text-Chunks muss ein Kl-Affe eingebaut werden.
    if(length(grep("@<<\\*>>=",news[1]))>0 && codestart < textstart) news<-c(news,"@\n")
    try(tkinsert(tworkwin,paste(insertline+1,"0",sep="."),paste(news,collapse="\n")))
    tkmark.set(tworkwin, "insert", paste(insertline+anzrows,"0",sep="."))
    tksee(tworkwin,paste(insertline+anzrows,"0",sep="."))
}
melde(insertline)
<<aktualisiere Texthervorhebungen>>
<<zeige Bilder im Textfenster an>>
tkfocus(tworkwin)
melde("inserted characters: \n",3,substring(news[1:min(7,length(news))],1,80))

@
\paragraph{[[text.tkinsert]] und [[text.tkget]]:}
Zur zuverlässigen Behandlung von geschweiften Klammern und ähnlichen
Zeichen wurde die Funktion [[tkinsert]] in einigen Fällen
durch die Funktion [[text.tkinsert]]
ersetzt. Erste Versionen führten eine Sonderbehandlung der
Zeichen [[\[{"}]$]] durch.
Wahrscheinlich ist die Funktion [[text.tkinsert]] bei der neuesten
{\sc Tcl/Tk}-Bibliothek überflüssig. Aber man kann ja nie wissen.

@
Der einzufügende Text ist über den formalen Parameter [[inserttext]]
zu übergeben. Die Position ist über [[position]] anzugeben.
Damit kann zum Beispiel [[tkinsert(tworkwin,"0.0",worktext)]]
durch [[text.tkinsert(tworkwin,"0.0",inserttext=worktext)]] ersetzt werden.
Später lassen sich so Anpassungen an Implementierungsänderungen leicht durchführen.
Besonderheiten für Sonderzeichen werden im Moment über entsprechende Events
gesteuert.
<<unused: definiere [[text.tkinsert]] und [[text.tkget]]>>=
text.tkinsert<-function(widget,position,inserttext=""){
  tkinsert(widget,position,paste(inserttext,collapse="\n"))
}
text.tkget<-function(widget,...){
  text<-tkget(widget,...)
  if(is.null(class(text)))  return(text)
  if("tclObj"==class(text)) return(tclvalue(text))
}


@
\paragraph{Arbeitsfenster einlesen:}
Das Auslesen des Reportfensters wird an verschiedenen Stellen benötigt.
Diese Operation wird hier in einem Text-Chunk zusammengefasst.
Hinter [[@<<tmp>>]] versteckt sich der Name für eine temporäre Datei.
Bei riesigen Texten ist die Aufsplittung in Zeilen innerhalb
von R zu zeitaufraubend, so dass dieses Problem mit einer
Schreibe-Lese-Operationen erledigt wird.
Der Text auf [[worktext]] ist der in Zeilen zerlegte Inhalt des
Arbeitsfensters.
<<lese Arbeitsfenster auf [[worktext]] ein>>=
if(!exists("revive.sys")) revive.sys<-get("revive.sys",envir=revive.env)
tworkwin<-get("tworkwin",envir=revive.sys)
worktext<-tclvalue(tkget(tworkwin,"0.0","end"))
if(nchar(worktext)<10000){
  worktext<-strsplit(worktext,"\n")[[1]]
}else{
  get("cat","package:base")(worktext,file=<<tmp>>)
  worktext<-myscan(file=<<tmp>>,"",sep="\n",blank.lines.skip=FALSE)
}

@
Der Name einer temporären Datei soll nur an einer Stelle
ermittelt werden. Dieses geschieht hier.
<<ermittle Namen einer temporären Datei>>=
tmp.file.name <- tempfile("rt-tmp")
assign(tmp.file.name,"tmp.file.name",env=revive.sys)

@
<<tmp>>=
get("tmp.file.name",env=revive.sys)

@
Bei einigen alten Versionen gab es Kollisionen im Falle von Fehlbenutzungen
zum Beispiel von [[readline]], wenn vor dem Eingabe-Ende [[AdvanceNo]]
aktiviert wurde.
Falls solche Dinge wieder auftreten, läßt sich mit diesem Code-Chunk
der Name der temporäre Datei für [[sink]]-Operationen verändern.
<<ermittle Namen einer Sink-Datei>>=
tmp.sink.name <- tempfile("rt-sink")
assign(tmp.sink.name,"tmp.sink.name",env=revive.sys)
@
vorher: "r.tmp"
<<tmp.sink>>=
get("tmp.file.name",env=revive.sys)

@
\subsubsection{Arbeitsfenstersteuerung: [[TrashROutput]]}
\paragraph{[[TrashROutput]] zur Entfernung des letzten Output-Abdrucks.}
Es hat sich als sehr wichtig erwiesen, unbrauchbare Output bequem
wieder entfernen zu können. Zwar ist noch nicht ganz sicher, ob
die Leichtigkeit der Entfernung weise ist, jedoch
wird sie bereitgestellt. Auch wird noch überlegt einen
Papierkorb zu definieren, aus dem sich die gelöschten
Stücke wieder herausholen lassen.
<<definiere Funktion für Knopf: [[TrashROutput]]>>=
fTrashROutput<-function(){
  melde("fTrashROutput",1)
  <<lese Arbeitsfenster auf [[worktext]] ein>>
  <<bestimme Cursorzeile [[line]] von [[tworkwin]]>>
  out.end  <-grep("^output-end",worktext)
  out.end  <-out.end[out.end>=(line-1)][1]
  if(is.na(out.end)) return()
  out.start <-grep("^output-start",worktext)
  out.start<-rev(out.start[out.start<out.end])[1]
  if(is.na(out.end)) return()
  code.start   <-grep("^@<<(.*)>>=",worktext)
  code.start <- rev(code.start[code.start<out.end])[1]
  if(is.na(code.start)) return()
  if(code.start>out.start) return()
  if("@"==worktext[out.start-1]) out.start<-out.start-1
  if(""==worktext[out.start-1]) out.start<-out.start-1
  if(""==worktext[out.start-1]) out.start<-out.start-1
  trash<-worktext[out.start:out.end]
  worktext<-worktext[-(out.start:out.end)]
  <<schreibe [[worktext]] ins Arbeitsfenster>>
  tkfocus(tworkwin)
  tkmark.set(tworkwin,"insert",paste(out.start-1,".0",sep=""))
  tksee(tworkwin,"insert")
  melde("fTrashROutput",2)
}

@
<<implementiere Eigenschaften der allgemeinen Knöpfe>>=
tkconfigure(TrashROutput,command=fTrashROutput)
tkbind(TopW, "@<<TrashROutput>>", fTrashROutput)


@
\subsubsection{Arbeitsfenstersteuerung: [[PlanRCode]]}
\paragraph{[[PlanRCode]] zur Vorbereitung eines neuen Schrittes.}
Dieser Knopf schreibt nur ein paar Zeichen ins Reportfenster.
<<definiere Funktion für Knopf: [[PlanRCode]]>>=
fPlanRCode<-function(){
  melde("fPlanRCode",1)
   <<lese Arbeitsfenster auf [[worktext]] ein>>
   news <- "\n@\n\n@<<*>>=\n\n"
   <<schreibe [[news]] hinter aktuellen Chunk>>
   <<lese Arbeitsfenster auf [[worktext]] ein>>
   <<aktualisiere Code-Chunk-Zähler und schreibe [[worktext]]>>
  melde("fPlanRCode",2)
}

@
Annahme: worktext hält Arbeitsfenster
<<aktualisiere Code-Chunk-Zähler und schreibe [[worktext]]>>=
<<bestimme Cursorzeile [[line]] von [[tworkwin]]>>
code.start<-grep("^@<<(.*)>>=",worktext)
try(if(0<length(code.start)){ # aktualisiere Chunk-Zaehler
       worktext[code.start]<-sub("^@<<(.*)>>=(.*)","@<<\\1>>=",worktext[code.start])
       worktext[code.start]<-paste(worktext[code.start]," (",1:length(code.start),")",sep="")
})
<<schreibe [[worktext]] ins Arbeitsfenster>>
tkmark.set(tworkwin, "insert", paste(line,"0",sep="."))
tksee(tworkwin,paste(line,"0",sep="."))
tkfocus(tworkwin)

@
<<implementiere Eigenschaften der allgemeinen Knöpfe>>=
tkconfigure(PlanRCode,command=fPlanRCode)
tkbind(TopW, "@<<PlanRCode>>", fPlanRCode)

@
\subsubsection{Arbeitsfenstersteuerung: [[Up]]}
\paragraph{[[Up]] zum Cursor-Zurücksetzen.}
a<-get("tworkwin",env=revive.sys)
tkmark.set(a,"insert","10.0")
<<definiere Funktion für Knopf: [[Up]]>>=
fUp<-function(){
  melde("fUp",1)
  <<bestimme Cursorzeile [[line]] von [[tworkwin]]>>
  <<lese Arbeitsfenster auf [[worktext]] ein>>
  code.start<-grep("^@<<(.*)>>=",worktext)
  code.start<-rev(code.start[code.start<line])[1]
  if(!is.na(code.start)) tkmark.set(tworkwin, "insert", paste(code.start,".0",sep=""))
  tksee(tworkwin,"insert")
  melde("fUp",2)
}

@
<<implementiere Eigenschaften der allgemeinen Knöpfe>>=
tkconfigure(Up,command=fUp)
tkbind(TopW, "@<<Up>>", fUp)

@
\subsubsection{Arbeitsfenstersteuerung: [[Down]]}
\paragraph{[[Down]] zum Cursor-Vorsetzen.}
<<definiere Funktion für Knopf: [[Down]]>>=
fDown<-function(){
  melde("fDown",1)
  <<bestimme Cursorzeile [[line]] von [[tworkwin]]>>
  <<lese Arbeitsfenster auf [[worktext]] ein>>
  code.start<-grep("^@<<(.*)>>=",worktext)
  code.start<-code.start[code.start>line][1]
  if(!is.na(code.start)) tkmark.set(tworkwin, "insert", paste(code.start,".0",sep=""))
  tksee(tworkwin,"insert")
  melde("fDown",2)
}

@
<<implementiere Eigenschaften der allgemeinen Knöpfe>>=
tkconfigure(Down,command=fDown)
tkbind(TopW, "@<<Down>>", fDown)

@
\subsubsection{Arbeitsfenstersteuerung: [[EvalRCode]]}
\paragraph{[[EvalRCode]] zur Evaluierung des Chunks, auf den der
Cursor zeigt.}
Vor der Aktivierung muß der betreffende Code-Chunk ermittelt werden.
Falls er noch nicht expandierte Module enthält, müssen diese
expandiert werden --- dieser lokale {\sc Tangle}-Prozeß wird weiter unten im
Abschnitt über reportorientiertes Arbeiten beschrieben.
Eventuell ausgegebene Ergebnisse werden in der Datei
[[<<tmp>>]] abgelegt und dann ins Arbeitsfenster geschrieben.
Ein Output, der zu viele Zeichen umfaßt, wird gekürzt, sofern es
länger als die Grenze [[maxol.sys]] ist.

Zur Sicherheit wird bei jeder Evaluation
eine Kopie des Reporttextes in die Datei
[[report-UnDo-bak.rev]] geschrieben! Diese kann mittels [[UnDo]] wieder
ins Arbeitsfenster geschrieben werden.
@
<<definiere Funktion für Knopf: [[EvalRCode]]>>=
fEvalRCode<-function(){ # vorher EvalCursorChunk
  melde("fEvalRCode",1)
  <<bestimme Cursorzeile [[line]] von [[tworkwin]]>>
  <<lese Arbeitsfenster auf [[worktext]] ein>>
  code.start<-grep("^@<<(.*)>>=",worktext)
  if(0==length(code.start)){cat("Warning: no code found!!!\n");return()}
  code.start<-code.start[code.start<=line]
  if(0<length(code.start)){
    <<ermittele mittels der Anfänge der Code-Chunks den Code [[code]]>>
  }
  if(0<length(code)){
    <<tangle ggf.\ aktuellen Chunk von [[worktext]], Ergebnis: [[code]]>>
    <<probiere [[code]] in [[revive.env]], Ergebnis: [[try.res]]>>
    <<lege auf [[ok]] ab, ob [[try.res]] Fehler zeigt>>
    if(ok){
      if(!is.null(try.res)&&0<length(try.res)){
        <<sichere letzten Zustand unter [[report-UnDo-bak.rev]]>>
        sink(<<tmp.sink>>);get("print",pos="package:base")(try.res);sink()
        news<-paste(myscan(<<tmp.sink>>,"",sep="\n"),collapse="\n")
        if(nchar(news)>maxol.sys)
            news<-paste(substring(news,1,maxol.sys),"...",sep="\n")
            news<-paste("", date(), news,"",sep="\n")
        <<schreibe [[news]] ans Ende des Outputfeldes>>
    ##zeige Ergebnisse in neuem Fenster an>>
      }
    } else { cat("evaluation not successful!!!\n") }
  } else { cat("no code found!!!\n") }
  <<generiere ein Ereignis zur Abarbeitung von [[cmds]]>>
  <<aktualisiere Texthervorhebungen>>
  ##lese Arbeitsfenster auf [[worktext]] ein##
  ##aktualisiere Code-Chunk-Zähler und schreibe [[worktext]]##
  <<zeige ggf. Warnungen an>>
  melde("fEvalRCode",2)
}

@
<<zeige ggf. Warnungen an>>=
options(show.error.messages=FALSE)
try({xxxxxxxxxxxxxxxxxxxxxxxxxxxxx})
options(show.error.messages=TRUE)
if(exists("last.warning",envir = .GlobalEnv)){
  lw<-get("last.warning",envir = .GlobalEnv)
  h<-grep("X11",names(lw)); if(length(h)>0) lw<-lw[-grep("X11",names(lw))]
  if(length(lw)>0){
    news<-c("last.warning(s):",
                   paste(paste(names(lw),lw,sep=" in: "),collapse="\n"))
    try(rm(last.warning,envir = .GlobalEnv))
    <<schreibe [[news]] ans Ende des Outputfeldes>>
  }
}

@
<<implementiere Eigenschaften der allgemeinen Knöpfe>>=
tkconfigure(EvalRCode,command=fEvalRCode)
tkbind(TopW, "@<<EvalRCode>>", fEvalRCode)


@
Anhängen oder überschreiben, das ist hier die Frage.
<<sichere letzten Zustand unter [[report-UnDo-bak.rev]]>>=
<<hole ggf. [[tworkwin]]>>
worktext<-TcltoWin.write(tclvalue(tkget(tworkwin,"0.0","end")))
get("cat","package:base")(worktext,file="report-UnDo-bak.rev")

@
Die vorsichtige Aktivierung von [[code]] wird auch an anderer Stelle benötigt.
<<probiere [[code]] in [[revive.env]], Ergebnis: [[try.res]]>>=
try.res <- try(eval(parse(text=code),envir=revive.env))

@
Um den Code von [[fEval...]] nicht zu unübersichtlich werden zu lassen, wurde
ein Block ausgelagert, der zudem auch noch an einer anderen Stelle Verwendung
findet.
Dabei handelt es sich um
die Aufgabe, den Code des letzten Code-Chunk mit Hilfe der Zeilen-Nummern
der Anfänge von Code-Chunks ([[code.start]]) zu ermitteln.
Auf [[code]] steht dann der gesuchte Code.
<<ermittele mittels der Anfänge der Code-Chunks den Code [[code]]>>=
if((code.start<-max(code.start)+1)>length(worktext)) return()
code.end  <-c(grep("^@",worktext),1+length(worktext))
code.end  <-min(code.end[code.end>code.start])-1
code<-worktext[code.start:code.end]
code<-code[code!=""]
if(length(weg.ab<-grep("^@<<(.*)>>=",code))>0) code<-code[-(weg.ab:length(code))]
if(length(code)==0 || code[1]=="@") code<-" "
melde("code:",3,code,"\n")

@
\subsubsection{Arbeitsfenstersteuerung: [[DumpCodeChunk]]}
\paragraph{[[DumpCodeChunk]] zur Speicherung des
aktuellen R-Chunks.}
@
<<definiere Kopf-Zeilen-Funktionen>>=
DumpCodeChunk<-function(){
  melde("DumpCodeChunk",1)
  <<bestimme Cursorzeile [[line]] von [[tworkwin]]>>
  <<lese Arbeitsfenster auf [[worktext]] ein>>
  code.start<-grep("^@<<(.*)>>=",worktext)
  if(0==length(code.start)) return()
  code.start<-code.start[code.start<=line]
  if(0<length(code.start)){
    <<ermittele mittels der Anfänge der Code-Chunks den Code [[code]]>>
  }
  if(0<length(code)){
    <<tangle ggf.\ aktuellen Chunk von [[worktext]], Ergebnis: [[code]]>>
  } else { cat("ERROR: no code found!!!\n"); return() }
  filename<-tkgetSaveFile(filetypes="{{Paper Files} {.R}}",
                          title="name of file to save code chunk?", initialdir=getwd(),
                          defaultextension=".R", initialfile="RCode-act.R")
  <<checke [[filename]], quitte ggf.>>
  try.res <- try(cat(code,file=filename,sep="\n"))
}

@
\subsubsection{Arbeitsfenstersteuerung: [[RemoveOut]]}
\paragraph{[[RemoveOut]] zum Löschung unbrauchbarer
Ergebnisse aus dem Outputfenster.}
<<definiere Funktion für Knopf: [[RemoveOut]]>>=
fRemoveOut<-function(){
  melde("fRemoveOut",1)
  worktext<-paste("")
  <<schreibe [[worktext]] ins Outputfenster>>
  melde("fRemoveOut",2)
}

@
\subsubsection{Arbeitsfenstersteuerung: [[Insert]]}
\paragraph{[[Insert]] zur Übertragung des Inhalts aus dem
Output- ins Arbeitsfenster.}
<<definiere Funktion für Knopf: [[Insert]]>>=
fInsert<-function(){
  melde("fInsert",1)
  <<lese Arbeitsfenster auf [[worktext]] ein>>
  news<-tclvalue(tkget(toutwin,"0.0","end"))
  if(1<nchar(news)){
    news<-paste("\n@","output-start",news,"output-end\n",sep="\n")
    news<-gsub("\n+","\n",news)
    <<schreibe [[news]] hinter aktuellen Chunk>>
    worktext<-""
    <<schreibe [[worktext]] ins Outputfenster>>
  }
  melde("fInsert",2)
}

@
\subsubsection{Arbeitsfenstersteuerung: [[CopyToEnd]]}
\paragraph{[[CopyToEnd]] zur Übertragung des Inhalts aus dem
Output- ans Ende des Arbeitsfensters.}
<<definiere Kopf-Zeilen-Funktionen>>=
CopyToEnd<-function(){
  melde("CopyToEnd",1)
  news<-tclvalue(tkget(toutwin,"0.0","end"))
  if(1<nchar(news)){
    news<-paste("\n@","output-start",news,"output-end\n",sep="\n")
    news<-gsub("\n+","\n",news)
    <<lese Arbeitsfenster auf [[worktext]] ein>>
    <<schreibe [[news]] ans Ende des Arbeitstextes>>
    worktext<-""
    <<schreibe [[worktext]] ins Outputfenster>>
  }
  melde("CopyToEnd",2)
}

@
<<implementiere Eigenschaften der allgemeinen Knöpfe>>=
tkconfigure(RemoveOut,command=fRemoveOut)
tkbind(TopW, "@<<RemoveOut>>", fRemoveOut)
tkconfigure(Insert,command=fInsert)
tkbind(TopW, "@<<Insert>>", fInsert)
tkconfigure(SavePlot,command=fSavePlot)
tkbind(TopW, "@<<SavePlot>>", fSavePlot)
#tkconfigure(CopyToEnd,command=CopyToEnd)
#tkbind(TopW, "@<<CopyToEnd>>", CopyToEnd)

@
\subsubsection{Arbeitsfenster:  Bereitstellung besonderer Zeichen}
Einige besondere Zeichen müssen in einem Text-Widget erst erzeugt werden.
Genauer handelt es sich um die Zeichen: [[\,[,],{,},~,@]].
Für sie werden geeignete Bindungen definiert.
Da dieses Eingabeverhalten auch an anderer Stelle verlangt ist,
wird ein allgemeiner Chunk die Zeichenerzeugung beschreiben.
Erforderlich ist jedoch,
daß das betreffende Widget über den Namen [[twin]] ansprechbar ist.

Ein in einem Textfenster eingegebener Umlaut führt beim Auslesen
auf eine R-Char-Variable zwei Zeichen zum Vorschein. Damit 
bei der Speicherung ein Windows-Umlaut in der Datei ankommt muss
eine Ersetzung erfolgen. 
Der Datei-Code für die Umlaute in
[[äöüÄÖÜß]] ist [["\344\366\374\304\326\334\337"]]. 
Für die Erzeugung eines Rückstriches muss beachtet werden,
dass der Rückstrich auf derselben Taste wie [[ß]] liegt.
<<stelle besondere Zeichen in [[twin]] zur Verfügung>>=
f.sonderzeichen<-function(zeichen){
  function(){
    tkinsert(twin,"insert",zeichen)
    if(<<das OS ist Windows>>)tkdelete(twin,"insert-1chars")
  }
}
f.umlaut<-function(zeichen){
  function(){
    return()
    if(zeichen=="\337" & tclvalue(tkget(twin,"insert-1chars","insert"))=="\\") return()
    tkinsert(twin,"insert",zeichen); tkdelete(twin,"insert-2chars")
  }
}
tkbind(twin,"@<<LKeckig>>", f.sonderzeichen("["))
tkbind(twin,"@<<RKeckig>>", f.sonderzeichen("]"))
tkbind(twin,"@<<Tilde>>",   f.sonderzeichen("~"))
tkbind(twin,"@<<LKgeschw>>",f.sonderzeichen("{"))
tkbind(twin,"@<<RKgeschw>>",f.sonderzeichen("}"))
tkbind(twin,"@<<Klammera>>",f.sonderzeichen("@"))
tkbind(twin,"@<<Pipe>>",    f.sonderzeichen("|"))
tkbind(twin,"@<<Backsl>>",  f.sonderzeichen("\\"))

@
\subsubsection{Arbeitsfenster: [[Strg Pagedown]] zur Kopie alter Code-Chunk}
Zur Wiederholung von Anweisungen ist es sehr unschön, diese immer wieder
eintippen zu müssen. Deshalb soll es möglich sein, solche durch die Tastenkombination
[[Strg Pagedown]] ans Ende des Arbeitsfeldes zu kopieren.
Mehrfachklicks, die zunächst als Lösung dienen sollten, besaßen zu viele
Nachteile.
<<definiere Wirkung von [[Strg Pagedown]] im Reportfenster>>=
tkbind(tworkwin,"@<<ActChunk>>", function() {
  <<bestimme Cursorzeile [[line]] von [[tworkwin]]>>
  <<lese Arbeitsfenster auf [[worktext]] ein>>
  code.start<-grep("^@<<(.*)>>=",worktext)
  code.start<-code.start[code.start<line]
  if(0<length(code.start)){
    <<ermittele mittels der Anfänge der Code-Chunks den Code [[code]]>>
    news<-paste("\n@\n@<<*>>=\n",paste(code,collapse="\n"),"\n",sep="")
    <<schreibe [[news]] ans Ende des Arbeitstextes>>
  }
   tkmark.set(tworkwin, "insert", "end")
   tksee(tworkwin,"end")
})

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Reportorientiertes Arbeiten --- Implementation}

@
\subsection{Implementation der Oberflächenelemente}

Für ein reportorientiertes Arbeiten muß das Angebot im Menü [[File]] des
Kopf-Frames erweitert werden.

\subsubsection{[[File]]: Ergänzung neuer Menüeinträge}
Die Stelle der Arbeit kann über [[SetWorkPath]] gesetzt werden.
Durch Laden von Reports [[OpenReport]] oder Speicherung [[SaveReport]]
wird ebenfalls ein Verzeichniswechsel durchgeführt.

<<definiere Kopf-Frame>>=
tkadd(mbFile.menu,"command", command=SetWorkPath,
      label="SetWorkPath:   change working path")
tkadd(mbFile.menu, "separator")
tkadd(mbFile.menu,"command", command=OpenReport,
      label="OpenReport:   APPEND file to text field")
tkadd(mbFile.menu,"command", command=SaveReport,
      label="SaveReport:   save text field to file")

@
\subsubsection{[[View]]: Anzeigen von Reports}
Für die Ansicht ist ein Browser notwendig, z.B.\ [[mozilla]].
Der Browser kann gesetzt werden über:
[[options(browser="/opt/kde3/bin/konqueror")]]
<<definiere Kopf-Frame>>=
tkadd(mbFile.menu,"command", command=ViewReport.html,
      label="ViewReport.html:   view html representation of report")
tkadd(mbFile.menu,"separator")

@
<<definiere Kopf-Frame>>=
if(but.Wizardry){
  tkadd(mbFile.menu,"command", command=OpenRevbook,
      label="OpenCompbook:   load compbook from library relax/rev")
  tkadd(mbFile.menu, "separator")
}
<<definiere Datei-Menü-Eintrag zur Programmbeendigung>>


@
\subsubsection{[[Edit]]: Ergänzung neuer Menüeinträge}
[[EditReport]] startet einen externen Editor.
[[SaveDiffReport]] speichert Differenz.
[[RunAll]] wiederholt alle bisherigen Start- und Stern-Chunks.
[[DeleteAll]] löscht das Reportfenster.
[[UnDo]] stellt den Zustand im
Reportfenster her, wie er vor der letzten Code-Aktivierung war.
[[EvalCursorChunk]] aktiviert Chunk, auf den der Cursor zeigt.
<<definiere Kopf-Frame>>=
tkadd(mbEdit.menu, "separator")
tkadd(mbEdit.menu, "command", command=EditReport,
      label=paste("EditReport:   use editor",editor.sys,"for editing"))
tkadd(mbEdit.menu, "command", command=DumpCodeChunk,
      label=paste("DumpCodeChunk:   save code chunk in a file"))
tkadd(mbEdit.menu, "command", command=CopyToEnd,
      label=paste("CopyToEnd:   copy output to end of text"))
tkadd(mbEdit.menu, "separator")
tkadd(mbEdit.menu, "command", command=RunAll,
      label="RunAll:   run all start- and *-code chunks")
tkadd(mbEdit.menu, "command", command=RunStart,
      label="RunStart:   run all start-code chunks")
tkadd(mbEdit.menu, "separator")
tkadd(mbEdit.menu, "command", command=DeleteAll,
      label="DeleteAll:   clear text field")
tkadd(mbEdit.menu, "separator")
tkadd(mbEdit.menu, "command", command=UnDo,
      label="UnDo:   load report-UnDo-bak.rev (report before last evaluation)")

@
<<unused>>=
tkadd(mbEdit.menu, "separator")
tkadd(mbEdit.menu, "command", command=SaveDiffReport,
      label="SaveDiffReport:   save difference between actual and old file")

@
\subsubsection{[[EvalRCode]]: lokaler {\sc Tangle}-Prozeß}
Für den angesprochenen lokalen {\sc Tangle}-Prozeß bedarf es keiner
Oberflächenelemente, siehe Abschnitt zur Implementation.

@
\subsection{Implementation der Funktionalitäten}

Es werden folgende Funktionen entworfen:\\
{ \small
[[SetWorkPath]],
% [[ListReportFiles]] (im Moment ohne Verwendung),
[[SaveReport]],
[[OpenReport]],
% [[SaveAsHtml]],
[[EditReport]],
[[SaveDiffReport]],\\
[[RunAll]],
[[RunStart]],
[[DeleteAll]] und
[[UnDo]]
} % end of small
Außerdem ist der lokale {\sc Tangle}-Prozeß zu beschreiben.

@
\subsubsection{Kopfzeile: [[File]] --- [[SetWorkPath]]}
\paragraph{[[SetWorkPath]] zur Ort für Reports.}
Die Funktion legt den Ort der Arbeit fest.
Der aktuelle Ort läßt sich mit Hilfe
von [[getwd]] ermitteln und mit [[setwd]] setzen.
Der Anwender muß nur nach dem neuen Ort gefragt werden.
Der neue Ort wird nicht als Systemvariable gespeichert.
Falls er nicht existiert, wird eine Fehlermeldung ausgegeben.
<<definiere Kopf-Zeilen-Funktionen>>=
SetWorkPath<-function(){
  melde("SetWorkPath",1)
  path<-tkchooseDirectory(title="Reportverzeichniswahl",initialdir=getwd())
  if(!is.character(path)) path<-tclvalue(path)
  if(path=="") return() else try.res <- try(setwd(path))
  <<lege auf [[ok]] ab, ob [[try.res]] Fehler zeigt>>
  if(ok){
    cat("new directory:",getwd(),"\n")
  }else{
    cat("ERROR: change of directory failed!!!\n")
  }
  melde("SetWorkPath",2)
}

@
Unter Windows95 führt der Aufruf von [[tk_chooseDirectory]]
zum Absturz. Der Verzeichniswechsel muß in einem solchen Fall
direkt über [[setwd()]] ausgeführt werden.

@
\subsubsection{Kopfzeile: [[File]] --- [[SaveReport]]}
\paragraph{[[SaveReport]] zur Abspeicherung eines Reports.}
Die Speicherung von Reports erfordert Schreib-Operationen,
die eventuell mißlingen. Deshalb werden diese innerhalb von [[try]]
ausgeführt. Ein solches Probieren wird auch an anderen
Stellen vorkommen. Deshalb wird ein Chunk zur Wiederverwendung eingerichtet,
der das Ergebnis auf einen möglichen Fehler hin untersucht.
<<definiere Kopf-Zeilen-Funktionen>>=
SaveReport<-function(){
  melde("SaveReport",1)
  filename<-tkgetSaveFile(filetypes="{{Paper Files} {.rev}}",
                          title="name of report file?", initialdir=getwd(),
                          defaultextension=".rev", initialfile=workname.sys)
  <<checke [[filename]], quitte ggf.>>
  <<lese Arbeitsfenster auf [[worktext]] ein>>
  <<speichere [[worktext]] als Rev-File ab, Indikator: [[ok]]>>
  if(ok){
    <<aktualisiere Reportname>>
    <<kopiere ggf.\ Bilder ins neue Verzeichnis>>
    <<wechsele ins neue Verzeichnis>>
    melde(paste("report file",filename,"saved\n"),0)
    melde(paste("w",workname.sys),"cmd.msg")
  } else {
    cat("ERROR: write operation failed!!!\n")
  }
  <<speichere Report als Html-File>>
  melde("SaveReport",2)
  return("ok")
}

@
<<implementiere Eigenschaften der allgemeinen Knöpfe>>=
tkbind(TopW, "@<<SaveReport>>", SaveReport)

@
Alte Behandlung der TLD-Zeile:
<<old>>=
worktext<-sub("^@<<(.*)>>= \\([0-9]*\\)","@<<\\1>>=",worktext)


@
Was sollte man tun, wenn der File existiert? Aus Gründen der Sicherheit
wird die Datei ggf.\ gesichert und eine entsprechende Meldung
per Message-Box ausgegeben.
<<sichere alten File auf [[old.tmp]], falls [[filename]] existiert>>=
## im Moment nicht aktiv ##
if(file.exists(filename)){
  copy.cmd <- if(<<das OS ist Windows>>) "command.com /c copy" else "cp"
  h<-paste(filename,".bak",sep="")
  system(paste(copy.cmd,filename,h))
  tkmessageBox(title="Warnung", icon="warning",
       message=paste("File existierte!\n ",filename,"\ngesichert unter:\n ",h))
}

@
Vor der Speicherung sollten einige Dinge geschickt übersetzt werden.
2.3.2004: Unter Linux funktionierte auf einmal nicht mehr die korrekte
Speicherung von Umlauten. Die eingelesenen Umlaute waren in R nicht mehr
zu erkennen und zu bearbeiten. Deshalb wurde experimentell die Zeile
mit [[cat..]] unter Linux ersetzt durch Tcl-Zeilen. Die Lösung ist aber unbefriedigend,
da keine weitere Bearbeitung in R erfolgen kann.
Interessanterweise liefert der erste .Tcl-Aufruf die falschen der zweite
die richtigen Zeichen. Der zweite kann jedoch nicht aufgefangen werden.
\begin{verbatim}
> .Tcl("set bbb")
<Tcl> asdfÇÏÇôÇ¬ÇÇÇÇasdf

> .Tcl("puts $bbb")
asdfäöüÄÖÜßasdf
\end{verbatimÿ}
Auch hilft eine Umkodierung mit allen möglichen code Tabellen nicht weiter:
\begin{verbatim}
> .Tcl(paste("set bbb [ encoding convertfrom",readline()," $aaa ] ")); .Tcl("set bbb")

top<-tktoplevel();tt<-tktext(top);tkpack(tt)
.Tcl("set ccc [ .Tk.ID(tt) insert \"0.0 end\" ] )

\end{verbatim}
<<speichere [[worktext]] als Rev-File ab, Indikator: [[ok]]>>=
worktext<-sub("^@<<(.*)>>=(.*)","@<<\\1>>=",worktext)
worktext<-sub("^output-start","\\\\begin{verbatim}",worktext)
worktext<-sub("^output-end","\\\\end{verbatim}",worktext)
if(0==length(grep("\\\\end\\{document\\}",worktext))) #2.1.0
   worktext<-c(worktext,"@\n\\end{document}")
worktext<-TcltoWin.write(worktext)
try.res <- try(cat(worktext,file=filename,sep="\n"))
<<lege auf [[ok]] ab, ob [[try.res]] Fehler zeigt>>

@
Ersetzungsoperation direkt unter Tcl/Tk
<<old>>=
    try(.Tcl(paste("set fileId [open ",filename," w 0600]")))
   #### try.res<-"ok"; try(.Tcl(paste("puts $fileId [ ",.Tk.ID(tworkwin)," get \"0.0\" \"end\" ] ")))
    try.res<-"ok"; try(.Tcl(paste("set xyz [ ",.Tk.ID(tworkwin)," get \"0.0\" \"end\" ] ")))
    try.res<-"ok"; try(.Tcl(paste("set xyz [ regsub -all output-start $xyz ",
                         "\\\\begin{verbatim} ]" )))
    try.res<-"ok"; try(.Tcl(paste("set xyz [ regsub -all output-end $xyz ",
                         "\\\\end{verbatim} ]" )))
    try.res<-"ok"; try(.Tcl(paste("puts $fileId $xyz")))
    try(.Tcl("close $fileId "))
@
\verb+set xyz [ regsub "^output-start"  [ .t  get "0.0" "end" ]  "\\begin\{document\}" ]+

@
Diese Operation wird an verschiedenen Stellen gebraucht, so
daß ein eigener Code-Chunk eingerichtet wird.
[[ok]] zeigt [[TRUE]] im Erfolgs- und [[False]] im Fehlerfall.
<<lege auf [[ok]] ab, ob [[try.res]] Fehler zeigt>>=
if(is.function(try.res)){
  ok <- "OK"
} else {
  if(mode(try.res)=="externalptr") try.res<-"ok"
  ok<-try.res[1]
  if(is.null(ok) ||is.na(ok)|| is.name(ok) || is.list(ok) || is.numeric(ok)) ok <- "OK"
  if(!is.character(ok)) { ok <- "OK" }
}
if(0!=length(ok)&&("Error"==substring(ok,1,5) | "Fehler"==substring(ok,1,6))){
  ok<-F
  cat(unclass(try.res),"\n")
  cat("operation failed in:",as.character(sys.call()),"!!!\n")
} else { ok<-T }


@
<<aktualisiere Reportname>>=
workname.sys<-sub(paste(".*",.Platform$file.sep,sep=""),"",filename)
lworkname.sys<-get("lworkname.sys",envir=revive.sys)
tkconfigure(lworkname.sys,text=workname.sys)
assign("workname.sys",workname.sys,envir=revive.sys)

@
\subsubsection{Kopfzeile: [[File]] --- [[SaveDiffReport]]}
\paragraph{[[SaveDiffReport]] zum Speichern von Unterschieden.}
\begin{enumerate}
\item [[worktext]] speichern
\item [[diff alt neu > diffreport]]
\item [[cat diffreport| grep "^[0-9]" > difflines]]
\item einlesen und [[difflines<-sub("^([0-9]*)[a-z]","",difflines)]]
\end{enumerate}
<<definiere Kopf-Zeilen-Funktionen>>=
# ermittle neue Zeilen:
SaveDiffReport<-function(){
  melde("SaveDiffReport",1)
  filename<-tkgetSaveFile(filetypes="{{Paper Files} {.html}}",
                          title="Diff-File-Name?", initialdir=getwd(),
                          defaultextension=".html", initialfile=
              paste("diff",workname.sys,sep="-"))
  <<checke [[filename]], quitte ggf.>>
  <<lese Arbeitsfenster auf [[worktext]] ein>>
  try.res <-try(cat(worktext,file=<<tmp>>,sep="\n"))
  <<lege auf [[ok]] ab, ob [[try.res]] Fehler zeigt>>
  if(!ok) return()
  # stelle Differenzen fest
  system(paste("diff ",workname.sys," ",<<tmp>>," | grep \"^[0-9]\" > ",<<tmp.sink>>))
  difflines<-scan(<<tmp.sink>>,"",blank.lines.skip=F,sep="\n")
  difflines<-sub("^([0-9]*)[a-z]","",difflines)
  difflines<-sub(",",":",difflines)
  difflines<-paste("c(",paste(difflines,collapse=","),")")
  try(difflines<-eval(parse(text=difflines)))
  if(length(difflines)>0 || "ERROR"!=substring(unlist(difflines)[1],1,5)){
    # suche Chunks:
    worktext<-c("@",worktext,"@")
    difflines<-difflines+1
    chunkbegins<-grep("(^@)|(^@<<(.*)>=)", worktext)
    chunk.log<-rep(F,length(chunkbegins))
    ch.new<- 0<hist(difflines,plot=FALSE,
                    breaks=c(chunkbegins,length(worktext)+1)-0.5)$counts
    ch.new<- ch.new | c(ch.new[-1],F) | c(F,ch.new[-length(ch.new)])
    ch.new<-seq(ch.new)[ch.new]
    # extrahiere Chunks:
    lines<-paste(chunkbegins[ch.new],":",
             c(chunkbegins[-1],chunkbegins[length(chunkbegins)]+1)[ch.new]-1)
    lines<-paste(lines,collapse=",")
    lines<-try(eval(parse(text=paste("c(",lines,")"))))
    if(ch.new[1]) lines<-lines[-1]
    if(ch.new[length(ch.new)]) lines<-lines[-length(lines)]
    difftext<-worktext[unique(lines)]
    # speichere difftext
    SaveAsHtml(difftext,filename)
    try.res <-try(cat(difftext,file=filename,sep="\n"))
  }
  melde("SaveDiffReport",2)
}

@
\subsubsection{Kopfzeile: [[File]] --- [[OpenReport]]}
\paragraph{[[OpenReport]] zum Öffnen von Reportdateien.}
Nach der Erkundung des Dateinamens wird der Reportdatei gelesen und
ans Ende des Arbeitsfenster gehängt.
<<definiere Kopf-Zeilen-Funktionen>>=
OpenReport<-function(){
  melde("OpenReport",1)
  filename<-tkgetOpenFile(filetypes="{{Paper Files} {.rev}}",
                          title="Welches Papier soll geladen werden?",
                          defaultextension=".rev", initialfile=workname.sys,
                          initialdir=getwd())
  <<checke [[filename]], quitte ggf.>>
  try.res<-try(myscan(filename,"",sep="\n",blank.lines.skip=FALSE))
  <<lege auf [[ok]] ab, ob [[try.res]] Fehler zeigt>>
  if(ok){
    <<wechsele ins neue Verzeichnis>>
    <<aktualisiere Reportname>>
    try.res<-WinToTcl.read(try.res)
        ## Eintrag mit Entfernung des bisherigen Inhalts:
        ## worktext<-paste(try.res, collapse="\n"); @<<schreibe [[worktext]] ins Arbeitsfenster>>
    news<-c("",try.res)
    <<schreibe [[news]] ans Ende des Arbeitstextes>>
    <<lese Arbeitsfenster auf [[worktext]] ein>>
    <<aktualisiere Code-Chunk-Zähler und schreibe [[worktext]]>>
    RunStart()
    <<aktualisiere Texthervorhebungen>>
    <<zeige Bilder im Textfenster an>>
    melde(paste("r", workname.sys), "cmd.msg")
  } else { cat("ERROR: File",filename,"not found!!!\n") }
  melde("OpenReport",2)
}

@
<<checke [[filename]], quitte ggf.>>=
if(!is.character(filename)) filename<-tclvalue(filename)
if(filename=="") return("cancel")

@
An verschiedenen Stellen ist es erforderlich, das Arbeitsfenster zu
aktualisieren. Deshalb wird ein eigener Code-Chunk spendiert.
<<schreibe [[worktext]] ins Arbeitsfenster>>=
if(length(worktext)>1) worktext<-paste(worktext,collapse="\n")
tkdelete(tworkwin,"0.0","end")
try(tkinsert(tworkwin,"0.0",paste(worktext,collapse="\n")))
tksee(tworkwin,"end")
<<aktualisiere Texthervorhebungen>>
<<zeige Bilder im Textfenster an>>

@
Entsprechend für das Outputfenster:
<<schreibe [[worktext]] ins Outputfenster>>=
if(length(worktext)>1) worktext<-paste(worktext,collapse="\n")
tkdelete(toutwin,"0.0","end")
try(tkinsert(toutwin,"0.0",paste(worktext,collapse="\n")))
@
<<kopiere ggf.\ Bilder ins neue Verzeichnis>>=
olddir<-getwd(); newdir<-sub("(.*)/(.*)","\\1",filename)
if(olddir!=newdir){
  rev<-grep("includegraphics",worktext,value=TRUE)
  if(0<length(rev)){
    pics<-sub("(.*)\\{(p.*\\.ps)\\}(.*)","\\2",rev)
    pics<-c(pics,sub("ps$","jpg",pics))
    mess<-NULL
    for(pic in pics) {
      if(file.exists(pic)){
        a<-file.copy(pic,paste(newdir,pic,sep="/"))
        mess<-c(mess,if(a) paste("picture",pic,"to",newdir) else
                                        paste("warning: picture", pic,"not copied"))
      }
    }
    cat(mess,sep="\n")
    "process of copying file(s) finished"
  }
}


@
<<wechsele ins neue Verzeichnis>>=
h <- strsplit(filename,.Platform$file.sep)[[1]]
workname.sys<-rev(h)[1]
workpath.sys<-paste(h[-length(h)],collapse=.Platform$file.sep)
setwd(workpath.sys)

@
<<definiere Kopf-Zeilen-Funktionen>>=
OpenRevbook<-function(){
  melde("OpenRevbook",1)
  h<-file.path(relax.path,"rev")
  filename<-tkgetOpenFile(filetypes="{{Paper Files} {.rev}}",
                          title="Choose paper to be loaded",
                          defaultextension=".rev", initialfile=workname.sys,
                          initialdir=h)
  <<checke [[filename]], quitte ggf.>>
  try.res<-try(myscan(filename,"",sep="\n",blank.lines.skip=FALSE))
  <<lege auf [[ok]] ab, ob [[try.res]] Fehler zeigt>>
  if(ok){
    <<aktualisiere Reportname>>
    code.ch<-grep("^@<<(.*)>>=",try.res)
    if(0<length(code.ch))
       try.res[code.ch]<-paste(try.res[code.ch], " (",1:length(code.ch),")",sep="")
       try.res<-WinToTcl.read(try.res)
        worktext<-paste(try.res, collapse="\n") # alter Inhalt wird entfernt
	<<schreibe [[worktext]] ins Arbeitsfenster>>
      RunStart()
    <<aktualisiere Texthervorhebungen>>
    <<zeige Bilder im Textfenster an>>
    melde(paste("r", workname.sys), "cmd.msg")
  } else { cat("ERROR: File",filename,"not found!!!\n") }
  melde("OpenRevbook",2)
}
@
<<definiere Kopf-Zeilen-Funktionen>>=
LoadRwtools<-function(){
  melde("LoadRwtools",1)
  path<-file.path(relax.path,"rev/robj.R")
  fns<-readLines(path) #2.1.0
  try(eval(parse(text=fns),
               envir=pos.to.env(which(.path.package("relax")==searchpaths()))))
  melde("LoadRwtools",2)
}

@
\subsubsection{Kopfzeile: [[File]] --- [[SaveAsHtml]]}
\paragraph{[[SaveAsHtml]] zur Erstellung eines [[Html]]-Dokuments.}
Dieser Abschnitt ist noch im Aufbau. Er dient mehr dazu, eine Idee
zu skizzieren. Zur Zeit wir die Abspeicherung als Html-File immer
dann vorgenommen, wenn der Report gespeichert wird.
<<speichere Report als Html-File>>=
{
  melde("SaveReportAsHtml",1)
  <<lese Arbeitsfenster auf [[worktext]] ein>>
  SaveAsHtml(worktext,workname.sys)
  melde("SaveReportAsHtml",2)
}

@
Für die Speicherung als [[Html]]-File soll eine Funktion eingesetzt werden.
<<definiere [[SaveAsHtml]]>>=
SaveAsHtml<-function(savetext,filename="lotto.rev"){
  <<initialisiere [[AsHtml]]; [[AsHtml]]>>
  <<rette Html-Anweisungen; [[AsHtml]]>>
  <<bearbeite Text-Chunks; [[AsHtml]]>>
  <<bearbeite Code-Chunks; [[AsHtml]]>>
  <<rekonstruiere alte Html-Anweisungen; [[AsHtml]]>>
  <<klebe Kopf und Schwanz an; [[AsHtml]]>>
  <<checke Namen und speichere; [[AsHtml]]>>
}

@
nur für Testzwecke
<<initialisiere [[AsHtml]]; [[AsHtml]]>>=

@
<<rette Html-Anweisungen; [[AsHtml]]>>=
# savetext<-gsub("<p>",NL,savetext)

@
<<bearbeite Text-Chunks; [[AsHtml]]>>=
<<behandle Code im Text; [[AsHtml]]>>
<<bearbeite Outputs; [[AsHtml]]>>
<<blende includegraphics-Zeilen aus; [[AsHtml]]>>
<<ersetze Umlaute; [[AsHtml]]>>
## savetext<-gsub("^@","</pre><p>",savetext)
savetext<-gsub("^@","</pre>",savetext)

@
Die Umlautersetzung (der letzte Punkt im letzten Chunk)
wird an zentraler Stelle der Umlautersetzung abgehandelt.

@
Kleinerzeichen ersetzen
<<behandle Code im Text; [[AsHtml]]>>=
savetext<-gsub("@@<<","&lt;&lt;",savetext)

@
<<blende includegraphics-Zeilen aus; [[AsHtml]]>>=
if(length(h<-grep("includegraphics",savetext))>0){
  savetext[h]<-paste("<!--",savetext[h],"-->")
}

@
<<bearbeite Outputs; [[AsHtml]]>>=
#savetext<-gsub("((\\\\begin\\{verbatim\\})|(output-start))","<p><pre>",savetext)
#savetext<-gsub("((\\\\end\\{verbatim\\})|(output-end))",  "</pre><p>",savetext)
savetext<-gsub("((\\\\begin\\{verbatim\\})|(output-start))","<pre>",savetext) #2.1.0
savetext<-gsub("((\\\\end\\{verbatim\\})|(output-end))",  "</pre>",savetext) #2.1.0

@
<<bearbeite Code-Chunks; [[AsHtml]]>>=
<<ersetze TLD-Zeilen; [[AsHtml]]>>
<<ersetze externe Verweise; [[AsHtml]]>>

@
<<ersetze externe Verweise; [[AsHtml]]>>=
savetext<-gsub("#<(.*)>#","</pre>&lt;\\1&gt;<pre>",savetext)

@
<<ersetze TLD-Zeilen; [[AsHtml]]>>=
no <- grep("@<<(.*)>>=",savetext)
if(0<length(no)){
  savetext<-gsub("^@<<(.*)>>=",  "&lt;&lt;\\1 ",savetext)
  savetext[no]<-paste(savetext[no],1:length(no),"&gt;&gt;=<pre>")
  savetext<-gsub("@<<(.*)>>","</pre>&lt;&lt;\\1&gt;&gt; <pre>",savetext)
}
@
<<rekonstruiere alte Html-Anweisungen; [[AsHtml]]>>=
# savetext<-gsub(NL,"<p>",savetext)

@
<<klebe Kopf und Schwanz an; [[AsHtml]]>>=
savetext<-c("<HTML><HEAD><TITLE>$$1</TITLE></HEAD>",
            "<BODY BGCOLOR=\"#FFFFFF\">", savetext, "</BODY></HTML>")

@
<<checke Namen und speichere; [[AsHtml]]>>=
savetext<-sub("$","<br>",savetext)
savetext<-sub("pre><br>$","pre>",savetext)
n<-nchar(filename)
if(is.null(n)||5>n||substring(filename,n-3,n)!=".rev"){
    cat("ERROR: File name not ok!!!\n")
}else{
    filename<-paste(substring(filename,1,n-3),"html",sep="")
    try(get("cat","package:base")(savetext,sep="\n",file=filename))
}

@
Ende der Definition von [[SaveAsHtml]].


@
\subsubsection{Kopfzeile: [[File]] --- [[ViewReport.html]]}
\paragraph{[[ViewReport.html]] zum Anzeigen von formatierten Rohreports.}
Falls der Browser nicht richtig verankert ist, soll [[mozilla]] verwendet werden.
<<definiere Kopf-Zeilen-Funktionen>>=
ViewReport.html<-function(){
  melde("ViewReport.html",1)
  n<-nchar(filename<-workname.sys)
  if(is.null(n)||5>n||substring(filename,n-3,n)!=".rev"){
    cat("ERROR: file name not ok!!!\n")
  }else{
    fname<-paste("file://",getwd(),.Platform$file.sep,sub("rev$","html",filename),sep="")
    if(version$os=="Win32" || version$os=="mingw32"){
         if(browser.sys=="") shell(paste("explorer", fname),wait=FALSE) else
	                                 shell(paste(browser.sys, fname),wait=FALSE)  # 050607
    }else
        if(browser.sys==""){
	  if(file.exists(options()$browser))
            try(browseURL(fname))
          else
            try(browseURL(fname,browser="mozilla"))
	}else try(browseURL(fname,browser=browser.sys))  #050607
  }
  melde("ViewReport.html",2)
}

@
\subsubsection{Kopfzeile: [[Edit]] --- [[EditReport]]}
\paragraph{[[EditReport]] zur Bearbeitung des Reports mit einem Editor.}
Als Zwischenablage wird eine Datei mit dem Namen, der sich auf
[[<<tmp>>]] befindet, angelegt.
Achtung Seiteneffekt: Sie wird nicht automatisch wieder entfernt.
<<definiere Kopf-Zeilen-Funktionen>>=
EditReport<-function(){
  melde("EditReport",1)
  <<lese Arbeitsfenster auf [[worktext]] ein>>
  worktext<-TcltoWin.write(worktext)
  try.res <-try(cat(worktext,file=<<tmp>>,sep="\n"))
  <<lege auf [[ok]] ab, ob [[try.res]] Fehler zeigt>>
  if(ok){
    try.res <- try(system(paste(editor.sys, <<tmp>>)))
    <<lege auf [[ok]] ab, ob [[try.res]] Fehler zeigt>>
    if(ok){
    try.res<-worktext<-try(myscan(<<tmp>>,"",sep="\n",blank.lines.skip=FALSE))
      <<lege auf [[ok]] ab, ob [[try.res]] Fehler zeigt>>
      if(ok){
        if(<<das OS ist Windows>>)worktext<-WinToTcl.read(worktext)
        <<aktualisiere Code-Chunk-Zähler und schreibe [[worktext]]>>
        worktext <- paste(worktext,collapse="\n")
#       worktext <- sub("\\\\end\{document\}","%end\{document\}",worktext)
      } else {  cat("ERROR: file open operation not successful!!!\n") }
    } else {  cat("ERROR: editor start not successful!!!\n") }
  } else { cat("ERROR: file write operation not successful!!!\n") }
  melde("EditReport",2)
}

@
\subsubsection{Kopfzeile: [[Edit]] --- [[RunAll]]}
\paragraph{[[RunAll]] zur Zustandswiederherstellung.}
Um nach einer unterbrochenen Sitzung wieder aufsetzen zu können,
muß der alte Zustand wieder hergestellt werden. Mit [[RunAll]]
werden alle Start- und Stern-Chunk aktiviert.
Dazu wird an den bestehenden Report ein neuer Code-Chunk mit dem Namen
[[RunAllStartsAndStars]] angefügt, der nur aus der Verwendung der
Start- und Sternmodule besteht. Dieser neue Chunk wird aktiviert und
zum Schluß wieder entfernt.
<<definiere Kopf-Zeilen-Funktionen>>=
RunAll<-function(){
  melde("RunAll",1)
  news<-paste("RunAll:",date(),"\n")
  <<schreibe [[news]] ans Ende des Outputfeldes>>
  news<-paste("\n@\n@<<RunAllStartsAndStars>>=\n@<<start>>\n@<<*>>\n@")
  <<schreibe [[news]] ans Ende des Arbeitstextes>>
  tkmark.set(tworkwin,"insert","end")
  fEvalRCode()
  <<lese Arbeitsfenster auf [[worktext]] ein>>
  h<-grep("RunAllStartsAndStars",worktext)
  if(0<length(h)) worktext<-worktext[1:(h[1]-2)]
  <<schreibe [[worktext]] ins Arbeitsfenster>>
  melde("RunAll",2)
}

@
<<definiere Kopf-Zeilen-Funktionen>>=
RunStart<-function(){
  melde("RunStart",1)
  news<-paste("RunStart:",date(),"\n")
  <<schreibe [[news]] ans Ende des Outputfeldes>>
  news<-paste("\n@\n@<<RunStarts>>=\n@<<start>>\n@")
  <<schreibe [[news]] ans Ende des Arbeitstextes>>
  tkmark.set(tworkwin,"insert","end")
  fEvalRCode()
  <<lese Arbeitsfenster auf [[worktext]] ein>>
  h<-grep("RunStart",worktext)
  if(0<length(h)) worktext<-worktext[1:(h[1]-2)]
  <<schreibe [[worktext]] ins Arbeitsfenster>>
  melde("RunStart",2)
}

@
\subsubsection{Kopfzeile: [[Edit]] --- [[DeleteAll]]}
\paragraph{[[DeleteAll]] zur Entfernung aller Inhalte aus dem Reportfenster.}
<<definiere Kopf-Zeilen-Funktionen>>=
DeleteAll<-function(){
  melde("DeleteAll",1)
  <<sichere letzten Zustand unter [[report-UnDo-bak.rev]]>>
  worktext<-paste("% New Report:",date(),"\n")
  <<schreibe [[worktext]] ins Arbeitsfenster>>
  melde("DeleteAll",2)
}

@
\subsubsection{Kopfzeile: [[Edit]] --- [[UnDo]]}
\paragraph{[[UnDo]] zur Restauration des Reportfensterzustands vor der
letzten Code-Aktivierung.}
<<definiere Kopf-Zeilen-Funktionen>>=
UnDo<-function(){
  melde("UnDo",1)
  if(file.exists("report-UnDo-bak.rev")){
    worktext<-myscan(file="report-UnDo-bak.rev",
                     what="",sep="\n",blank.lines.skip=FALSE)
    <<schreibe [[worktext]] ins Arbeitsfenster>>
  }else{
    cat("ERROR: file report-UnDo-bak.rev not found!!!\n")
  }
  melde("UnDo",2)
}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



@
\subsubsection{Reportoperationen --- der lokale {\sc Tangle}-Prozeß}

An dieser Stelle wird der schon in der Definition von [[fEvalRCode]]
verwendete {\sc Tangle}-Prozeß definiert.
Besonders in Reports schafft eine Wiederverwertung gegenüber einfachem
Kopieren Übersicht.
Der Quelltext befindet sich auf [[worktext]], expandiert werden muß der
aktuelle Code-Chunk. Das Ergebnis muß auf [[code]] abgelegt werden.
Vorher steht dort gerade der aktuelle Code-Chunk.
<<tangle ggf.\ aktuellen Chunk von [[worktext]], Ergebnis: [[code]]>>=
melde("vor tangle - Code:\n",3,code)
if(length(grep("@<<(.*)>>",code))>0 || length(grep(">#",code))>0){
  <<bereite Inhalt des Inputs auf>>
  <<initialisiere Variable für Output>>
  <<ermittle Namen und Bereiche der Code-Chunks>>
  melde("vor expand - Code:\n",3,code)
  <<expandiere aktuellen Code-Chunk>>
  <<korrigiere ursprünglich mit @ versehene Zeichengruppen>>
  <<liefere [[code]] ab>>
  melde("nach expand\n",3,code)
}

@
\paragraph{Aufbereitung des Inputs.}
Aus dem Input werden Text-Chunks entfernt und
Definitions- und Verwendungszeilen gekennzeichnet.
<<bereite Inhalt des Inputs auf>>=
<<entferne Text-Chunks>>
<<substituiere mit @ versehene Zeichengruppen>>
<<stelle Typ der Zeilen fest>>

@
[[code.ch]] enthält die isolierten Code-Chunks.
[[code.n]] zeigt die aktuelle Zeilenzahl von [[code.ch]] an.
Text-Chunks beginnen mit einem [[@]], Code-Chunks enden mit der
Zeichenfolge [[>]][[>=]]. Es werden
die Nummern der ersten Zeilen der Code-Chunks auf [[code.a]] abgelegt.
[[code.z]] zeigt den Beginn von Text-Chunks an, weiter unten wird diese
Variable die letzten Zeilen eines Code-Chunk anzeigen.
Aus der Kumulation des logischen Vektor [[change]],
der die Übergänge hält, lassen sich schnell die Bereiche der
Text-Chunks ermitteln.
<<entferne Text-Chunks>>=
code.a    <- grep("^@<<(.*)>>=",worktext)
code.z    <- grep("^@",worktext)
code.z    <- unlist(sapply(code.a ,function(x,y) y[y>x][1], code.z))
if(any(h<-is.na(code.z))) code.z<-code.z[!h]
code.n    <- length(worktext)
change    <- rep(0,code.n); change[c(code.a ,code.z)]<-1
code.ch   <- worktext[1==(cumsum(change)%%2)]
code.n    <- length(code.ch)

@
<<substituiere mit @ versehene Zeichengruppen>>=
code.ch<-gsub("@@>>","DoSpCloseKl-esc",gsub("@@<<","DoSpOpenKl-esc",code.ch))

@
In dieser Implementation dürfen
vor der Verwendung von Verfeinerungen Anweisungsteile stehen,
ebenso dahinter. Deshalb werden die Zeilen, die [[<<]] enthalten,
aufgebrochen.
Sodann werden die Orte der Definitionen von Code-Chunks
und der Verwendungen festgestellt.
Auf der Variable [[line.typ]] wird
die Qualität der Zeilen von [[code.ch]] anzeigt: [[D]] steht für
Definition, [[U]] für Verwendungen, [[C]] für normalen Code-Zeilen
und [[E]] für externe Verweise.
[[code.ext]] zeigt externe Code-Chunks an.
<<stelle Typ der Zeilen fest>>=
<<knacke ggf.\ Zeilen mit mehrfachen Chunk-Uses>>
line.typ  <-rep("C",code.n)
code.a    <-grep("cOdEdEf",code.ch)
code.ch[code.a]<-substring(code.ch[code.a],8)
line.typ[code.a]<-"D"
code.use    <-grep("uSeChUnK",code.ch)
code.ch[code.use]<-substring(code.ch[code.use],9)
line.typ[code.use]<-"U"
code.ext  <-grep("#<file",code.ch)
line.typ[code.ext]<-"E"
melde("code.ch:",3,code.ch,"\n")
@
<<knacke ggf.\ Zeilen mit mehrfachen Chunk-Uses>>=
code.ch<-gsub("(.*)@<<(.*)>>=(.*)","cOdEdEf\\2",code.ch)
repeat{
  if(0==length(cand<-grep("@<<(.*)>>",code.ch))) break
  code.ch<-unlist(strsplit(gsub("(.*)@<<(.*)>>(.*)",
             "\\1bReAkuSeChUnK\\2bReAk\\3",code.ch),"bReAk"))
}
code.ch<-code.ch[code.ch!=""]
code.n<-length(code.ch)
melde("code.ch:",3,code.ch,"\n")

@
<<old: stelle Typ der Zeilen fest>>=
code.use  <-grep("@<<.*>>[^=]",code.ch)
if(0<length(code.use<-grep("@<<.*>>[^=]",code.ch))){
   code.ch[code.use]<- sub(">>",">>>>\n",code.ch[code.use])
   code.ch<-unlist(strsplit(code.ch,">>\n"))
}
code.ch <- gsub("<<-","BiG<-GiB",code.ch)
code.ch <- unlist(strsplit(code.ch,"<<"))
code.ch <- gsub("BiG<-GiB","<<-",code.ch)
code.n    <-length(code.ch)
code.a    <-grep(">>=",code.ch); code.use <-grep(">>",code.ch)

code.use  <-code.use[is.na(match(code.use,code.a))]
code.ext  <-grep("#<file",code.ch)
line.typ  <-rep("C",code.n)
line.typ[code.a]<-"D"; line.typ[code.use]<-"U"; line.typ[code.ext]<-"E"

@
\paragraph{Ermittlung der Code-Chunks.}
Zur Erleichterung für spätere Manipulationen werden in den Bezeichnern die
Zeichenketten [[<<]], [[>>]] und [[>>=]] entfernt.
Die Zeilennummern der Anfänge von Code-Chunks bezüglich [[code.ch]]
stehen auf [[code.a]], die Enden auf [[code.z]].
<<ermittle Namen und Bereiche der Code-Chunks>>=
def.names<-code.ch[code.a]
use.names<- if(length(code.use)>0) code.ch[code.use] else NULL
code.z<-c(if(length(code.a)>1) code.a[-1]-1, code.n)
code.ch<-paste(line.typ,code.ch,sep="")
melde("code.ch:",3,code.ch,"\n")

@
<<old: ermittle Namen und Bereiche der Code-Chunks>>=
code.ch[code.a]  <- unlist(lapply(strsplit(code.ch[code.a],">>="),"[",1))
def.names        <- substring(code.ch[code.a],2)
if(length(code.use)>0){
  code.ch[code.use]<- unlist(lapply(strsplit(code.ch[code.use],">>"),"[",1))
  use.names        <-substring(code.ch[code.use],2)
} else { use.names <- NULL }
code.z             <-c(if(length(code.a)>1) code.a[-1]-1, code.n)

@
\paragraph{Initialisierung des Outputs.}
Auf [[code.out]] werden die fertiggestellten Code-Zeilen abgelegt.
Diese Variable muß initialisiert werden.
<<initialisiere Variable für Output>>=
code.out<-"##act:##"

@
\paragraph{Expansion des aktuellen Code-Chunk.}
Es gilt, den letzten Code-Chunk zu expandieren.
Dazu wird der aktuelle Chunk gesucht und auf dem
Zwischenspeicher [[code.stack]] abgelegt.
Dann werden normale Code-Zeilen
auf die Output-Variablen übertragen, und Verfeinerungsverwendungen werden
auf [[code.stack]] durch ihre Definitionen ersetzt.
<<expandiere aktuellen Code-Chunk>>=
melde("bearbeite aktuellen Chunk\n",3)
<<bestimme Cursorzeile [[line]] von [[tworkwin]]>>
ch.no<-length(grep("^@<<(.*)>>=",worktext[1:line]))
rows      <-c((code.a[ch.no]+1),code.z[ch.no])
if(all(!is.na(rows))&&rows[1]<=rows[2]){
  rows<-rows[1]:rows[2]
  code.stack<-code.ch[rows]
  repeat{
     <<transferiere Zeilen oder ersetze Verfeinerungen bis Ende erreicht>>
  }
}
if(length(code.ext)>0){
  <<expandiere externe Verfeinerungen>>
}
code.out<-c(code.out,"##:act##")

@
Falls [[code.stack]] leer ist, ist nichts mehr zu tun. Andernfalls
wird die Anzahl der aufeinanderfolgenden Codezeilen festgestellt
und auf die Output-Variable übertragen. Falls die nächste keine
Codezeile ist, muß es sich um die Verwendung einer Verfeinerung handeln.
In einem solchen Fall wird die nächste Verfeinerung
identifiziert und der Bezeichner der Verfeinerung wird durch seine Definition
ersetzt.
<<transferiere Zeilen oder ersetze Verfeinerungen bis Ende erreicht>>=
if(0==length(code.stack))break
typ<-substring(code.stack[1],1,1)
if("C"==typ||"E"==typ){
  n.lines<-sum(cumprod("C"==substring(code.stack,1,1)))
  code.out<-c(code.out, substring(code.stack[1:n.lines],2))
  code.stack<-code.stack[-(1:n.lines)]
}
if(length(code.stack)>0 && "U"==substring(code.stack[1],1,1)){
  if(any(found<-def.names==substring(code.stack[1],2))){
    found<-seq(along=def.names)[found]; rows<-NULL
    for(no in found){
      if((code.a[no]+1)<=code.z[no]) rows<-c(rows,(code.a[no]+1):code.z[no])
    }
    code.stack<-c(code.ch[rows],code.stack[-1])
    melde("found",0,found)
  }else{code.stack<-code.stack[-1]}
}

@
<<expandiere externe Verfeinerungen>>=
code.out<-code.out[code.out!=""]
code.ext<-rev(grep(">#",code.out))
found<-TRUE
repeat{
  <<beende Schleife, falls keine externen Verfeinerungen zu finden>>
  <<gehe im Fehlerfall zur nächsten externen Verfeinerung>>
  found<-TRUE
  <<ermittle Dateinamen und Chunkbeschreibung>>
  <<falls Chunkbeschreibung ein Name, suche Chunknummer>>
  <<lese Datei mit Code-Chunks>>
  <<extrahiere externen Code>>
  <<lege Code auf Ergebnisvariablen ab>>
  <<gehe zur nächsten externen Verfeinerung>>
}

@
<<beende Schleife, falls keine externen Verfeinerungen zu finden>>=
if(length(code.ext)==0) break

@
Falls die Suche ergebnislos verläuft --- dieses führt (s.u.) in einem
Schleifendurchgang zur Anweisung [[next]] und damit zum folgenden
Code-Chunk ---, wird eine Fehlermeldung ausgegeben. Trotzdem wird
die Weiterverarbeitung fortgesetzt, auch wenn dies oft nicht mehr
sinnvoll sein dürfte.
<<gehe im Fehlerfall zur nächsten externen Verfeinerung>>=
if(!found){
  code.out[code.ext[1]]<-paste("# ??",code.out[code.ext[1]])
  cat("ERROR: External Chunk",code.out[code.ext[1]],"not found!!!\n")
  code.ext<-code.ext[-1]
}

@
Für den Zugriff auf den externen Code wird der Dateiname [[ext.name]]
ohne Endung und die Bezeichnung des Chunk [[ext.chunk]] festgestellt.
<<ermittle Dateinamen und Chunkbeschreibung>>=
ext.name <- rev(unlist(strsplit(code.out[code.ext[1]],"#<file:")))[1]
ext.name <- unlist(strsplit(unlist(strsplit(ext.name,">#"))[1],":"))
ext.chunk<-ext.name[2]; ext.name <-ext.name[1]
ext.name.n<-nchar(ext.name)
if(ext.name.n >4 && ".rev"==substring(ext.name,ext.name.n-3,ext.name.n)){
  ext.name<-substring(ext.name,1,ext.name.n-4)
}

@
Ein externer Code-Chunk kann
durch einen Namen oder eine Chunknummer beschrieben
sein. Im Falle eines Namens wird der [[*.rev]]-File gelesen und aus diesem
die Nummer ermittelt.
<<falls Chunkbeschreibung ein Name, suche Chunknummer>>=
if(is.na(as.numeric(ext.chunk))){
  # tld untersuchen
  filename<-paste(ext.name[1],".rev",sep="")
  if(!file.exists(filename)){
    cat("ERROR: file",filename,"for expansion of code chunk not found!!!\n")
    ext.file<-"Error"
  }else{
    ext.file<-try(myscan(file=filename),what="",sep="\n")
  }
  if("Error"==substring(unlist(ext.file)[1],1,5)){
    found <-FALSE; next
  }
  ext.file <-ext.file[grep("^@<<(.*)>>=",ext.file)]
  if(!is.null(ext.file)){ found<-FALSE; next }
  ext.chunk<-grep(ext.chunk,ext.file)
}

@
Die [[*.R]]-Datei wird gelesen ...
<<lese Datei mit Code-Chunks>>=
filename<-paste(ext.name[1],".R",sep="")
if(!file.exists(filename)){
  cat("Warning: file",filename,"not found!!!\n")
  cat("         file",filename,"is now generated!!!\n")
  try(tangleR(ext.name[1]))
}
if(!file.exists(filename)){
  ext.file<-"Error"
}else{
  ext.file<-try(myscan(file=filename,what="",sep="\n"))
}
if("Error"==substring(unlist(ext.file)[1],1,5)){
  found <-FALSE; next
}

@
%%%%%%%%%%%%%%%%  aus rw.rev uebernommen -- notwendig ANFANG
<<unused: generiere zur Datei [[filename]] zugehörige [[R]]-Datei>>=
melde(paste(filename,"nicht gefunden!"),3)
worktext<-REVFILE
if(length(grep("^@<<(.*)>>=",worktext))>0){
  <<entferne Text-Chunks>>
  <<trage Sektionsnummernverweise ein>>
  <<stelle Typ der Zeilen fest>>
  code.out<-NULL
  <<ermittle Namen und Bereiche der Code-Chunks>>
}
melde("bearbeite aktuellen Chunk\n",3)
code.stack<-c("Ustart","U*")
repeat{
  <<transferiere Zeilen oder ersetze Verfeinerungen bis Ende erreicht>>
}
<<schreibe [[code.out]] nach Endbehandlung als [[filename]] weg>>

@
Die gefundenen Definitionszeilen werden um die Kommentare, abgegrenzt durch
Newline-Zeichen, verlängert. Eine Datei-Schreibe-Lese-Operation wertet
die Trennzeichen aus.
<<unused: trage Sektionsnummernverweise ein>>=
sec.z<- grep(">>=",code.ch); sec.z.start<-grep("@<<start>>=",code.ch)
sec.no<-seq(along=sec.z);    sec.no[!is.na(match(sec.z,sec.z.start))]<-0
if(0<length(sec.z)){
  h<-c(sec.z[-1]-1,length(code.ch))
  code.ch[sec.z]<-paste(code.ch[sec.z],"\n#", sec.no,":\n",sep="")
  code.ch[h    ]<-paste(code.ch[h    ],"\n#:",sec.no,"\n", sep="")
}
cat(code.ch,sep="\n",file=<<tmp>>)
code.ch<-myscan(file=<<tmp>>,what="",sep="\n")

@
Ist das Startmodul auf mehrere Code-Chunks verteilt, müssen
überflüssige ([[#0:]], [[#:=]])-Paare entfernt werden. Gleiches gilt für
Zeilen der Form (Leerzeichen, Zahl, [[:]], Leerzeichen), die bei dem
lokalen Tangle-Prozeß entstehen.
<<unused: schreibe [[code.out]] nach Endbehandlung als [[filename]] weg>>=
no<-grep("#0:",code.out)
if(1<length(no)){
  no<-no[-1]
  code.out<-code.out[-c(no,rev(grep("#:0$",code.out))[-1])]
}
no<-grep(": $",code.out)
if(0<length(no)){
  code.out<-code.out[-no]
}
try(cat(code.out,sep="\n",file=filename))

@
%%%%%%%%%%%%%%%%  aus rw.rev uebernommen -- notwendig ENDE

@
... und der gesuchte Code extrahiert.
<<extrahiere externen Code>>=
ext.chunk<-as.numeric(ext.chunk)
a        <-grep(paste("#", ext.chunk,":",sep=""),ext.file)[1]
z        <-grep(paste("#:",ext.chunk,    sep=""),ext.file)[1]
if(is.na(a)){
  found <- FALSE; next
}
if(a<=z) ext.file <-ext.file[a:z]

@
Der gefundene Code wird auf der Ergebnisvariablen [[code.out]] abgelegt.
<<lege Code auf Ergebnisvariablen ab>>=
code.out <-c(code.out[1:(code.ext[1]-1)], ext.file,
             if(length(code.out)>(code.ext[1]+1))
               code.out[(code.ext[1]+1):length(code.out)]
           )

@
Nachdem der externe Link abgearbeitet ist, kann der Stapel der externen
Verweise [[code.ext]] verkürzt werden.
<<gehe zur nächsten externen Verfeinerung>>=
code.ext<-code.ext[-1]

@
<<korrigiere ursprünglich mit @ versehene Zeichengruppen>>=
code.out<-gsub("DoSpCloseKl-esc",">>",gsub("DoSpOpenKl-esc","<<",code.out))

@
Gemäß den Vorgaben wird der Code zum Schluß auf [[code]] abgelegt.
<<liefere [[code]] ab>>=
melde("Ende Rtangle-last\n",3)
code<-code.out[code.out!=""]
@
%%%%% end of tangling ch.no %%%+++%%%%%

%%%%%%%% hier war vorher der Paperteil !!!!!!!!!!!!!!!!!


@
\section{Dialogorientiertes Arbeiten}
Für Tutorials und andere speziell ausgerichtete wiederbelebbare Papiere
müssen noch einige Spezialitäten implementiert werden: Zum Beispiel gibt es
Papiere mit Dialogelementen. Hierzu werden in der Regel die Funktionen
[[readline]], [[scan]], [[cat]], [[print]] und [[menu]] verwendet.
Damit der hier präsentierte Vorschlag Dialoge innerhalb der eigenen Fensterwelt
abhandeln kann, müssen die genannten Funktionen durch neue
überlagert werden. Zum zweiten unterstellen einige Papiere, daß
Verarbeitungsanweisungen auch über die Variable [[cmds]]
abgesetzt werden können.
Als drittes ist ein Mechanismus nett, mit dem ein Anwender bzw.\ ein
Papier im Kopf\-frame ein eigenes Menü unterbringen kann. Als Beispiel
und als Defaultsetzung wird hier ein völlig rudimentärer Vorschlag
einer Daten- und Funktionsverwaltung für den Anfänger definiert.
Für Unterbrechungen wird die Funktion [[.Return]] geschaffen, mit der
die Abarbeitung erst nach Druck der Taste {\sc Return} vorangeht.
Zum Abschluß wird noch eine Funktion zur Umsetzung von Umlauten
definiert.

@
\subsection{Die Umsetzung von Anweisungen über [[cmds]]}
Die Funktion [[Execute.cmds]] führt die Kommandos: [[s]], [[q]], [[>]],
[[i]] und [[r]] sowie einige andere Dinge aus.
Diese müssen sich in der Umgebung des Anwenders auf [[cmds]] befinden.
Der Mechanismus läuft so: Nach bestimmten Aktionen, nämlich am Ende von
[[fEvalRCode]] und am Ende der Initialisierung
von [[relax]], wird das virtuelles Ereignis [[@<<Acticmds>>]] ausgelöst.
Mit diesem Ereignis ist die Funktion [[Execute.cmds]] verbunden,
die dann [[cmds]] analysiert und die dort abgespeicherten Befehle
abarbeitet.
@
<<definiere Bindung zur Abarbeitung von [[cmds]]>>=
Execute.cmds<-function(){
  melde("Execute.cmds",1)
  res<-ls(pattern="^cmds$",envir=revive.env)
  if(length(res)>0){
    cmds<-try(eval(parse(text="cmds"),envir=revive.env))
    if(length(cmds)>0){
      eval(parse(text="cmds<-NULL"),envir=revive.env)
      #repeat{
        <<aktiviere die auf [[cmds]] abgelegten Kommandos>>
      #}
    } else remove(list="cmds",envir=revive.env)
  }
  melde("Execute.cmds",2)
}
tkbind(TopW, "@<<Acticmds>>", Execute.cmds)

@
<<aktiviere die auf [[cmds]] abgelegten Kommandos>>=
melde("beginn repeat",1)
if(length(cmds) == 0) break
cmd <- substring(cmds[1],1,1); choice<-substring(cmds[1],2)
cmds<-cmds[-1]; assign("cmds",cmds,env=revive.env)
switch(cmd
  ,"s" = {
           <<lese Arbeitsfenster auf [[worktext]] ein>>
           line<-grep("^@<<(.*)>>=",worktext)
           if(class(try(no<-line[as.numeric(choice)]))!="try-error" && !is.na(no)){
	     line<-paste(no[1],"0",sep=".")
	     tkmark.set(tworkwin,"insert",line);fEvalRCode()
	     tksee(tworkwin,"end")
	   }
          }
  ,"q" = { Exit() }
  ,">" = {
          news<-paste("\n@\n@<<*>>=\n",choice,"",sep="")
          <<schreibe [[news]] ans Ende des Arbeitstextes>>
           tkmark.set(tworkwin,"insert","end");fEvalRCode()
	   tksee(tworkwin,"end")
	 }
  ,"p" = {
          psname <- choice
          <<lege Bild unter [[bildname]] ab>>
         }
  ,"r" = {
          choice<-gsub(" ","",choice)
          if(!file.exists(choice)){
            cat("ERROR:",choice,"not found!!!\n")
            ok<-FALSE
          }else{
            try.res<-try(myscan(choice,"",sep="\n"))
            <<lege auf [[ok]] ab, ob [[try.res]] Fehler zeigt>>
          }
          if(ok){
            worktext<-paste(try.res, collapse="\n")
            <<schreibe [[worktext]] ins Arbeitsfenster>>
            filename<-choice
            assign("workname.sys",filename,env=revive.sys)
            <<aktualisiere Reportname>>
            melde(paste("r", filename), "cmd.msg")
	    Execute.cmds()
	  } else { cat("ERROR: file not found!!!\n") }
         }
)

@
<<generiere ein Ereignis zur Abarbeitung von [[cmds]]>>=
melde("event wird generiert",3)
tkevent.generate(TopW,"@<<Acticmds>>")

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Die Überlagerung von Input- und Outputfunktionen}
Wird während der Arbeit mit dem Manager eine Eingabe verlangt, ist der
sicherste Weg, dem Anwender ein kleines Fenster zur Eingabe anzuzeigen.
Eine Eingabeauf\-forderung in dem normalen R-Fenster dürfte verwirren,
da das R-Fenster irgendwo im Hintergrund verborgen sein kann.
Entsprechendes gilt für die Ausgabefunktionen.
Deshalb werden in diesem Abschnitt Funktionen bereitgestellt, die
denselben Namen besitzen wie ihre R-Gegenstücke.
Damit diese Ersatzfunktionen auch wirksam werden, werden sie in
die Umgebung kopiert, in der sich auch die Evaluation der Anwenderanweisungen
zuträgt.

@
\subsubsection{Die Überlagerung von [[readline]]}
Die neue [[readline]]-Funktion soll ein neues kleines Fenster öffnen
und in diesem eine Eingabe verlangen. Über das formale Argument
läßt sich ein kleiner Text als Titel verwenden.
Das Eingabe-Widget wird in ein neues Top-Level-Fenster gepackt.
Als Wirkung für einen {\sc Return}-Druck wird der Fokus neu gesetzt
das Fenster gelöscht, woraufhin [[tkwait.window]]
die weitere Auswertung der Funktion freigibt. Im Rahmen dieser
Beendigungsarbeiten wird ein Vermerk über die Eingabe ins Arbeitsfenster
geschrieben und der Index des gewählten Item ausgegeben.
<<definiere Input/Output-Funktionen neu>>=
readline<-function(prompt=""){
  if(! (<<teste, ob [[relax]] aktiv ist>>) ){
    readline<-get("readline", pos="package:base")
    return(readline(prompt=prompt))
  }
  .newl<-tktoplevel()
  tkwm.title(.newl, "text input"); tkwm.geometry(.newl,"+0+0")
  <<schreibe letzte Ausgabe als Info in Widget [[.newl]]>>
  eline<-tkentry(.newl,textvariable="tvreadline")
  set.tclvalue("tvreadline","")
  lline<-tklabel(.newl,text=prompt)
  tkpack(eline, lline, side="right");         tkfocus(eline)
  twin<-eline; <<stelle besondere Zeichen in [[twin]] zur Verfügung>>
  <<hole ggf. [[tworkwin]]>>
  tkbind(.newl,"<Return>",function(){tkfocus(tworkwin);tkdestroy(.newl)})
  tkwait.window(.newl)
  news<-paste("\nreadline Input:\n", (out<-tclvalue("tvreadline")))
  <<schreibe [[news]] ans Outputfeld ([[relax]]) oder ans Arbeitsfeld>>
  return(out)
}
assign("readline",readline,pos=<<stelle Nummer von [[relax]] im Suchpfad fest>>)
melde("readline saved",3)

@
<<schreibe letzte Ausgabe als Info in Widget [[.newl]]>>=
if(exists("running.function") && running.function==<<relax>>){
  <<schreibe Inhalt von [[toutwin]] als Info in ein Message-Widget unter [[.newl]]>>
}else{
  <<schreibe letzte Ausgabe als Info in ein Message-Widget unter [[.newl]]>>
}


@
Zur Information ist es hilfreich, wenn die letzten Dialogfragmente in
dem Widget zur Eingabe eingeblendet werden.
<<schreibe letzte Ausgabe als Info in ein Message-Widget unter [[.newl]]>>=
tkpack(minfo<-tkmessage(.newl,width="1000",justify="left",relief="raised"))
<<lese Arbeitsfenster auf [[worktext]] ein>>
worktext<-worktext[worktext!=""]
line<-rev(grep("^@<<(.*)>>=",worktext))[1]
if(!is.na(line)&length(line)>0) worktext<-worktext[-(1:line)]
line<-grep("^@",worktext)[1]
if(!is.na(line)&length(line)>0) worktext<-worktext[-(1:line)]
if(length(h<-grep("^output", worktext))>0) worktext<-worktext[-h]
if(length(h<-grep("^@", worktext))>0)      worktext<-worktext[-h]
if(length(h<-grep("verbatim",worktext))>0) worktext<-worktext[-h]
if(length(worktext)>0){
  worktext<-rev(rev(worktext)[1:min(20,length(worktext))])
  worktext<-paste(worktext,collapse="\n")
  tkconfigure(minfo,text=worktext)
}

@
<<hole ggf. [[toutwin]]>>=
if(!exists("toutwin"))
  toutwin<-get("toutwin",envir=get("revive.sys",envir=revive.env))

@
<<hole ggf. [[tworkwin]]>>=
if(!exists("tworkwin"))
  tworkwin<-get("tworkwin",envir=get("revive.sys",envir=revive.env))

@
<<schreibe Inhalt von [[toutwin]] als Info in ein Message-Widget unter [[.newl]]>>=
tkpack(minfo<-tkmessage(.newl,width="1000",justify="left",relief="raised"))
<<hole ggf. [[toutwin]]>>
news<-strsplit(tclvalue(tkget(toutwin,"0.0","end")),"\n")[[1]]
if(length(news)>10) news<-rev(rev(news)[1:10])
if(length(h<-grep("^output", news))>0) news<-news[-h]
if(length(h<-grep("^@", news))>0)      news<-news[-h]
if(length(h<-grep("verbatim",news))>0) news<-news[-h]
if(length(news)>0){
  news<-rev(rev(news)[1:min(20,length(news))])
  news<-paste(news,collapse="\n")
  tkconfigure(minfo,text=news)
}

@
\subsubsection{Die Überlagerung von [[menu]]}
Für eine Auswahl mit der Funktion [[menu]] werden in einem neuen
Top-Level-Fenster mit mitgegebenem Titel die Auswahlpunkte als Elemente
eines [[listbox]]-Widgets zur Auswahl angeboten. Der Menüpunkt [[Exit]]
wird der Liste der Alternativen hinzugefügt. Ein {\sc Return}-Druck schreibt
das Menü und die Auswahlentscheidung ins Arbeitsfenster.
Die Nummer des gewählten Menüpunktes wird wie bei [[menu]] ausgegeben.

@
Aus Sicherheitsgründen: [[revive.sys]] erst holen, dann benutzen.

@
Neueste Erkenntnis: auch unter Windows muss [[tkwait.variable]]
verwendet werden!

<<definiere Input/Output-Funktionen alt>>=
menu<-function(choices, graphics=FALSE, title=""){
  if(! (<<teste, ob [[relax]] aktiv ist>>) ){
    menu<-get("menu", pos="package:base")
    return(menu(choices=choices,graphics=graphics,title=title))
  }else{
    TopN<-tktoplevel()
    tkwm.geometry(TopN,"+0+0"); if(title!="")tkwm.title(TopN, title)
    nc<-length(choices<- c(choices, "EXIT"))
    mch<-max(chars<-nchar(choices)); leer<-paste(rep(" ",mch),collapse="")
    choices<-paste(choices, substring(leer,1,mch-chars) )
    escape.brace<-function(text){text<-gsub("\\\\","\\\\\\\\}",text)
      text<-gsub("\\{","\\\\{",text);text<-gsub("\\}","\\\\}",text);text
    }
    choices<-as.character(escape.brace(choices))
    bw<-as.character(max(mch,10+nchar(title)))
    for(item in choices) {
      tkpack(tkradiobutton(TopN,width=bw,anchor="sw",
                           text=item,variable="tvchoice",value=item))
    }
    tkwait.variable("tvchoice")
    ind <- match(tclvalue("tvchoice"), choices)
    choice <- if(ind==nc) "0" else ind
    news<-paste("",
                   paste(paste(c(1:(nc-1),"0"),choices,sep=":"),collapse="\n"),
                   "\nSelection: ",choice, "",sep="")
    <<schreibe [[news]] ans Outputfeld ([[relax]]) oder ans Arbeitsfeld>>
    tkfocus(get("tworkwin",env=get("revive.sys",env=revive.env))) # wichtig!!
    tkdestroy(TopN)
    return(as.numeric(choice))
  }
}
assign("menu",menu,pos=<<stelle Nummer von [[relax]] im Suchpfad fest>>)
melde("menu saved",3)

@
050518: Menu.Funktion um Schieber erweitert. 
<<definiere Input/Output-Funktionen neu>>=
menu<-function(choices, graphics=FALSE, title=""){
 if(! (<<teste, ob [[relax]] aktiv ist>>) ){
    menu<-get("menu", pos="package:base")
    return(menu(choices=choices,graphics=graphics,title=title))
 }else{
  TopN<-tktoplevel()
  if(title=="") title<-"select item, press Return (or exit by Esc)"
  tkwm.geometry(TopN,"+0+0"); tkwm.title(TopN, title)
  if(missing(choices)||length(choices)==0) choices<-"relax"
  choices<-paste(seq(choices),": ",choices, sep="")
  nc<-length(choices<- c(choices, "EXIT"))
  scr <- tkscrollbar(TopN, command=function(...)tkyview(tl,...))
  tl<-tklistbox(TopN,height=min(30,length(choices)),width=60,
                selectmode="single",yscrollcommand=
                  function(...)tkset(scr,...),background="white")
  for(ch in choices) tkinsert(tl,"end",ch)
  tkpack(tl,side="left",expand="yes",fill="y")
  tkpack(scr,side="left",expand="yes",fill="y")
  set.tclvalue("choice","0"); tkbind(TopN,"<Escape>",function(){tkdestroy(TopN)})
  tkbind(TopN,"<Return>",function(){
     choice<-as.numeric(tkcurselection(tl))+1
     set.tclvalue("choice",choice); tkdestroy(TopN)
  })
  tkwait.window(TopN)
  choice<-tclvalue("choice")
  choice<- if(choice==length(choices)) 0 else as.numeric(choice)
  news<-paste("",paste(choices,collapse="\n"),"\nSelection: ",choice, "",sep="")
  <<schreibe [[news]] ans Outputfeld ([[relax]]) oder ans Arbeitsfeld>>
  tkfocus(get("tworkwin",env=get("revive.sys",env=revive.env))) # wichtig!!
  return(choice)
 }
}
assign("menu",menu,pos=<<stelle Nummer von [[relax]] im Suchpfad fest>>)
melde("menu saved",3)

@
\subsubsection{Die Überlagerung von [[scan]]}
Die Funktion [[scan]] zu überlagern, scheint ein wenig schwieriger zu sein.
Deshalb soll zunächst einmal für den Manager ein ganz einfacher Vorschlag
gemacht werden, der nur die Eingabe von Zahlen oder Zeichenketten über
Tastatur unterstützt, nicht jedoch kompliziertere Strukturen.
<<definiere Input/Output-Funktionen neu>>=
scan<-function(file="",what=double(0),nmax=-1,n=-1,sep="",
               quote="",dec=".",skip=0,nlines=0,na.strings="NA",flush=FALSE,
               fill=FALSE,strip.white=FALSE,quiet=FALSE,blank.lines.skip=TRUE){
    <<definiere lokale [[scan]]-Funktion>>
    if(file!="" || ! (<<teste, ob [[relax]] aktiv ist>>) ){
      <<realisiere [[scan]] ohne [[tcl]]-Eingabe-Fenster>>
    } else {
      <<realisiere [[scan]] für [[relax]]>>
    }
    worktext
}
assign("scan",scan,pos=<<stelle Nummer von [[relax]] im Suchpfad fest>>)
melde("scan saved",3)

@
Beachte: [[scan]] ist versionsabhängig! Ebenso: [[local.scan]]
<<definiere lokale [[scan]]-Funktion>>=
scan<-get("scan",pos="package:base")

@
<<realisiere [[scan]] ohne [[tcl]]-Eingabe-Fenster>>=
  if(!missing(n))
    worktext<-scan(file=file,what=what,n=n,sep=sep,quote=quote,dec=dec,
                 skip=skip,nlines=nlines,na.strings=na.strings,
                 flush=flush,fill=fill,strip.white=strip.white,quiet=quiet,
                 blank.lines.skip=blank.lines.skip)
  else
    worktext<-scan(file=file,what=what,nmax=nmax,sep=sep,quote=quote,dec=dec,
                 skip=skip,nlines=nlines,na.strings=na.strings,
                 flush=flush,fill=fill,strip.white=strip.white,quiet=quiet,
                 blank.lines.skip=blank.lines.skip)

@
<<realisiere [[scan]] für [[relax]]>>=
typ<-if(is.numeric(what)) "Zahlen-Eingabe" else "Text-Eingabe"
.newl<-tktoplevel(); tkwm.title(.newl, typ); tkwm.geometry(.newl,"+0+0")
revive.sys<-get("revive.sys",envir=revive.env)
assign(".newl",.newl,envir=revive.sys)
<<schreibe letzte Ausgabe als Info in Widget [[.newl]]>>
if(!missing(n)&&n==1){
  sp<-"10"; zei<-"1"
  tkbind(.newl,"<Return>",function() set.tclvalue("tvscandone",2))
}else{sp<-"50"; zei<-"3"}
tkbind(.newl,"<Return><Return>",function()set.tclvalue("tvscandone",2))
tscan<-tktext(.newl,width=sp,height=zei)
twin<-tscan; <<stelle besondere Zeichen in [[twin]] zur Verfügung>>
bexit<-tkbutton(.newl, text="Exit: end of input")
tkpack(tscan, bexit); tkfocus(tscan)
tkconfigure(bexit,command=function()set.tclvalue("tvscandone",2))
set.tclvalue("tvscandone",0); tkwait.variable("tvscandone")
worktext<-tclvalue(tkget(tscan,"0.0","end"))
<<hole ggf. [[tworkwin]]>>
tkfocus(tworkwin); tkdestroy(.newl)
<<verarbeite die [[scan]]-Eingabe>>

@
<<verarbeite die [[scan]]-Eingabe>>=
news<-paste("\nscan-Eingabe:\n",worktext,sep="")
<<schreibe [[news]] ans Outputfeld ([[relax]]) oder ans Arbeitsfeld>>
     worktext<-strsplit(worktext,"\n")[[1]]
worktext<-strsplit(paste(worktext,collapse=" ")," ")[[1]]
worktext<-worktext[worktext!=""]
if(typ=="Zahlen-Eingabe"){
  try.res<-try(as.numeric(worktext))
  <<lege auf [[ok]] ab, ob [[try.res]] Fehler zeigt>>
  if(ok) worktext<-try.res else NULL
}

@
\subsubsection{Die Bereitstellung von [[scan]] für eigene Zwecke}
Leider unterscheiden sich die [[scan]]-Funktionen der unterschiedlichen
R-Versionen.
Deshalb für interne Zwecke eine eigene verwendet.
<<definiere Input/Output-Funktionen neu>>=
# myscan<-get("scan",pos="package:base"); formals(myscan)$comment.char<-""
myscan<-function(file,what,sep="\n", blank.lines.skip=FALSE){ readLines(file) } #2.1.0

@
\subsubsection{Die Überlagerung von [[print]]}
Die neue [[print]]-Funktion enthält die Definition einer lokalen
[[print]]-Funktion, deren Body mit dem der [[print]]-Funktion von R
identisch ist. Diese lokale Funktion kommt mit den übergebenen
Parametern zur Anwendung, so daß im R-Fenster die normale Ausgabe erscheint.
Zusätzlich wird sie aufgerufen, um das Ausgegebene auch in der Datei
[[<<tmp>>]]q
abzulegen. Der Inhalt von [[<<tmp>>]] wird dann ins Arbeitsfenster übertragen.
<<definiere Input/Output-Funktionen neu>>=
print<-function(x, ...){ # 050614
  if( <<teste, ob [[relax]] aktiv ist>> ){
    sink(<<tmp.sink>>); base::print(x, ...); sink()
     news<-paste("", # date(),
                 paste(scan(file=<<tmp.sink>>,what="",sep="\n"),collapse="\n"),
                 "",sep="\n" )
    <<schreibe [[news]] ans Outputfeld ([[relax]]) oder ans Arbeitsfeld>>
  } else base::print(x, ...)
}
assign("print",print,pos=<<stelle Nummer von [[relax]] im Suchpfad fest>>)
melde("print saved",3)

@
<<print alte Version>>=
print<-function(x, ...){
  local.print<-function(x, ...){
    UseMethod("print")
  }
  local.print(x, ...)
  sink(<<tmp.sink>>); local.print(x, ...); sink()
  if( <<teste, ob [[relax]] aktiv ist>> ){
     news<-paste("", # date(),
                 paste(scan(file=<<tmp.sink>>,what="",sep="\n"),collapse="\n"),
                 "",sep="\n" )
    <<schreibe [[news]] ans Outputfeld ([[relax]]) oder ans Arbeitsfeld>>
  }
}
assign("print",print,pos=<<stelle Nummer von [[relax]] im Suchpfad fest>>)
melde("print saved",3)
@
\subsubsection{Die Überlagerung von [[cat]]}
Die Struktur von [[cat]] entspricht fast  der von
[[print]]. [[cat]] löste jedoch beim internen Tanglen Probleme aus,
so daß es angepaßt werden mußte.
<<definiere Input/Output-Funktionen neu>>=
cat<-function(...,file="",sep=" ",fill=FALSE,labels=NULL,append=FALSE){
  cat<-get("cat",pos="package:base")
  cat(...,file=file,sep=sep,fill=fill,labels=labels,append=append)
  if(file==""&& <<teste, ob [[relax]] aktiv ist>> ){
     cat(...,file=<<tmp>>,sep=sep,fill=fill,labels=labels,append=append)
     news<-paste("\n", # date(),
                 paste(scan(file=<<tmp>>,what="",sep="\n"),collapse="\n"),
                 "",sep="\n")
     <<schreibe [[news]] ans Outputfeld ([[relax]]) oder ans Arbeitsfeld>>
  }
}
assign("cat",cat,pos=<<stelle Nummer von [[relax]] im Suchpfad fest>>)
melde("cat saved",3)

@
<<stelle Nummer von [[relax]] im Suchpfad fest>>=
which(paste("package",<<relax>>,sep=":")==search())

@
<<schreibe [[news]] ans Outputfeld ([[relax]]) oder ans Arbeitsfeld>>=
if(exists("running.function") && running.function==<<relax>>){
       <<schreibe [[news]] ans Ende des Outputfeldes>>
}else{
       <<schreibe [[news]] ans Ende des Arbeitstextes>>
}

@
<<teste, ob [[relax]] aktiv ist>>=
any((h<-'tkwait.variable("tvexit")')==substring(sys.calls(),1,nchar(h))) ||
0 < length(grep("revive.env",as.character(sys.calls()) ) )

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

@
\subsection{[[myhead.menu]] --- zur Erstellung eines Anwendermenüs im
Kopf\-frame}

In diesem Abschnitt soll eine Funktion beschrieben werden, die einem
Autor eines wiederbelebbaren Papiers die Möglichkeit eröffnet, über
die Kopfzeile eigene Menüs zu erstellen.
Diese Funktion muß bei ihrem ersten Aufruf prüfen, ob bereits das verlangte
Menü vorhanden ist. Falls nicht sind einige Initialisierungsarbeiten zu
absolvieren. Andernfalls ist dem schon existierenden Menü ein
Menüeintrag hinzuzufügen. Durch Setzung der Option [[rm.menu]] auf [[T]]
wird das Menü wieder gelöscht. Die Nummer des Menüs wird über
[[menu.no]] transportiert. Nummer [[0]] ist für die vom System
bereitgestellten Funktionen vorgesehen.
<<definiere [[myhead.menu]]>>=
myhead.menu<-function(item="Test",code=function()cat("Menu-Test"),
                      title="Menue",rm.menu=FALSE,menu.no=1){
  set.tclvalue<-function(name,value)tclvalue(name)<-as.character(value)
  out.msg<-NULL
  menu.widget.name<-paste("mrtrevive",   menu.no,sep="")
  menu.item.name  <-paste("mmyhead.menu",menu.no,sep="")
  if(!exists("revive.sys")) revive.sys<-get("revive.sys",envir=revive.env)
  if( !( <<teste, ob ein [[myhead.menu]] Nummer [[menu.no]] installiert>> )){
    if( rm.menu==TRUE && menu.no!=0){
      tkmessageBox(title="Warnung", icon="warning",
                   message="Achtung:  kein Kopfmenue vorhanden")
      return("Error")
    }
    <<richte [[myhead.menu]] Nummer [[menu.no]] ein>>
  }
  if( rm.menu==TRUE ){
    <<entferne [[myhead.menu]] Nummer [[menu.no]]>>
  }else{
    <<erweitere [[myhead.menu]] Nummer [[menu.no]] um einen Eintrag>>
  }
  return(out.msg)
}
assign("myhead.menu",myhead.menu, pos=relax.pos)


@
<<entferne [[myhead.menu]] Nummer [[menu.no]]>>=
mrtrevive<-get(menu.widget.name,envir=revive.sys)
tkpack("forget",mrtrevive)
tkdestroy(mrtrevive)
remove(list=menu.widget.name,envir=revive.sys)
out.msg<-c(out.msg, paste("Menue im Kopf entfernt!"))

@
<<teste, ob ein [[myhead.menu]] Nummer [[menu.no]] installiert>>=
exists(menu.widget.name,envir=revive.sys)

@
<<richte [[myhead.menu]] Nummer [[menu.no]] ein>>=
fhead<-get("fhead",envir=revive.sys)
mrtrevive<-tkmenubutton(fhead,text=title,
                        font=<<Font für Knöpfe>>,
                        relief="flat", width=<<Knopfbreite>>)
assign(menu.widget.name,mrtrevive,envir=revive.sys)
tkbind(mrtrevive,"<Enter>",function() set.tclvalue("tvmess","R cmd menue"))
tkbind(mrtrevive,"<Leave>",<<relax-zeige-Funktion>>)
tkpack(mrtrevive,side="left")
mmyhead.menu<-tkmenu(mrtrevive)
assign(menu.item.name,mmyhead.menu,envir=revive.sys)
tkconfigure(mrtrevive, menu=get(menu.item.name,env=revive.sys))
out.msg<-c(out.msg, paste("Menue im Kopf eingerichtet!"))

@
<<erweitere [[myhead.menu]] Nummer [[menu.no]] um einen Eintrag>>=
item<-as.character(item[[1]])
mmyhead.menu<-get(menu.item.name,envir=revive.sys)
revive.env <- get("revive.env",envir=revive.sys)
if(is.function(code))  code<-deparse(body(code))
item.code<-function()eval(parse(text=code),envir=revive.env)
tkadd(mmyhead.menu, "command", label=item, command=item.code,
        font=<<Font für Knöpfe>>
)
out.msg<-c(out.msg, paste("Item",item,"im Kopfmenue eingerichtet!"))

@
\subsubsection{Ein Anwendungsbeispiel: Daten- und Funktionswahlunterstützung}

Gerade für den Anfänger ist es schwierig sich an Namen und Syntax von
R-Funktionen zu erinnern. Ähnliches gilt auch für den Fortgeschrittenen
in Bezug auf Datensätze. Ein kleines Werkzeug zur Unterstützung kann
für diese Probleme sehr nützlich sein.
In diesem Abschnitt soll die Entwicklung eines solchen unter
Einsatz der Funktion [[myhead.menu]] vorgeführt werden.
Dieses Menü erhält die Menü-Nummer [[0]].

Zunächst überlegen wir geeignete Funktionalitäten:
\begin{itemize}
\item
Das Instrument soll ein- und zwei-dimensionale Datensätze auf\-listen
\item
und jeweils für diese beiden Objekttypen Methoden anbieten.
\item
Entsprechend den Wünschen sollen dann im Arbeitfeld Eintragungen
angebracht werden, die der Anwender dann starten kann.
\end{itemize}
Damit können wir schon das Menü definieren:
<<definiere Data-Fns-Menü>>=
<<definiere Menüfunktionen>>
data.fns.menu<-function(){
  myhead.menu(rm.menu=TRUE, menu.no=0)
  # myhead.menu(item="load data via internet",code=loadwwwdata, menu.no=0)   # ok
  myhead.menu(item="1-dim data sets",code=get.dim.1.data,title="Data",menu.no=0)    # ok
  myhead.menu(item="1-dim random numbers",code=generate.1.data,menu.no=0) # ok
  myhead.menu(item="2-dim data sets",code=get.dim.2.data,menu.no=0)    # ok
  myhead.menu(item="delete NAs from vector x",code=removenafromvecx,menu.no=0)
  myhead.menu(item="delete NAs from matrix xy",code=removenafrommatxy,menu.no=0)
  myhead.menu(item="save col of matrix xy as x",code=choosecol,menu.no=0)
  myhead.menu(item="1-dim statistics",code=get.dim.1.stats,title="Methods",menu.no=1)   # ok
  myhead.menu(item="1-dim plots",code=get.dim.1.plots,title="Methods",menu.no=1)   # ok
  myhead.menu(item="2-dim methods",code=get.dim.2.methods,menu.no=1)   # ok
}

@
Das größere Problem ist offensichtlich, die Funktionen zu definieren.

@
\paragraph{[[loadwwwdata]].} Für diesen Job gibt es bereits eine
Funktion. [[GetWWWData]].
Für die Datenbeschaffung vom Server wird die Funktion
\begin{quote}
[[GetWWWData()]]
\end{quote}
bereitgestellt. Diese Funktion greift auch
auf dem WWW-Server unter [[~wolf]] auf das Verzeichnis

[[software/revweb/rtrevive/data]] zu.

In diesem Verzeichnis liegen die Objekte in der R-üblichen Form herum.
Datensätze haben einen Namen mit der Endung [[.R]] außerdem gibt
die Datei [[00Contents]] Auskunft über die Datensätze,
indem für jeden Datensatz ein Eintrag {\em (Name Kurzbeschreibung)}
zu finden ist. Für die Auswahl wird hier die Funktion
[[listboxmenu]] beigesteuert.
<<definiere Menüfunktionen>>=
loadwwwdata<-function(){
  GetWWWData<-function(){
    melde("GetWWWData",1)
    URL<-paste("http://www.wiwi.uni-bielefeld.de/~wolf",
               "software/revweb/rtrevive/data",sep="/")
    download.file(paste(URL,"00Contents",sep="/"),"r.tmp")
    choices<-scan(file="r.tmp","",sep="\n")
    <<definiere Funktion [[listboxmenu()]]>>
    choice<-listboxmenu(choices,"gefundene Datensaetze")
    if(0==choice) return() else choice<-sub(" .*$",".R",choices[choice])
    download.file(paste(URL,choice,sep="/"),"www.data.R")
    cmds<-scan(file="www.data.R","",sep="\n")
    ok<-try(eval(parse(text=cmds),envir=revive.env))
    cat("\"",sub(".R$","",choice),"\" geladen\n",sep="")
    melde("GetWWWData",2)
  }
  GetWWWData()
}

@
\paragraph{[[generate.1.dat]].}
<<definiere Menüfunktionen>>=
generate.1.data<-function(){
 (function(){
  DS<-c("sample(99)","sample(99,replace=T)","rnorm(99,mean=0,sd=1)","rexp(99)")
  <<liste [[DS]] in einem Menü auf, wähle Objekt [[choice]]>>
  cmd<-paste("x <-",choice)
  <<schreibe [[cmd]] ins Arbeitsfenster>>
 })()
}

@
<<definiere ggf.\ myscan>>=
if(!exists("myscan")) myscan<-get("myscan",env=revive.sys)


@
Hierfür haben wir zwei Code-Chunks zu definieren:
060517
<<liste [[DS]] in einem Menü auf, wähle Objekt [[choice]]>>=
<<definiere Funktion [[listboxmenu()]]>>
choice<-listboxmenu(DS,"Items:")
if(0==length(choice)||is.na(choice)||0==choice) return()
choice<-DS[choice]
<<definiere ggf.\ myscan>>

@
060517
<<schreibe [[cmd]] ins Arbeitsfenster>>=
<<lese Arbeitsfenster auf [[worktext]] ein>>
<<bestimme Cursorzeile [[line]] von [[tworkwin]]>>
last.text<-c(0,grep("^@",worktext)); last.text<-rev(last.text[last.text<=line])[1]
last.code<-grep("^@<<(.*)>>=",worktext)
if(0<length(last.code)){
  last.code<-rev(last.code[last.code<=line])[1]
  if(is.na(last.code)||last.code<last.text)
            {delta<-4; news<-paste("\n@\n@<<*>>=\n",cmd,"\n@\n",sep="") }
  else
                  {delta<-1; news<-paste(cmd,"\n",sep="")}
}else{
            {delta<-4; news<-paste("\n@\n@<<*>>=\n",cmd,"\n@\n",sep="")}
}
<<schreibe [[news]] hinter Cursorzeile>>
tkmark.set(tworkwin, "insert", paste(line+delta,"0",sep="."))

@
\paragraph{[[get.dim.1.data]].} Es sind drei Dinge zu tun:
Beginnen wir mit [[get.dim.1.data]].
\begin{enumerate}
\item
Datensätze ermitteln
\item
die gefundenen Datensätze in einem Menü auf\-listen
\item
entsprechend der getroffenen Wahl im Arbeitsfenster eine
Eintragung vornehmen.
\end{enumerate}
<<definiere Menüfunktionen>>=
get.dim.1.data<-function(){
 (function(){
  <<ermittle eindimensionale Datensätze>>
  <<liste [[DS]] in einem Menü auf, wähle Objekt [[choice]]>>
  cmd<-paste("x <-",choice)
  <<schreibe [[cmd]] ins Arbeitsfenster>>
 })()
}

@
Mit der Datensatzermittlungsfunktion [[ds]] ist nicht viel zu tun.
<<ermittle eindimensionale Datensätze>>=
<<definiere eine Datensatzsuchfunktion>>
DS<-c( ds(-1), ds(1) ,ds(<<stelle Nummer von [[relax]] im Suchpfad fest>>)
             , "-5:5 # integers from -5 to 5", "rep(7,5) # vector: (7,7,7,7,7)")

@
Zur Ermittlung von Datensätzen mit die Funktion [[ds]] aber
erst noch definiert werden:
<<definiere eine Datensatzsuchfunktion>>=
ds<-function(pos=1,mode="numeric",struc=is.vector){
  if(pos>0){
   obj<-ls(pos=pos)
   obj<-obj[unlist(lapply(obj ,function(o,pos)
     exists(o,where=pos,mode="numeric") &&
     eval(parse(text=paste("struc(get(\"",o,"\",pos=",pos,"))",sep=""))),pos))]
   if(0==length(obj)) return(NULL) else return(obj)
  }else{
   obj<-ls(env=revive.env)
   obj<-obj[unlist(lapply(obj ,function(o)
     exists(o,where=revive.env,mode="numeric") &&
     eval(parse(text=paste("struc(get(\"",o,"\",env=revive.env))",sep=""))) ))]
   if(0==length(obj)) return(NULL) else return(obj)
  }
}



@
Die Definition von [[get.dim.2.data]] fällt nun leicht.
<<definiere Menüfunktionen>>=
get.dim.2.data<-function(){
 (function(){
  <<ermittle zweidimensionale Datensätze>>
  <<liste [[DS]] in einem Menü auf, wähle Objekt [[choice]]>>
  cmd<-paste("xy <-",choice)
  <<schreibe [[cmd]] ins Arbeitsfenster>>
 })()
}

@
<<ermittle zweidimensionale Datensätze>>=
<<definiere eine Datensatzsuchfunktion>>
DS<-ds(struc=is.matrix)
DS<-c(DS,"matrix(sample(100),50,2)","cbind(1:100,rnorm(100,mean=0,sd=1))")
DS<-c(DS, ds(-1,struc=is.matrix), ds(1,struc=is.matrix) ,
           ds(<<stelle Nummer von [[relax]] im Suchpfad fest>> ,struc=is.matrix) )

@
Es ist besser, wenn der Anwender eine Reihe spezieller
Hilfsfunktionen für die statistische Arbeit bereitgestellt
bekommt. Solange darüber aber keine Klarheit herrscht,
soll zunächst einmal für die kleinen Jobs nur aus der
Hüfte -- sozusagen als Erinnerungsposten -- die Funktionen
[[remove.na.from.x]] und [[save.matcol.as.x]] bereitgestellt werden.

@
<<definiere Menüfunktionen>>=
removenafromvecx<-function(){
  (function(){
    cmd<-"x<-x[!is.na(x)]"
    <<definiere ggf.\ myscan>>
    <<schreibe [[cmd]] ins Arbeitsfenster>>
   })()
}
removenafrommatxy<-function(){
  (function(){
    cmd<-"xy<-xy[!apply(is.na(xy),1,any),,drop=F]"
    <<definiere ggf.\ myscan>>
    <<schreibe [[cmd]] ins Arbeitsfenster>>
   })()
}

@
<<definiere Menüfunktionen>>=
choosecol<-function(){
  (function(){
    <<ermittle zweidimensionale Datensätze>>
    <<liste [[DS]] in einem Menü auf, wähle Objekt [[choice]]>>
    <<definiere [[choose.col()]]>>
    if(0==(col.no<-choose.col(choice))) return()
    cmd<-paste("x<-",choice,"[,",col.no,"]",sep="")
    <<schreibe [[cmd]] ins Arbeitsfenster>>
   })()
}

@
<<definiere [[choose.col()]]>>=
choose.col<-function(obj,title="Which variable?"){
  if(is.character(obj)) try(obj<-eval(parse(text=obj)))
  if(!is.matrix(obj)) return()
  if(is.null(choices<-dimnames(obj)[[2]])) choices<-1:ncol(obj)
  <<definiere Funktion [[listboxmenu()]]>>
  choice<-listboxmenu(choices,title)
  choice
}

@
<<definiere Funktion [[listboxmenu()]]>>=
listboxmenu<-function(choices,title="items",addexit=TRUE){
    if(addexit) choices<-c(choices,"EXIT")
    lbmTop<-tktoplevel();tkwm.geometry(lbmTop,"+0+0")
    tkwm.title(lbmTop,"Selection by Click and Return, Quit by Esc")
    ltit<-tklabel(lbmTop,text=title); lbframe<-tkframe(lbmTop)
    lb<-tklistbox(lbframe,height=8,width=60); sb<-tkscrollbar(lbframe)
    tkconfigure(lb,yscrollcommand=function(...) tkset(sb,...))
    tkconfigure(sb ,command=function(...) tkyview(lb,...))
    tkpack(ltit,lbframe)
    tkpack(sb,side="right",fill="y"); tkpack(lb)
    for(i in seq(choices)) tkinsert(lb,"end",choices[i])
    lbmdone      <- tclVar()
    tkbind(lbmTop,"<Return>",function()set.tclvalue(lbmdone,"1"))
    tkbind(lbmTop,"<Escape>",function()set.tclvalue(lbmdone,"0"))
    tkfocus(lb); tkwait.variable(lbmdone)
    choice<-tclvalue(tkget(lb,"active")); tkdestroy(lbmTop)
    if(tclvalue(lbmdone)=="0") return(0)
    ind <- match(choice, choices)
    choice <- if(addexit && ind==length(choices)) 0 else ind
    return(choice)
}

@
\paragraph{Zur Methodenauswahl.}
<<definiere Menüfunktionen>>=
get.dim.1.stats<-function(){
  (function(){
    <<definiere eindimensionale Statistiken>>
    <<liste [[DS]] in einem Menü auf, wähle Objekt [[choice]]>>
    cmd<-methoden[choice]
    <<schreibe [[cmd]] ins Arbeitsfenster>>
   })()
}
get.dim.1.plots<-function(){
  (function(){
    <<definiere eindimensionale Plots>>
    <<liste [[DS]] in einem Menü auf, wähle Objekt [[choice]]>>
    cmd<-methoden[choice]
    <<schreibe [[cmd]] ins Arbeitsfenster>>
   })()
}

@
<<definiere eindimensionale Statistiken>>=
methoden  <-c("median of x"       		="median(x,rm.na=T)"
              ,"mean of x"           			="mean(x,rm.na=T)"
              ,"standard deviation of x"         ="sd(x,rm.na=T)"
              ,"variance of x"              		="var(x,rm.na=T)"
              ,"maximum of x"  			="max(x,rm.na=T)"
	      ,"minimum of x"      			="min(x,rm.na=T)"
	      ,"quantiles of x, prob: p"	="quantile(x,p)"
	      ,"range of x"      			="range(x,rm.na=T)"
	      ,"inter quartile range of x"      	="IQR(x,rm.na=T)"
	      ,"5 number summary of x"      	="five.num(x,rm.na=T)"
	      ,"summary statistics of x"      	="summary(x,rm.na=T)"
	      ,"sorted data of x"      		="sort(x)"
	      ,"ranks of x"      				="rank(x)"
	      ,"sum of x"      		="sum(x)"
	      ,"cumulative sum of x"      		="cumsum(x)"
	      ,"length of x"      		="length(x)"
	      ,"frequency table of x"      		="table(x)"
	      ,"relative frequencies of x"      		="table(x)/length(x)"
	      )
DS<-names(methoden)

<<definiere eindimensionale Plots>>=
methoden  <-c("1 dim plot of x"="plot(x)"
 ,"boxplot of x"              ="boxplot(x)"
 ,"jitterplot of x"              ="plot(jitter(x))"
 ,"histogram of x"              ="hist(x,prob=T)"
 ,"histogram of x, breaks at br"           ="hist(x,breaks=br,prob=T)"
 ,"plot of density trace of x, width w"="plot(density(x,width=w),type=\"l\")"
 ,"barplot of x"              ="barplot(x)"
 ,"barplot of relative frequencies of x"              ="plot(table(x)/length(x))"
 ,"barplot of frequencies h.i at x.i"      ="plot(x.i, h.i, type=\"h\")"
 ,"empirical distribution function  of x"              ="plot(ecdf(x))"
 ,"stem and leaf display of x"="if(exists(\"stem.leaf\")) stem.leaf(x) else stem(x)"
)
DS<-names(methoden)

@
<<definiere Menüfunktionen>>=
get.dim.2.methods<-function(){
  (function(){
    <<definiere zweidimensionale Methoden>>
    <<liste [[DS]] in einem Menü auf, wähle Objekt [[choice]]>>
    cmd<-methoden[choice]
    <<schreibe [[cmd]] ins Arbeitsfenster>>
  })()
}

@
<<definiere zweidimensionale Methoden>>=
methoden  <-c("scatter plot of xy[,1:2]"="plot(xy[,1:2])",
              "correlation of xy" ="cor(xy)",
              "regression line of xy"  ="plot(xy[,1:2])\nabline(lsfit(xy[,1],xy[,2]))",
              "mean values of cols of xy" ="apply(xy,2,mean)"
            )
DS<-names(methoden)

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

@
\subsection{[[.Return]] --- zur Unterbrechung der weiteren Abarbeitung}
Soll zum Beispiel vor dem Einblenden des nächsten Menüs dem Anwender
die Möglichkeit gegeben werden, einen Plot zu betrachten, so wird
ein Mechanismus zur Unterbrechung benötigt. Hierbei hilft die
(versteckte) Funktionn [[.Return]], die ein kleines Label-Widget öffnet und
auf einen {\sc Return}-Druck wartet.
<<auskommentiert: definiere [[.Return]]>>=
.Return<-function(title="Return!"){
      .newl  <- tktoplevel(); tkwm.geometry(.newl,"+0+0")
      tkpack(tklabel(.newl,text=title))
      tkbind(.newl,"<Return>",function(){
                               tkdestroy(.newl);
			       set.tclvalue("tvscandone",2)
			       })
      tkfocus(.newl); tkwait.variable("tvndone")
}

@
\subsection{Die Transformation von Umlauten}
Leider sind die Vorstellungen unter {\sc dos} und in einem {\sc Tcl}-Fenster
über Umlaute unterschiedlich. Deshalb werden hier zwei Funktionen
zur Konvertierung bereitgestellt.
@
Umlautumwandlung beim Lesen von Dateien.
Externe Dateien können seltsame Charaktere enthalten.
Diese müssen dann ersetzt werden.
<<definiere Input/Output-Funktionen neu>>=
WinToTcl.read<-function(x){
  return(x)
 # x<-chartr("\204\224\201\216\231\232\341","\244\266\274\204\226\234\237",x) # old dos
    x<-chartr("\314\316\317\330\332\333\336","\244\266\274\204\226\234\237",x) # old unix
    x<-chartr("\344\366\374\304\326\334\337","\244\266\274\204\226\234\237",x)
    x<-gsub("(\244|\266|\274|\204|\226|\234|\237)","\283\\1",x) #ae
}
@
Umlautumwandlung beim Schreiben von Dateien
Externe Dateien können seltsame Charaktere enthalten.
Diese müssen dann ersetzt werden:
<<definiere Input/Output-Funktionen neu>>=
TcltoWin.write<-function(x){
 x<-gsub("\283","",x)
 x<-chartr("\244\266\274\204\226\234\237","\344\366\374\304\326\334\337",x)
 x
}

@
Umlautersetzung für Html-Datei-Speicherung.
<<ersetze Umlaute; [[AsHtml]]>>=
# Umlaute-Ersetzung fuer Tcl-Fenster nach Html:
savetext<-gsub("\237","&szlig;",savetext)
savetext<-gsub("(\244|\266|\274|\204|\226|\234)","&\\1uml;",savetext)
savetext<-chartr("\244\266\274\204\226\234", "aouAOU", savetext)
savetext<-gsub("\283","",savetext)

@
<<unused>>=
x<-gsub("\244","+ä",x) #ae
 x<-gsub("\266","+ö",x) #oe
 x<-gsub("\274","+ü",x) #ue
 x<-gsub("\204","+Ä",x) #Ae
 x<-gsub("\226","+Ö",x) #Oe
 x<-gsub("\234","+Ü",x) #Ue
 x<-gsub("\237","+ß",x) #sz
toUnixTcl<-function(x){
 x<-chartr("\344\366\374\304\326\334\337","\314\316\317\330\332\333\336",x)
 x<-chartr("\204\224\201\216\231\232\341","\314\316\317\330\332\333\336",x)
 x<-sub("\032","",x)
}
 x<-gsub("\344","\283\244",x) #ae
 x<-gsub("\366","\283\266",x) #oe
 x<-gsub("\374","\283\274",x) #ue
 x<-gsub("\304","\283\204",x) #Ae
 x<-gsub("\326","\283\226",x) #Oe
 x<-gsub("\334","\283\234",x) #Ue
 x<-gsub("\337","\283\237",x) #sz
savetext<-gsub("\336","&szlig;",savetext)
savetext<-gsub("(\314|\316|\317|\330|\332|\336)","&\\1uml;",savetext)
savetext<-chartr("\314\316\317\330\332\333", "aouAOU", savetext)
# Umlaute-Ersetzung fuer Unix-Dateien nach Html:
# savetext<-gsub("\341","&szlig;",savetext)  ;
# savetext<-gsub("(\204|\224|\201|\216|\231|\232)","&\\1uml;",savetext)
# savetext<- chartr("\204\224\201\216\231\232", "aouAOU", savetext)


@
%tcl2dos<-function(x){
% x<-gsub("ä","ä",x);x<-gsub("ö","ö",x);x<-gsub("ü","ü",x)
% x<-gsub("Ä","Ä",x);x<-gsub("Ö","Ö",x);x<-gsub("Ü","Ü",x)
% x<-gsub("ß","ß",x)
%}
%dos2tcl<-function(x){
% x<-gsub("ä","ä",x);x<-gsub("ö","ö",x);x<-gsub("ü","ü",x)
% x<-gsub("Ä","Ä",x);x<-gsub("Ö","Ö",x);x<-gsub("Ü","Ü",x)
% x<-gsub("ß","ß",x)
%}

@
\section{Zusammenbau und Restarbeiten}

@
\subsection{Die große Bauanleitung und die Funktion [[relax]]}
Nachdem jetzt alle Teilprobleme bearbeitet worden sind, können die Teillösungen
zu der Funktion [[relax]] zusammengebaut werden. Dabei ist besonders
zu berücksichtigen, daß Dinge, die verwendet werden, zuvor definiert
sein müssen, sprich: es kommt auf die richtige Reihenfolge an.
Voraussetzung für die Arbeit mit [[relax]] ist, daß das
Paket [[Tcl/Tk]] geladen wurde.
Die Option [[no.plots]] veranlaßt den Manager keine Bilder einzublenden.

[[pswidth.sys="13cm"]] wurde als Parameter, da an sich überflüssig, entfernt.
<<*>>=
relax<-function(file.name,no.plots=FALSE,cmds="",but.Wizardry=TRUE){
 # Copyright (C) 2005 Hans Peter Wolf
  <<stelle Pfad und Position von [[relax]] fest>>
  assign("running.function",<<relax>>, pos=relax.pos)
  <<definiere [[myhead.menu]]>>
  <<definiere Funktion zur Erleichterung der Fehlersuche>>
  <<setze Anwenderkonfiguration um>>
  <<lade das [[Img]]-Paket für [[Tcl/Tk]]>>
  <<definiere Funktionen zum Umgang mit [[Tcl]]-Variablen>>
  <<generiere eine neue Umgebung für die Anwenderdaten>>
  <<definiere Input/Output-Funktionen neu>>
  <<ermittle Namen einer temporären Datei>>
  <<ermittle Namen einer Sink-Datei>>
  <<definiere [[SaveAsHtml]]>>           ##definiere Testknopf\-funktion##
  <<definiere Funktionen allgemeiner Knöpfe>>
  <<definiere Kopf-Zeilen-Funktionen>>                       ##setze Umgebung für Knopf\-funktionen##
	  ##setze Umgebung für Testknopf\-funktion##   ##setze Umgebung für Zeilen-Funktionen##
  <<setze Umgebung für sonstige Funktionen>>
  <<definiere Data-Fns-Menü>>
  <<setze einige Konstanten>>
  <<setze einige [[tcl]]-Konstanten>>
  <<setze Systemkonstanten>>
  <<definiere plattformspezifische Ereignisse>>         ##definiere Testknopf-Ereignis>>
  <<definiere [[Implement.but]]>>
  melde("Implement.but defined",3)

  <<generiere Top-Level-Fenster mit verschiedenen Frames>>
  <<definiere Kopf-Frame>>
  melde("frame head defined",3)

  <<definiere Report-Aktionsframe>>           ##implementiere Testknopf##
  <<definiere Report-Text-Frame>>
  <<definiere Info-Frame>>
  melde("frame info defined",3)

  <<implementiere Eigenschaften der allgemeinen Knöpfe>>   ##implementiere Eigenschaften vom Testknopf##
  twin<-tworkwin; <<stelle besondere Zeichen in [[twin]] zur Verfügung>>
  <<definiere Wirkung von [[Strg Pagedown]] im Reportfenster>>
  ##definiere Funktionstasten-Puffer##
  <<definiere Bindung zur Abarbeitung von [[cmds]]>>
  melde("initialization of RELAX finished",3)
  <<lade ggf. [[file.name]] und verarbeite Argument [[cmds]]>>
  data.fns.menu()
  if(language=="german"){
    cat("relax Initialisierung abgeschlossen!\nR-Editor wird erneut durch  relax()  gestartet!\n")
  }else{
    cat("initialisation of relax completed!\nrestart relax by: relax()\n")
  }
  tkwait.variable("tvexit")
  return()
}

@
<<stelle Pfad und Position von [[relax]] fest>>=
relax.path<-.path.package(<<relax>>)
relax.pos<-grep("^package:relax$",search())[1]

@
Folgende Konstante werden jetzt in der Datei config/settings.relax gesetzt:
<<define-config-settings>>=
#############################################
# configuration file of relax
#############################################
#
## general parameters of relax
# language for messages:
language<-"english"
# language<-"german"
# maximal characters of output to be shown
maxol.sys<-2500
# size of fonts # set of values: 1,2, ..., 7
initial.font.size<-4
# height of included postscript plot in LaTeX document:
psheight.sys<-"10cm"
# height parameter for postscript device
psdesignheight.sys<-6
# width parameter for postscript device
psdesignwidth.sys<-6
#############################################
## special settings for windows
# how to call LaTeX
latex.command.windows<-"echo q | latex"
# view command for viewing .dvi files
view.command.windows<-"yap"
# how to call dvipdf
dvipdf.command.windows<-"dvipdfm"
# text editor
text.editor.windows<-"notepad"
# browser
# browser.windows<-"c:/Programme/.../mozilla"
#############################################
## special settings for linux
path.tcltk.package.img<-"/usr/local/lib"
# how to call LaTeX
latex.command.linux<-"echo q | latex"
# view command for viewing .dvi files
view.command.linux<-"xdvi"
# how to call dvipdf
dvipdf.command.linux<-"dvipdf"
# text editor
text.editor.linux<-"eddi"
# browser
browser.linux<-"konqueror"

@
<<old settings for windows, used in: [[FormatTeXLines]]>>=
# path to ghostscript
# ghostscript<-"c:\\gs\\gs7.04\\bin\\gswin32"
ghostscript<-"c:\\Programme\\gstools\\gs7.04\\bin\\gswin32"

@
<<setze Anwenderkonfiguration um>>=
<<define-config-settings>>
try({
  h<-scan(file=file.path(relax.path,"config/settings.relax"),what="",sep="\n")
  for(i in seq(h)) eval(parse(text=h[i]))
})
if(<<das OS ist Windows>>) {
  editor.sys <- text.editor.windows
}
if(<<das OS ist Linux>>) {
  editor.sys <- text.editor.linux
}
browser.sys<-""
if(<<das OS ist Windows>>) {
  if(exists("browser.windows")) browser.sys <- browser.windows
}
if(<<das OS ist Linux>>) {
  if(exists("browser.linux")) browser.sys <- browser.linux
}
if(!exists("initial.font.size")) initial.font.size<-4
initial.font.size<-initial.font.size[1]
if(is.na(initial.font.size) || all(initial.font.size!=(1:7))) initial.font.size<-4

@
\subsection{Funktionstastenbelegung}
Für das Schreiben der Textstücke haben sich
Clipboard-Fähigkeiten bewährt. Etwas allgemeiner können mehrere
Buffer als temporäre Textbausteinspeicher zur Verfügung stehen.
Für experimentelle Zwecke werden 8 Speicher eingerichtet, deren
Inhalte durch Betätigung der Funktionstasten in das Textfenster
übertragen werden. Editiert werden sie über einen Wizard-Menü-Eintrag.
Default-mäßig werden auf ihnen übliche \LaTeX-Konstrukte abgelegt.
Der aktuelle Zustand befindet sich in der Umgebung [[revive.sys]].
Wird beim Aufruf die Variable "F.buffers gefunden,
wird diese zur Setzung der Puffer herangezogen.
<<definiere Funktionstasten-Puffer>>=
buffers <- if(exists("F.buffers")) F.buffers else NULL
buffers <- c(buffers,
                    "\\begin{center}\n\n\\end{center}\n",
                    "\\begin{enumerate}\n\\item\n\\end{enumerate}\n",
                    "\\begin{eqnarray*}\n\n\\end{eqnarray*}\n",
                    "\\begin{itemize}\n\\item\n\\end{itemize}\n",
                    "\\begin{quote}\n\n\\end{quote}\n",
                    "\\begin{verbatim}\n\n\\end{verbatim}\n","","")[1:8]
assign("F.buffers",buffers,env=revive.sys)
tkbind(TopW,"<F1>", function(){
    news<-get("F.buffers",env=revive.sys)[1];    <<schreibe [[news]] hinter Cursorzeile>>  })
tkbind(TopW,"<F2>", function(){
    news<-get("F.buffers",env=revive.sys)[2];    <<schreibe [[news]] hinter Cursorzeile>>  })
tkbind(TopW,"<F3>", function(){
    news<-get("F.buffers",env=revive.sys)[3];    <<schreibe [[news]] hinter Cursorzeile>>  })
tkbind(TopW,"<F4>", function(){
    news<-get("F.buffers",env=revive.sys)[4];    <<schreibe [[news]] hinter Cursorzeile>>  })
tkbind(TopW,"<F5>", function(){
    news<-get("F.buffers",env=revive.sys)[5];    <<schreibe [[news]] hinter Cursorzeile>>  })
tkbind(TopW,"<F6>", function(){
    news<-get("F.buffers",env=revive.sys)[6];    <<schreibe [[news]] hinter Cursorzeile>>  })
tkbind(TopW,"<F7>", function(){
    news<-get("F.buffers",env=revive.sys)[7];    <<schreibe [[news]] hinter Cursorzeile>>  })
tkbind(TopW,"<F8>", function(){
    news<-get("F.buffers",env=revive.sys)[8];    <<schreibe [[news]] hinter Cursorzeile>>  })
tkbind(TopW,"<F1>", function(){
    news<-get("F.buffers",env=revive.sys)[1];    <<schreibe [[news]] hinter Cursorzeile>>  })

@
<<schreibe [[news]] hinter Cursorzeile>>=
<<hole ggf. [[tworkwin]]>>
<<bestimme Cursorzeile [[line]] von [[tworkwin]]>>
    anzrows<-length(news)
    try(tkinsert(tworkwin,paste(line+1,"0",sep="."),paste(news,collapse="\n")))
    tkmark.set(tworkwin, "insert", paste(line+anzrows,"0",sep="."))
    tksee(tworkwin,paste(line+anzrows,"0",sep="."))
tkfocus(tworkwin)
melde("inserted characters: \n",3,substring(news[1:min(7,length(news))],1,80))

@
Jetzt ist noch der Menüpunkt zur Pufferänderung zu erstellen.
<<erstelle Menüeintrag für Funktionstasten-Puffer>>=
tkadd(mbRevweb.menu, "command", command=DefineFKeys,
      label="DefineFKeys:    define F-Keys / buffers")

@
Es folgt die Definition des Kommandos.
\subsubsection{Kopfzeile: [[DefineFKeys]]}
\paragraph{[[DefineFKeys]]} ermöglicht die Funktionstasten mit Texten zu belegen,
die dann ins Arbeitsfenster eingefügt werden.
<<definiere Kopf-Zeilen-Funktionen>>=
DefineFKeys<-function(){
  melde("DefineFKeys",1)
  frage<-"number of function key?"; set.tclvalue("tvinfo",1)
  <<frage [[frage]], biete [[tvinfo]] als Antwort an>>
  tkbind(TopW,"<Return>", function(){
      F.no<-tclvalue("tvinfo")
      <<setze Manager nach {\sc Return} in Normalzustand>>
      if(!any(F.no==as.character(1:8))) return() else F.no<-as.numeric(F.no)
      .newl<-tktoplevel();tkwm.geometry(.newl,"+0+0");tkpack(tt<-tktext(.newl))
      twin<-tt; <<stelle besondere Zeichen in [[twin]] zur Verfügung>>
      tkwm.title(.newl,paste("contents of function key","Definition by Escape!"))
      F.buffers<-get("F.buffers",env=revive.sys)
      try(tkinsert(tt,"0.0",paste(F.buffers[F.no],collapse="\n")))
      abbruch<-function(){tkdestroy(.newl); set.tclvalue("tvscandone",2)}
      tkbind(.newl,"<Escape>", function(){
		 F.buffers[F.no]<-tclvalue(tkget(tt,"0.0","end"))
		 assign("F.buffers",F.buffers,env=revive.sys)
                 tkdestroy(.newl); set.tclvalue("tvscandone",2)
	       })
      tkfocus(.newl);tkwait.variable("tvndone")
      set.tclvalue("tvmess","relax")
    } # end of function
  )
  melde("DefineFKeys",2)
}

@
\subsection{[[Tcl/Tk]] als Voraussetzung für die Oberfläche}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Wird der Report-Manager als R-Pakete geladen, so sind für das Funktionieren
einige Vorarbeiten zu erledigen. Unter Windows sind die Umgebungs-Variablen
[[PATH]] und [[TCL_library]] zu setzen,
damit für die [[tcl/tk]]-Oberfläche die notwendigen Zutaten gefunden werden.
\begin{center}
[[PATH=..../rw*/library/relax/bin]]\\
[[TCL_library=..../rw*/library/relax/lib/tcl8.3]]
\end{center}
Weiterhin wird nach dem Laden des [[Tcl/Tk]]-Paketes mit Hilfe
eines [[Tcl]]-Kommandos das Paket [[img]]-Paket geladen, damit in den
Textfenster [[jpeg]]-Bilder angezeigt werden können.

Unter [[Unix]] müssen ggf.\ die Pfade zum Beispiel bei
Änderungen des System-Dateibaums im [[HRZ]] angepaßt werden.
<<lade das [[Img]]-Paket für [[Tcl/Tk]]>>=
if(<<das OS ist Windows>>){
  settclenvvars<-function(){
    imgpath<-file.path(relax.path,"lib")  # ; print(imgpath)
    try(.Tcl(paste("lappend auto_path",imgpath)))
  }
  settclenvvars()
  try(.Tcl("package require Img"))
} else{
  <<setze unter [[Unix]] Pfad in [[Tcl/Tk]] zum Image-Paket>>
}

@
Zur Umsetzung von [[.Tcl("lappend auto_path /usr/local/lib") # img1.3 ]]\\
sowie [[.Tcl("package require Img")]]
<<setze unter [[Unix]] Pfad in [[Tcl/Tk]] zum Image-Paket>>=
Img.ok<-F
if(file.exists(path.tcltk.package.img)){ # pwolf-lokal
        addTclPath(path.tcltk.package.img); Img.ok<-T
}
if(Img.ok) try(tclRequire("Img"))

@
\subsection{Funktionalitäten von Knöpfen, die immer präsent sind}
Für die Übersicht werden in dieser Sektion die Definitionen aller Knöpfe
zusammengefaßt.
<<definiere Funktionen allgemeiner Knöpfe>>=
<<definiere Funktion für Knopf: [[Help.R]]>>
##definiere Funktion für Knopf: [[InsertPlot]]##
<<definiere Funktion für Knopf: [[InsertTeX]]>>
<<definiere Funktion für Knopf: [[PlanRCode]]>>
<<definiere Funktion für Knopf: [[RemoveOut]]>>
<<definiere Funktion für Knopf: [[Insert]]>>
<<definiere Funktion für Knopf: [[SavePlot]]>>
##definiere Funktion für Knopf: [[CopyToEnd]]##
<<definiere Funktion für Knopf: [[TrashROutput]]>>
<<definiere Funktion für Knopf: [[EvalRCode]]>>
<<definiere Funktion für Knopf: [[Up]]>>
<<definiere Funktion für Knopf: [[Down]]>>
@
Durch Verschiebung der folgenden Funktionen ist
eine Environment-Veränderung nicht mehr nötig.

@
<<setze Umgebung für sonstige Funktionen>>=
environment(myhead.menu)<-revive.sys

@
\subsection{Initialisiere einige Variablen}
<<setze einige Konstanten>>=
REVFILE            <- "REVFILE"    # eingelesener RevFile
RCHFILE            <- "RCHFILE"    # eingelesener Chunk-File
fr.paper.sys       <- "forget"     #

@
17.~Juni 2002 -- Erkenntnis:
[[version$os]] liefert unter 1.5.1: [[mingw32]] statt [[Win32]].
<<das OS ist Windows>>=
(version$os=="Win32" || version$os=="mingw32")

@
<<unused: definiere Funktionen zum Umgang mit [[Tcl]]-Variablen>>=
get.tclvar<-function(name){
  tclvalue(name)
}
@
<<definiere Funktionen zum Umgang mit [[Tcl]]-Variablen>>=
set.tclvalue<-function(name,value)  tclvalue(name)<-as.character(value)
assign("set.tclvalue",set.tclvalue, pos=relax.pos)
  
@
<<setze einige [[tcl]]-Konstanten>>=
tvexit       <- tclVar("0")
tvchoice     <- tclVar("0")
tvndone      <- tclVar("0")
tvscandone   <- tclVar("0")
tvinfo       <- tclVar("")      # Variable des Kopf-Entry-Widget
tvreadline   <- tclVar("0")
tvmess       <- tclVar("relax")

@
Unter Linux ggf.\ Variable:  export VISUAL=eddi   setzen???
<<setze Systemkonstanten>>=
revpath.sys  <- getwd()         # Pfad zum Revwebpaperverzeichnis
secno.sys    <- "0"             # aktuelle SecNo. in der Revdatei
string.sys   <- ""              # Default-Suchstring

sizes<-c("8-80","10-100","12-120","14-140","18-180","24-240","*-2000")
tfont.sys    <- "-Adobe-helvetica-Medium-R-Normal--14-140-*" # Text-Schrift
tfont.sys<-sub("al--.+-.+-\*",paste("al--",sizes[initial.font.size],"-*",sep=""),tfont.sys)
outfont.sys  <- "-Adobe-courier-Medium-R-Normal--14-140-*"   # Output-Schrift
outfont.sys<-sub("al--.+-.+-\*",paste("al--",sizes[initial.font.size],"-*",sep=""),outfont.sys)
workname.sys<-"out.rev"

@
<<lade ggf. [[file.name]] und verarbeite Argument [[cmds]]>>=
if(!missing(file.name)){
   file.name<-gsub("\\\\","/",file.name)
   if(0<length(grep("/",file.name))){
     path<-sub("^(.*)/(.*)","\\1",file.name)
     print(path)
     if(nchar(path)>0) try(setwd(path))
     file.name<-sub("^(.*)/","",file.name)
   }
   if(0==length(grep(".rev$",file.name))) file.name<-paste(file.name,"rev",sep=".")
   print(file.name)
   workname.sys<-file.name
   assign("cmds",paste("r",file.name),env=revive.env)
   Execute.cmds(); RunStart()
}
if(0<length(cmds) && cmds[1]!="") {
  assign("cmds",cmds,env=revive.env)
  Execute.cmds()
}

@
Definition einiger Konstanten

Zeichensatz für Knöpfe u.ä.
War 14-140
<<Font für Knöpfe>>=
"-Adobe-helvetica-Medium-R-Normal--12-140-*" # ,foreground="#124800"

@
Breite der Knöpfe:
<<Knopfbreite>>=
10

@
Breite des Informationsfeldes:
<<Infofeldbreite>>=
80

@
Hinweis für Schriften: Durch Tausch von [[-r-]] statt [[-o-]] erhält
man eine kursive Schrift.

@
\subsection{Plattformabhängige Events}
Die Bezeichnungen von Event variieren von Maschine zu Maschine. Deshalb
ist es vorteilhaft, mit virtuellen Events zu arbeiten. Die spezifischen
Events sollen in einem Chunk zusammengestellt werden.
Als Beispiel sei die Lösung zum Anstoß von [[fSetNo]] über
{\sc Alt-S} betrachtet. Ohne virtuelle Events leistet dieses:
\begin{quote}
\begin{verbatim}
if(version$os=="Win32"){
  tkbind(TopW,"<Alt_L><s>", fSetNo)
} else {
  tkbind(TopW,"<ssharp>", fSetNo)
}
\end{verbatim}
\end{quote}
@
Wird jedoch durch
\begin{quote}
\begin{verbatim}
if(version$os=="Win32"){
  tkevent.add("@<<SetNo>>","<Alt_L><s>")
} else {
  tkevent.add("@<<SetNo>>","<ssharp>")
}
\end{verbatim}
\end{quote}
@
anlagenspezifisch das virtuelle Ereignis [[@<<SetNo>>]] definiert,
so entfällt im Code die Verzweigung:
\begin{quote}
\begin{verbatim}
tkbind(TopW,"@<<SetNo>>", fSetNo)
\end{verbatim}
\end{quote}
@
Für HPUX gelten die Setzungen des else-Teiles.
<<definiere plattformspezifische Ereignisse>>=
if(<<das OS ist Windows>> | <<das OS ist Linux>>){
  tkevent.add("@<<EvalRCode>>",  "<Alt_L><e>")
  tkevent.add("@<<Down>>",  "<Alt_L><d>")
  tkevent.add("@<<Up>>",  "<Alt_L><u>")
  tkevent.add("@<<AdvanceNo>>", "<Alt_L><a>")
  tkevent.add("@<<TrashROutput>>","<Alt_L><t>")
  tkevent.add("@<<Next>>",      "<Alt_L><n>")
  tkevent.add("@<<Help.R>>",   "<Alt_L><h>")
  tkevent.add("@<<Modify>>",    "<Alt_L><m>")
  tkevent.add("@<<PlanRCode>>",   "<Alt_L><p>")
  tkevent.add("@<<FindReportText>>",   "<Control_L><f>")
  tkevent.add("@<<SaveReport>>",   "<Control_L><s>")
  tkevent.add("@<<ProcessReport>>",   "<Control_L><p>")
  tkevent.add("@<<RemoveOut>>",   "<Alt_L><r>")
  tkevent.add("@<<Insert>>",   "<Alt_L><i>")
  tkevent.add("@<<SavePlot>>","<Alt_L><s>")
  tkevent.add("@<<CopyToEnd>>",   "<Alt_L><c>")
  tkevent.add("@<<CopyOld>>",   "<Alt_L><x>")
  tkevent.add("@<<RunNo>>",     "<Alt_L><r>")
  tkevent.add("@<<SetNo>>",     "<Alt_L><s>")
  tkevent.add("@<<ActChunk>>",  "<Control_L><Next>")#Short-Cut copy.down / set
  tkevent.add("@<<RKgeschw>>",  "<Alt_L><0>")
  tkevent.add("@<<LKgeschw>>",  "<Alt_L><7>")
  tkevent.add("@<<RKeckig>>",   "<Alt_L><9>")
  tkevent.add("@<<LKeckig>>",   "<Alt_L><8>")
  tkevent.add("@<<Tilde>>",     "<Alt_L><plus>")
  tkevent.add("@<<Klammera>>",  "<Alt_L><q>")
  #tkevent.add("@<<Backsl>>",    "<Alt_L><ssharp>")
  tkevent.add("@<<Pipe>>",      "<Alt_L><less>")
  tkevent.add("@<<aeumlaut>>",      "<adiaeresis><KeyRelease>")
  tkevent.add("@<<oeumlaut>>",      "<odiaeresis><KeyRelease>")
  tkevent.add("@<<ueumlaut>>",      "<udiaeresis><KeyRelease>")
  tkevent.add("@<<Aeumlaut>>",      "<Adiaeresis><KeyRelease>")
  tkevent.add("@<<Oeumlaut>>",      "<Odiaeresis><KeyRelease>")
  tkevent.add("@<<Ueumlaut>>",      "<Udiaeresis><KeyRelease>")
  tkevent.add("@<<szumlaut>>",      "<ssharp><KeyRelease>")
  tkevent.add("@<<Backsl>>",    "<Alt_L><ssharp>")
} else {                                               #f <hpguilder>
  tkevent.add("@<<EvalRCode>>",  "<ae>")
  tkevent.add("@<<AdvanceNo>>", "<aring>")
  tkevent.add("@<<TrashROutput>>","<hpmute_acute>") # vorher Drop:<eth>  #u <hpmute_diaeresis>
  tkevent.add("@<<InsertPlot>>","<hpmute_asciitilde>") #c <ccedilla>
  tkevent.add("@<<Next>>",      "<ordfeminine>")
  tkevent.add("@<<Help.R>>",   "<yen>")
  tkevent.add("@<<Modify>>",    "<mu>")
  tkevent.add("@<<PlanRCode>>",   "<thorn>")
  tkevent.add("@<<CopyOld>>",   "<ccedilla>")                #a aring
  tkevent.add("@<<RunNo>>",     "<hpmute_acute>")
  tkevent.add("@<<SetNo>>",     "<ssharp>")
  tkevent.add("@<<ActChunk>>",  "<Control_L><Next>")#Short-Cut copy.down / set
  tkevent.add("@<<RKgeschw>>",  "<braceright>")
  tkevent.add("@<<LKgeschw>>",  "<braceleft>")
  tkevent.add("@<<RKeckig>>",   "<bracketright>")
  tkevent.add("@<<LKeckig>>",   "<bracketleft>")
  tkevent.add("@<<Tilde>>",     "<asciitilde>")
  tkevent.add("@<<Klammera>>",  "<at>")
  tkevent.add("@<<Backsl>>",    "<Alt_R><backslash>")
  tkevent.add("@<<Pipe>>",      "<Alt_R><bar>")
}

@
<<das OS ist Linux>>=
substring(version$os,1,5)=="linux"

@
Es zeigte sich, daß in Abhängigkeit vom Betriebssystem ein unterschiedliches
Warteverhalten realisiert werden muß. Die Abfrage wird über einen Code-Chunk
umgesetzt. Vorher: [[tclvar$warten]].
<<warte, falls das OS NICHT Windows ist>>=
if( (! <<das OS ist Windows>>) ) tkwait.variable("tvchoice")

@
\subsection{Debugging und Klick-Report}
Bis zum Schluß ist die Definition der Funktion [[melde]] aufgespart worden,
die die Fehlersuche ein wenig erleichtert. Testerei führte mit
[[sys.calls]], [[browser]] u.a.\ leider bei alten R-Versionen zu Problemen.
<<definiere Funktion zur Erleichterung der Fehlersuche>>=
melde<-function(report.msg,typ=0,...){
  cat<-get("cat",pos="package:base")
  # if(exists("last.warning"))get("print",pos="package:base")(last.warning)
  if(typ==0) cat(report.msg,...,"\n")
  if(exists("DEBUG") && TRUE==DEBUG){
    if(typ==1 | typ==2) cat(c(a="Start:",z="Ende:")[typ], report.msg,"\n")
    if(typ==3){cat(report.msg); cat(...); cat("\n")}
  }
  if(typ=="cmd.msg"){
    if(<<das OS ist Windows>>) flush.console()
    if(exists("report.msg.to.file.flag")) cat(report.msg, "\n", file="report.msg", append=TRUE)
  }
  invisible()
}
assign("melde",melde, pos=relax.pos)

@
Zur Erleichtung der Fehlersuche kann mit der Funktion [[relax.debug]]
der eventuell veränderte Editor [[relax]] neu geladen werden.
Dabei kommen schärfere Debugging Regeln zum Einsatz.
<<dieser Chunk könnte beim Debuggen helfen>>=
relax.debug<-function(){
  DEBUG<<-T; options(warn=5)
  path<-sub(paste("/",<<relax>>,sep=""),"",.find.package(<<relax>>))
  detach("package:relax")
  library(relax,lib.loc=path)
  assign("DEBUG",T,paste("package",<<relax>>,sep=":"))
  relax()
}

@
\section{Weitere wichtige Definitionen und Dateien von [[relax]]}

\subsection{Datei [[DESCRIPTION]]}

<<define-DESCRIPTION>>=
Package: relax
Version: 1.00
Date: 2005-06-24
Title: relax -- R Editor for Literate Analysis and lateX
Author: Hans Peter Wolf <pwolf@wiwi.uni-bielefeld.de>
Maintainer: Hans Peter Wolf <pwolf@wiwi.uni-bielefeld.de>
Depends: R (>= 2.1.0), tcltk
Description: package relax contains some functions for report
    writing, presentation, and programming: relax(), tangleR(),
    weaveR(), slider(). "relax" is written in R and Tcl/Tk.
    relax creates a new window (top level Tcl/Tk widget) that consists
    of two text fields and some buttons and menus.
    Text (chunks) and code (chunks) are inserted in the upper text field (report field).
    Code chunks are evaluated by clicking on EvalRCode.
    Results are shown in the lower text field (output field) and
    will be transfered to the report field by pressing on Insert.
    In this way you get correct reports. These reports can be
    loaded again in cause of presentation, modification and result checking.
    tangleR() and weaveR() implement a plain kind of tangling
    and weaving. slider() is designed to define sliders for interactive
    experiments in a simple way.
    The windows version uses some ingredients of the noweb system of Norman Ramsey
    (http://www.eecs.harvard.edu/~nr/noweb/intro.html),
    of the Img package of Jan Nijtmans (http://www.xs4all.nl/~nijtmans/img.html),
    -- notice the copyright declarations of these products.
License: This package was written by Hans Peter Wolf.
   This software is licensed under the GPL (version 2 or newer) terms.
    It is free software and comes with ABSOLUTELY NO WARRANTY.
URL: http://www.wiwi.uni-bielefeld.de/~wolf/software/relax/relax.html

@
\subsection{Help-Page von [[relax]]}

<<define-relax-help>>=
\name{relax}
\alias{relax}
%- Also NEED an '\alias' for EACH other topic documented here.
\title{ R editor: relax }
\description{
  \code{relax} is an editor for doing data analysis with R and writing reports.
}
\usage{
relax(file.name, no.plots = FALSE, cmds = "", but.Wizardry = TRUE)
}
%- maybe also 'usage' for other objects documented here.
\arguments{
  \item{file.name}{name of report file to be loaded }
  \item{no.plots}{ if \code{TRUE} no plots are integrated into the report text field}
  \item{cmds}{ special operations that are evaluated on start }
  \item{but.Wizardry}{ if \code{FALSE} menu \code{Wizardry} is not created }
}
\details{
  \code{relax} is written in R and Tcl/Tk.
  \code{relax} creates a new window (top level Tcl/Tk widget) that consists of
  two text fields and some buttons and menus. Text (chunks) and code (chunks)
  are inserted in the upper text field (report field). Code chunks are evaluated by clicking
  on \code{EvalRCode}. Results are shown in the lower text field (output field) and will be
  transfered to the report field by pressing on \code{Insert}.

  Chunks are separated by separators:
  A line containing the character "@" at its first position indicades the beginning of a text chunk.
  Patterns like \code{@<<*>>=} or \code{@<<}code chunk name\code{>>=} define code chunk
  headers and introduce code chunks.
  The code of a code chunk is the set of R expression found between the header and the
  following text chunk.

  How to work with relax?
  \itemize{
   \item{Load of package \code{relax}}{in \code{R} through: \code{library(relax)}.}

   \item{Start the editor by:}{\code{relax()}.}

   \item{PlanRCode:}{Press \code{PlanRCode} and an empty text chunk and an empty code
   chunk without contents appear in the report field (upper blue text field).
   Now you can write down any text between
   "@"-line and the header of next code chunk \code{@<<*>>=}. The code has to be placed
   after the header line.}

   \item{EvalRCode:}{\code{EvalRCode} evaluates the code (the cursor is pointing at)
   and the results appear in the output field just as in \code{R}.}

   \item{RemoveOut:}{\code{RemoveOut} clears the output field.}

   \item{Insert:}{\code{Insert} transfers the contents of the output text field
   to the upper text field as a new text chunk.}

   \item{SavePlot:}{\code{SavePlot} copies the graphics device; it creates a \code{postscript}
         as well as a \code{jpeg} file and inserts the LaTeX includegraphics reference
	 in the report field as a new text chunk.}

   \item{TrashOutput:}{\code{TrashOutput} removes inserted \code{R} output from the upper field
   (the cursor is pointing at). }

   \item{Down:}{\code{Down} moves the cursor down to the next code chunk.}

   \item{Up:}{\code{Up} moves the cursor up to the next code chunk.}

    \item{File:}{The \code{File} menu in the menu bar of \code{relax} allows you save the report
   -- the contents of the blue text field. The saving operation generates two
   files: a text file (extension: \code{rev}) and a \code{html} file.
   You can load an old report into the upper text field (report field)
   and continue to work on the report.}

    \item{Edit:}{Several operations to make editing faster and easier are collected in the \code{Edit} menu:
   searching, starting an external editor, etc.}

   \item{Options:}{The entries of the \code{Options} menu change some of the parameter of relax.}

    \item{Wizardry:}{With \code{Wizardry} you are able to generate LaTeX documents
    (for LaTeXperts only).
    After saving the raw report you can \code{web} it: this process generates a \code{tex}-file
    that can be formated by LaTeX. See your LaTeX companion for syntax.
    (The web syntax fits to the rules of \code{noweb}.
    Therefore, the raw files can also be processed by Norman Ramsey's
    \code{noweb} system (see: \cr \url{http://www.eecs.harvard.edu/~nr/noweb/}).}

    \item{Configuration:}{
    Some parameters of \code{relax} can be modified in \code{...relax/config/settings.relax}.}

    \item{Environment for evaluation:}{
    Evaluations of code chunks take place in the environment (\code{revive.env}).}

    \item{cmds:}{
    The character vector \code{cmds} in environment (\code{revive.env}) enables you to
    define operations of your own. For example, \code{cmds<-"r test1.rev"} forces \code{relax}
    to load file \code{test1.rev}. \code{cmds<-c("> 1+1","> 2+2")} results in
    computing 1+1 and then 2+2. \code{cmds<-"s10"} evaluates code chunk number 10.}
   }
}
\value{
   --
}
\references{\url{http://www.wiwi.uni-bielefeld.de/~wolf/software/relax/relax.html}}
\author{2005 Hans Peter Wolf}
\note{}

\seealso{  }
\examples{

## The function is currently defined as
function (workname.sys = "out.rev", no.plots = FALSE, cmds = "", but.Wizardry = TRUE){
      # nearly 5000 lines of R / Tcl/Tk code
}
}
\keyword{ documentation }% at least one, from doc/KEYWORDS

@
\subsection{Help-Page von [[slider]]}
<<define-slider-function>>=
slider<-function(sl.functions,sl.names,sl.mins,sl.maxs,sl.deltas,sl.defaults,
                  but.functions,but.names,
                  no,set.no.value,obj.name,obj.value,
                  reset.function,title){
  # slider, version2, pw 040107
  if(!missing(no)) return(as.numeric(tclvalue(get(paste("slider",no,sep=""),env=slider.env))))
  if(!missing(set.no.value)){ try(eval(parse(text=paste("tclvalue(slider",set.no.value[1],")<-",
                            set.no.value[2],sep="")),env=slider.env)); return(set.no.value[2]) }
  if(!exists("slider.env")) slider.env@<<-new.env()
  if(!missing(obj.name)){
    if(!missing(obj.value)) assign(obj.name,obj.value,env=slider.env) else
      obj.value<-get(obj.name,env=slider.env)
    return(obj.value)
  }
  if(missing(title)) title<-"slider control widget"
  require(tcltk); nt<-tktoplevel(); tkwm.title(nt,title); tkwm.geometry(nt,"+0+0")
  if(missing(sl.names)) sl.names<-NULL
  if(missing(sl.functions)) sl.functions<-function(...){}
  for(i in seq(sl.names)){
    eval(parse(text=paste("assign('slider",i,"',tclVar(sl.defaults[i]),env=slider.env)",sep="")))
    tkpack(fr<-tkframe(nt));  lab<-tklabel(fr, text=sl.names[i], width="25")
    sc<-tkscale(fr,from=sl.mins[i],to=sl.maxs[i],showvalue=T,resolution=sl.deltas[i],orient="horiz")
    tkpack(lab,sc,side="right"); assign("sc",sc,env=slider.env)
    eval(parse(text=paste("tkconfigure(sc,variable=slider",i,")",sep="")),env=slider.env)
    sl.fun<-if(length(sl.functions)>1) sl.functions[[i]] else sl.functions
    if(!is.function(sl.fun)) sl.fun<-eval(parse(text=paste("function(...){",sl.fun,"}")))
    tkconfigure(sc,command=sl.fun)
  }
  assign("slider.values.old",sl.defaults,env=slider.env)
  tkpack(f.but<-tkframe(nt),fill="x")
  tkpack(tkbutton(f.but, text="Exit", command=function()tkdestroy(nt)),side="right")
  if(missing(reset.function)) reset.function<-function(...) print("relax")
  if(!is.function(reset.function))
    reset.function<-eval(parse(text=paste("function(...){",reset.function,"}")))
  tkpack(tkbutton(f.but, text="Reset", command=function(){
         for(i in seq(sl.names))
            eval(parse(text=paste("tclvalue(slider",i,")<-",sl.defaults[i],sep="")),env=slider.env)
         reset.function()  }  ),side="right")
  if(missing(but.names)) but.names<-NULL
  for(i in seq(but.names)){
    but.fun<-if(length(but.functions)>1) but.functions[[i]] else but.functions
    if(!is.function(but.fun))but.fun<-
       eval(parse(text=paste("function(...){",but.fun,"}")))
    tkpack(tkbutton(f.but, text=but.names[i], command=but.fun),side="left")
    # cat("button",i,"eingerichtet")
  }
  invisible(nt)
}


@
\subsection{Die Hilfe von [[slider]]}
<<define-slider-help>>=
\name{slider}
\alias{slider}
%- Also NEED an '\alias' for EACH other topic documented here.
%-  cp slider2.Rd /home/wiwi/pwolf/work/relax/install.dir/relax/man/slider.Rd
\title{slider / button control widgets}
\description{
  \code{slider} constructs a Tcl/Tk-widget with sliders and buttons 
  automated calculation and plotting. For example slider allows complete
  all axes rotation of objects in a plot.
}
\usage{
slider(sl.functions, sl.names, sl.mins, sl.maxs, sl.deltas, sl.defaults, but.functions, but.names, no, set.no.value, obj.name, obj.value, reset.function, title)
}
%- maybe also 'usage' for other objects documented here.
\arguments{
  \item{sl.functions}{set of functions or function connected to the slider(s)}
  \item{sl.names}{labels of the sliders}
  \item{sl.mins}{minimum values of the sliders' ranges}
  \item{sl.maxs}{maximum values of the sliders' ranges}
  \item{sl.deltas}{change of step per click}
  \item{sl.defaults}{default values for the sliders}
  \item{but.functions}{function or list of functions
          that are assigned to the button(s)}
  \item{but.names}{labels of the buttons}
  \item{no}{\code{slider(no=i)} requests slider \code{i}}
  \item{set.no.value}{\code{slider(set.no.value=c(i,val))} sets slider \code{i} to value \code{val}}
  \item{obj.name}{\code{slider(obj.name=name)} requests the value of 
  variable \code{name} from environment \code{slider.env}}
  \item{obj.value}{\code{slider(obj.name=name,obj.value=value)} assigns \code{value}
  to variable \code{name} in environment \code{slider.env}}
  \item{reset.function}{function that comprises the commands of the
  \code{reset.button}}
  \item{title}{title of the control window}
}
\details{
  With slider you can:
  a) define (multiple) sliders and buttons, 
  b) request or set slider values, and
  c) request or set variables in the environment \code{slider.env}.
  Slider function management takes place in the
  environment \code{slider.env}. If \code{slider.env}
  is not found it is generated.

  \item{Definition}{... of sliders: First of all you have to define sliders, buttons and the attributes of them.
  Sliders are established by six arguments:
  \code{sl.functions, sl.names, sl.minima, sl.maxima,sl.deltas}, and \code{sl.defaults}.
  The first argument,
  \code{sl.functions}, is either a list of functions or a single function that 
  entails the commands for the sliders.
  If there are three sliders and slider 2 is moved with the mouse the function stored in
  \code{sl.functions[[2]]} (or in case of one function for all sliders the function \code{sl.functions})
  is called.}

  \item{Definition}{... of buttons: Buttons are defined by a vector of labels \code{but.names} and a list of functions:
  \code{but.functions}. If button \code{i} is pressed the function stored in \code{but.functions[[i]]} is called.}

  \item{Requesting}{... a slider: 
  \code{slider(no=1)} returns the actual value of slider 1,
  \code{slider(no=2)} returns the value of slider 2, etc. 
  You are allowed to include expressions of the type
  \code{slider(no=i)} in functions describing the effect of
  sliders or buttons.}

  \item{Setting}{... a slider: \code{slider(set.no.value=c(2,333))} sets slider \code{2} to value 333.
  \code{slider(set.no.value=c(i,value))} can be included in the functions 
  defining the effects of moving sliders or pushing buttons.}

  \item{Variables}{... of the environment \code{slider.env}: Sometimes information
  has to be trransferred back and forth between functions defining the effects of sliders and buttons.
  Imagine for example two sliders: one to control \code{p} and another one to control \code{q},
  but they should satisfy: \code{p+q=1}. Consequently, you have to correct the value of the first slider
  after the second one was moved. To prevent the creation of  global 
  variables store them in the environment \code{slider.env}.
  Use \code{slider(obj.name="p.save",obj.value=1-slider(no=2))}
  to assign value  \code{1-slider(no=2)} to the variable \code{p.save} .
  \code{slider(obj.name=p.save)} returns the value of variable \code{p.save}.}
}
\value{
 Using \code{slider} in definition mode \code{slider} returns the value of new created the top level widget.
  \code{slider(no=i)} returns the actual value of slider \code{i}.
  \code{slider(obj.name=name)} returns the value of variable \code{name} in environment \code{slider.env}.
}
\author{Hans Peter Wolf}

\examples{

# example 1, sliders only
\dontrun{
## This example cannot be run by examples() but should work in an interactive R session
plot.sample.norm<-function(){
 refresh.code<-function(...){
   mu<-slider(no=1); sd<-slider(no=1); n<-slider(no=3)
   x<-rnorm(n,mu,sd)
   plot(x)
 }
 slider(refresh.code,sl.names=c("value of mu","value of sd","n number of observations"),
       sl.mins=c(-10,.01,5),sl.maxs=c(+10,50,100),sl.deltas=c(.01,.01,1),sl.defaults=c(0,1,20))
}
plot.sample.norm()
}

# example 2, sliders and buttons
\dontrun{
## This example cannot be run by examples() but should work in an interactive R session
plot.sample.norm.2<-function(){
 refresh.code<-function(...){
   mu<-slider(no=1); sd<-slider(no=2); n<-slider(no=3)
   type=  slider(obj.name="type")
   x<-rnorm(n,mu,sd)
   plot(seq(x),x,ylim=c(-20,20),type=type)
 }
 slider(refresh.code,sl.names=c("value of mu","value of sd","n number of observations"),
       sl.mins=c(-10,.01,5),sl.maxs=c(10,10,100),sl.deltas=c(.01,.01,1),sl.defaults=c(0,1,20),
       but.functions=list(
              function(...){slider(obj.name="type",obj.value="l");refresh.code()},
              function(...){slider(obj.name="type",obj.value="p");refresh.code()},
              function(...){slider(obj.name="type",obj.value="b");refresh.code()}
       ),
       but.names=c("lines","points","both"))
  slider(obj.name="type",obj.value="l")
}
plot.sample.norm.2()
}

# example 3, dependent sliders
\dontrun{
## This example cannot be run by examples() but should work in an interactive R session
print.of.p.and.q<-function(){
 refresh.code<-function(...){
   p.old<-slider(obj.name="p.old")
   p<-slider(no=1); if(abs(p-p.old)>0.001) {slider(set.no.value=c(2,1-p))}
   q<-slider(no=2); if(abs(q-(1-p))>0.001) {slider(set.no.value=c(1,1-q))}
   slider(obj.name="p.old",obj.value=p)
   cat("p=",p,"q=",1-p,"\n")
 }
 slider(refresh.code,sl.names=c("value of p","value of q"),
       sl.mins=c(0,0),sl.maxs=c(1,1),sl.deltas=c(.01,.01),sl.defaults=c(.2,.8))
 slider(obj.name="p.old",obj.value=slider(no=1))
}
print.of.p.and.q()
}

# example 4, rotating a surface
\dontrun{
## This example cannot be run by examples() but should work in an interactive R session
R.veil.in.the.wind<-function(){
  # Mark Hempelmann / Peter Wolf
  par(bg="blue4", col="white", col.main="white", 
      col.sub="white", font.sub=2, fg="white") # set colors and fonts
  samp	<- function(N,D) N*(1/4+D)/(1/4+D*N) 
  z<-outer(seq(1, 800, by=10), seq(.0025, 0.2, .0025)^2/1.96^2, samp) # create 3d matrix
  h<-100 
  z[10:70,20:25]<-z[10:70,20:25]+h; z[65:70,26:45]<-z[65:70,26:45]+h
  z[64:45,43:48]<-z[64:45,43:48]+h; z[44:39,26:45]<-z[44:39,26:45]+h
  x<-26:59; y<-11:38; zz<-outer(x,y,"+"); zz<-zz*(65<zz)*(zz<73)
  cz<-10+col(zz)[zz>0];rz<-25+row(zz)[zz>0]; z[cbind(cz,rz)]<-z[cbind(cz,rz)]+h
  refresh.code<-function(...){
    theta<-slider(no=1); phi<-slider(no=2)
    persp(x=seq(1,800,by=10),y=seq(.0025,0.2,.0025),z=z,theta=theta,phi=phi, 
          scale=T, shade=.9, box=F, ltheta = 45,
          lphi = 45, col="aquamarine", border="NA",ticktype="detailed")   
  }
  slider(refresh.code, c("theta", "phi"), c(0, 0),c(360, 360),c(.2, .2),c(85, 270)  )
}
R.veil.in.the.wind()
}


## The function is currently defined as
function(sl.functions,sl.names,sl.mins,sl.maxs,sl.deltas,sl.defaults,
                  but.functions,but.names,
                  no,set.no.value,obj.name,obj.value,
                  reset.function,title){
  # slider, version2, pw 040107
  if(!missing(no)) return(as.numeric(tclvalue(get(paste("slider",no,sep=""),env=slider.env))))
  if(!missing(set.no.value)){ try(eval(parse(text=paste("tclvalue(slider",set.no.value[1],")<-",
                            set.no.value[2],sep="")),env=slider.env)); return(set.no.value[2]) }
  if(!exists("slider.env")) slider.env@<<-new.env()
  if(!missing(obj.name)){
    if(!missing(obj.value)) assign(obj.name,obj.value,env=slider.env) else
      obj.value<-get(obj.name,env=slider.env)
    return(obj.value)
  }
  if(missing(title)) title<-"slider control widget"
  require(tcltk); nt<-tktoplevel(); tkwm.title(nt,title); tkwm.geometry(nt,"+0+0")
  if(missing(sl.names)) sl.names<-NULL
  if(missing(sl.functions)) sl.functions<-function(...){}
  for(i in seq(sl.names)){
    eval(parse(text=paste("assign('slider",i,"',tclVar(sl.defaults[i]),env=slider.env)",sep="")))
    tkpack(fr<-tkframe(nt));  lab<-tklabel(fr, text=sl.names[i], width="25")
    sc<-tkscale(fr,from=sl.mins[i],to=sl.maxs[i],showvalue=T,resolution=sl.deltas[i],orient="horiz")
    tkpack(lab,sc,side="right"); assign("sc",sc,env=slider.env)
    eval(parse(text=paste("tkconfigure(sc,variable=slider",i,")",sep="")),env=slider.env)
    sl.fun<-if(length(sl.functions)>1) sl.functions[[i]] else sl.functions
    if(!is.function(sl.fun)) sl.fun<-eval(parse(text=paste("function(...){",sl.fun,"}")))
    tkconfigure(sc,command=sl.fun)
  }
  assign("slider.values.old",sl.defaults,env=slider.env)
  tkpack(f.but<-tkframe(nt),fill="x")
  tkpack(tkbutton(f.but, text="Exit", command=function()tkdestroy(nt)),side="right")
  if(missing(reset.function)) reset.function<-function(...) print("relax")
  if(!is.function(reset.function))
    reset.function<-eval(parse(text=paste("function(...){",reset.function,"}")))
  tkpack(tkbutton(f.but, text="Reset", command=function(){
         for(i in seq(sl.names))
            eval(parse(text=paste("tclvalue(slider",i,")<-",sl.defaults[i],sep="")),env=slider.env)
         reset.function()  }  ),side="right")
  if(missing(but.names)) but.names<-NULL
  for(i in seq(but.names)){
    but.fun<-if(length(but.functions)>1) but.functions[[i]] else but.functions
    if(!is.function(but.fun))but.fun<-
       eval(parse(text=paste("function(...){",but.fun,"}")))
    tkpack(tkbutton(f.but, text=but.names[i], command=but.fun),side="left")
    cat("button",i,"eingerichtet")
  }
  invisible(nt)
}
}
\keyword{dynamic}% at least one, from doc/KEYWORDS
\keyword{iplot}% __ONLY ONE__ keyword per line

@
\section{Anhang: Installationsskript}
Das Skript [[dorw]] erzeugt aufgerufen in [[install.dir]] die wesentlichen Datei
des Paket-Quellverzeichnisses [[install.dir/relax]]. Es wird generiert durch:
\begin{verbatim}
notangle -Rdefine-dorw relax.rev > dorw; chmod +x dorw
\end{verbatim}
<<define-dorx>>=
# dorx: Installationsskript fuer relax
# notangle -Rdefine-dorx relax.rev > install.dir/dorx; chmod +x install.dir/dorx

[ ! -d relax/R ] && mv relax/r relax/R

notangle -Rdefine-tangleR          ../webR/webR.rev > relax/R/tangleR.R
notangle -Rdefine-tangleR-help ../webR/webR.rev > relax/man/tangleR.Rd
notangle -Rdefine-weaveR         ../webR/webR.rev > relax/R/weaveR.R
notangle -Rdefine-weaveR-help ../webR/webR.rev > relax/man/weaveR.Rd
cp -p ../webR/webR.rev  relax/inst/src/webR.rev

notangle -Rdefine-relax-help ../relax.rev > relax/man/relax.Rd
notangle -Rdefine-slider-help   ../relax.rev > relax/man/slider.Rd
notangle -Rdefine-slider-function ../relax.rev > relax/R/slider.R
notangle -Rdefine-DESCRIPTION  ../relax.rev > relax/DESCRIPTION
notangle -Rdefine-config-settings ../relax.rev > relax/inst/config/settings.relax
notangle -Rdefine-config-settings ../relax.rev > relax/inst/config/settings.init
notangle ../relax.rev > relax/R/relax.R
cp -p ../relax.rev  relax/inst/src/relax.rev
notangle -RLaTeX-head ../relax.rev > relax/inst/lib/LaTeX-head.tex

R CMD check relax;  R CMD build relax
rm lib/relax/R/relax.rdb
R CMD INSTALL --library=lib relax_1.00.tar.gz
echo "library(relax,lib.loc=\"lib\"); relax()" | R --vanilla
cd $HOME/work/relax/install.dir/lib; zip -r relax_1.00.zip relax/*
mv relax_1.00.zip ..

# exit 0


@
\section{Anhang: Formfill}
Diese Funktion ist entstanden aus [[ff2.rev]].

Ziel der Funktion [[ff.verbatim]] ist die Ersetzung von Anweisungen
durch ihrer Ergebnisse, so daß sich leicht schöne Outputs mit den
Ergebnissen konkreter Datensätze erstellen lassen.

Zur Anwendung sind folgende Regeln zu beachten:
\begin{enumerate}
\item In einer Verbatim-Umgebung ist ein komplettes
\LaTeX-Dokument mit den zu ersetzenden Anweisungen
abzulegen.
\item
Auszuwertende Anweisungen müssen durch zwei Lattenzäune eingeschlossen
werden: [[#]]{\em auszuwertende Anweisung\/}[[#]]
\item
Nach dieser Verbatim-Umgebung muß ein Code-Chunk folgen,
in dem als letztes die Funktion [[ff.verbatim]] aufgerufen wird.
Der Name, den das \TeX-Dokument bekommen soll, ist dieser Funktion
zu übergeben.
\item
Weitere notwendige Operationen können diesem Funktionaufruf vorgelagert
werden.
\item
Nun ist das Papier nur noch in den Reportmanager zu laden und
der Code-Chunk zu aktivieren. Hierdurch wird der \LaTeX-File
mit der Ergebnissen angelegt, formatiert und im Viewer angezeigt.
\end{enumerate}
@
Es folgt ein Beispiel:
{\footnotesize
\begin{verbatim}
Vorspann des rev-File mit beliebigem Text.
@
\begin{VERBATIM}
\documentclass{slides}\usepackage{graphics}
\begin{document}

\begin{center} Regression \end{center}
\footnotesize
Mit diesem Entwurf lassen sich zu beliebigen Daten schnell
Outputs / Folien  mit passenden Regressionsergebnissen erstellen.
\begin{itemize}
\item Mittel der $x$-Werte: #mean(x)#
\item Mittel der $y$-Werte: #mean(y)#
\item
\[
  \hat\beta
       = \frac{ \overline{xy} - \bar x \bar y}{ \bar{x^2} - \bar x^2 }
       = \frac{#mean(x*y)# - #mean(x)*mean(y)# }{ #mean(x*x)# - #mean(x)^2# }
       = \frac{#mean(x*y)  -  mean(x)*mean(y)# }{ #mean(x*x)  - mean(x)^2# }
       = #b.dach <- (mean(x*y)-mean(x)*mean(y)) / (mean(x*x)-mean(x)^2)#
\]
\item $ \hat\alpha = \bar y - \hat\beta \bar x = #mean(y)-b.dach*mean(x)# $ .
\end{itemize}

\begin{center}
\includegraphics[width=10cm,height=6cm]{file=tmp2.ps}
\end{center}

Wie ist die Summe der ersten 100 Zahlen? Antwort: #sum(1:100)#

Hier endet der mit Ergebnissen zu versehende Text.


@<<*>>=
n<-100; a<-10; b<-0.7; sigma.u<-5
x<-1:n; y<-a+b*x+ rnorm(n,sd=sigma.u)
plot(x,y); abline(lsfit(x,y))
dev.copy(postscript,"tmp2.ps",horizontal=F,width=psdesignwidth.sys,height=psdesignheight.sys)
dev.off()
ff.verbatim("testtest")

@@
Ende des ff.verbatim-Beispiels.
\end{verbatim}
} % end of footnotesize
@
%%%%%%% start of ../R/formfill/ffverb/ffverb.sch  %%%%%%%%%%%%%%
Die [[repeat]]-Schleife ist identisch mit dem Kern von [[ff2.rev]].
Davor wird nur der Ort des aktivierten Chunks festgestellt und die
davorstehende Verbatim-Umgebung gesucht, die dann auf [[tz]]
abgelegt wird. Am Ende sind Systemaufrufe zum Texen und Anzeigen
eingefügt.
<<im Moment unused: definiere [[ff.verbatim]] für [[relax]]>>=
ff.verbatim<-
function(out.file="tmpout.tex",path="",digits=4,escape.symbol="#"){
  ##lese Paperfenster auf [[REVFILE]] ein>>
  <<lese Arbeitsfenster auf [[worktext]] ein>>
  REVFILE<-worktext
    <<lese Arbeitsfenster auf [[worktext]] ein>>
   <<bestimme Cursorzeile [[line]] von [[tworkwin]]>>
  if(0==length(line))  return()
  if(2 >length(line<-grep("{verbatim}", REVFILE[1:line]  )))return()
  line <- rev(line) [2:1]+c(1,-1); lines<-line[1]:line[2]
   if(0==length(tz <-REVFILE[lines])) return()
  cat("processing for   ",out.file,": starts   \n")
  ff.begin.end<-grep(escape.symbol,tz)
  cat("  lines with replacements: \n")
  cat(paste("  ",tz[ff.begin.end],"\n"))
  repeat{
   if(length(ff.begin.end)==0) break
   ff.repl <-tz[ff.begin.end[1]]
   ff.chars<-substring(ff.repl,1:nchar(ff.repl),1:nchar(ff.repl))
   ff.found<-T
   ff.positions<-seq(ff.chars)[ff.chars==escape.symbol]
   if(length(ff.positions)<2)           ff.found<-F
   if(ff.chars[ff.positions[1]+1]==":") ff.found<-F
   if(0!=length(ff.positions)%%2)       ff.found<-F
   if(ff.found){
     ff.positions<-matrix(ff.positions,2)
     ff.eval <-substring(ff.repl,ff.positions[1,]+1,ff.positions[2,]-1)
     ff.out<-NULL
     for(ff.e in ff.eval){
       cat("  expression to be evaluated / replaced:", ff.e, "\n")
       ff.out<-c(ff.out,eval(parse(text=ff.e),env=revive.env))
       cat("  evaluation done, result: ",ff.out[length(ff.out)]," \n")
     }
     if(is.numeric(ff.out)) ff.out<-as.character(signif(ff.out,digits))
     ff.chars<-c("a",ff.chars[0==cumsum(ff.chars==escape.symbol)%%2],"z")
     ff.chars<-paste(ff.chars,collapse="")
     ff.chars<-strsplit(ff.chars,escape.symbol)[[1]]
     ff.chars<-rbind(c(" ",ff.out),ff.chars)[-1]
     ff.chars<-paste(ff.chars,collapse="")
     ff.repl <-substring(ff.chars,2,nchar(ff.chars)-1)
     tz[ff.begin.end[1]]<-ff.repl
     cat("  REPLACED line:",ff.repl,"\n")
   }
   ff.begin.end<-ff.begin.end[-1]
  }
  cat("replacements for ",out.file,": finished\n")
  if(0<nchar(path)) out.file<-paste(path,.Platform$file.sep,out.file,sep="")
  tex.file <- paste(out.file,".tex",sep="")
  get("cat",pos="package:base")(paste(tz,"\n"),file=tex.file,sep="")
  cat("output file      ",tex.file," generated\n")
  if(<<das OS ist Windows>>){
    system(paste("latex ",tex.file)); system(paste("yap",out.file))
  }else{
    system(paste("echo q | latex ",tex.file," ; xdvi ",out.file,"&"))
  }
  "formfillverb beendet"
}
@
%%%%%%% end of ff.verbatim

@
\section{Umstellung auf R-2.0.0}

Wie schnell erkannt, lief die damalige Version von rwined nicht unter R-2.0.0
Deshalb wurden ein paar kleine Änderungen notwendig, die hier
beschrieben werden.

\begin{verbatim}
0. Sicherung der alten Version von rwined

  cp rwined.rev versions/rwined.040922.rev

  gehe nach install.dir und dort nach rwined
  das rwined-Verzeichnis wird die Quelldateien für das Paket aufnehmen.

1. Erstellung einer geeigneten Paketstruktur in:
   /home/wiwi/pwolf/work/relax/install.dir/rwined
DESCRIPTION:

Package: rwined
Version: 0.93
Date: 2004-10-18
Title: relax
Author: Peter Wolf <pwolf@wiwi.uni-bielefeld.de>
Maintainer: Peter Wolf <pwolf@wiwi.uni-bielefeld.de>
Depends: tcltk
Description: package rwined contains full screen R editor rwined()
License: GPL version 2 or newer
URL: http://www.wiwi.uni-bielefeld.de/wolf

2. lege inst-Datei an und platziere dort revweb-Kram und Materialien.

(mkdir) R;   hier kommen alle *.R-Dateien hinein, die später in dem
Paket sein sollen.

(mkdir) inst; hier kommen alle Dateien hinein, die später noch existieren
sollen:

bin  config  lib  rev  rtrevweb

3. verschiebe das Revbook z.B.\ nach

mv rbo/rev/rbk.rev inst/rev/rbk.rev
bzw.
mv rev/*rev inst/rev

4. Check und Bau in install.dir: ( ohne rwined in rwined/R! )

R CMD check rwined; R CMD build rwined

5. Installation:

R CMD INSTALL --library=lib rwined_0.93.tar.gz

6. Lauftest aus dem Verzeichnis .. \verb+$HOME/work/relax/install.dir+

library(rwined,lib.loc="./lib")

-> alle Dinge aus rbo sind angekommen.

7. Hinweise

Warnings: S3 inconsistency: Punkte in Funktionsnamen


Fehler: tmp-Datei wird zum gecheckt: ist aber Quatsch,
da tmp-Datei erst zur Laufzeit benötigt wird.

8. Bewegung von @<<ermittle Namen einer Sink-Datei>> und
 @<<ermittle Namen einer temporären Datei>>  in Funktion rwined
Ablage in der Systemumgebung: revive.sys
@
@<<ermittle Namen einer temporären Datei>>=
tmp.file.name <- tempfile("rt-tmp")
assign(tmp.file.name,"tmp.file.name",env=revive.sys)
@
@<<tmp>>=
get("tmp.file.name",env=revive.sys)

@<<ermittle Namen einer Sink-Datei>>=
tmp.sink.name <- tempfile("rt-sink")
assign(tmp.sink.name,"tmp.sink.name",env=revive.sys)
@
vorher: "r.tmp"
@<<tmp.sink>>=
get("tmp.file.name",env=revive.sys)

tmp.sink wird verwendet in
fEvalRCode, SaveDiffReport, print, EditReport

9. Entfernung von
library("rbo",lib.loc=.find.package(c(@<<rwined>>)[1]))
aus rwined()


10. Verschiebung der Ueberlagerung von cat, print, menu, scan und readline
in die Funktion rwined mit anschliessender Zuordnung in das Paket zur
Laufzeit Muster:

assign("cat",cat,pos=@<<stelle Nummer von [[rwined]] im Suchpfad fest>>)

Zur Sicherheit werden vor rwined Objekte gleichen namens erzeugt:

cat<-print<-menu<-scan<-readline<-1 besser bekommen alte Definitionen

-> check build und Install, library funktionieren, Oberfläche wird erstellt!!
und auch der Code

11. TCLTK-image-jpeg funktioniert nicht:

Error in structure(.External("dotTclObjv", objv, PACKAGE = "tcltk"), class = "tclObj") :
        [tcl] image file format "jpeg" is not supported.

@<<lade tcl/tk... >> ausgewechselt gegen @<<lade img fuer tcltk>>
und in rwined verschoben

12. TeX-Head nicht ans Ende -> nach aktuellen Chunk

13. Konfiguration fuer Systemspezialitäten zentral
... ganz vorn als erstes

14. Unterverzeichnisse z.B. rev/* werden nicht uebernommen.

Loesung: platziere die Verzeichnisse in das Verzeichnis "inst"!

15. Das Data-menu war unbrauchbar.

Grund es wurde nach rbo gesucht, diese Datei war aber nicht mehr da.

16. Experimentell neue Parameter psdesignheight /width eingefuehrt.

XX:
a) R CMD check rwined; b) R CMD build rwined
c) R CMD INSTALL --library=lib rwined_0.91.tar.gz

17. c) R CMD INSTALL --library=lib rwined_0.92.tar.gz simuliert durch

 c1) per Hand (winzip) gz-File ausgepackt
 c2) Alles, was unter Verzeichnis "inst" zu finden war, einen hoeher gehaengt
 c3) Build-Zeile in DESCRIPTION eingefügt
 c4) rwined/R/rwined.R umbenannt in rwined/R/rwined
 c5) lokale Fehlerbehebung:  rtrevweb.bin.path -> binpath in rtrevweb

18. stilgerechter Ladeversuch unter  Windows

19. Variablenfehler in rtrevweb beheben.

20. Dateistruktur fuer windows anpassen, aufbauen: rrtcl, rtrevweb

21. chmod: 644 fuer DESCRIPTION, 755 fuer alle andere Dinge
\end{verbatim}
Inzwischen ist rrtcl/lib/img* unter lib gehängt und revweb bzw.\ rtrevweb nicht mehr nötig.

@
\section{Anhang: Installation}
Mit Übergang auf R-2.0.0 ist die Struktur vereinfacht und für
die Windows / Linux\_Version einheitlich geworden.
Damit die Verzeichnisse so stehen wie hier abgedruckt, muss
alles (bis auf R, man und DESCRIPTION unter inst stehen).
\begin{verbatim}
|
+-- relax                  lokale Bibliothek relax
    |
    +-- DESCRIPTION           Kurzbeschreibung wegen Package-Bedingungen
    |
    +-- INDEX             Kurzindex
    |
    +-- R                     Code-Verzeichnis der Bibliothek relax
    |   |
    |   +-- relax.R          Code der Bibliothek relax
    |   |
    |   +-- weaveR.R          eigene weave-Funktion
    |   |
    |   +-- tangleR.R          eigene tangle-Funktion
    |   |
    |   +-- slider.R          eigene slider-Funktion
    |
+-+
|
+ inst:
    |
    +-- config             Verzeichnis fuer Pfadeinstellungen
    |   |
    |   +-- settings.relax         Datei mit Pfadeinstellungen
    |
    +-- lib            Bibliothek mit diversen Dateien
    |   |
    |   +-- img1.3  tcltk Paket img1.3
    |   |
    |   +-- LaTeX-head.tex  gnoweb.sty  gpl.txt  img1.3  noweb.sty
    |
    +-- man        Help-Pages
    |   |
    |   +-- relax.Rd, slider.Rd, tangleR.Rd, weaveR.Rd
    |
    +-- rev                   wiederbelebbare Materialien
    |   |
    |   +-- rrevbook.rev, roulette.rev, robj.R
    |
    +-- src    Quelldateien
        |
        +-- relax.rev Quelldatei des Pakets
        |
        +-- webR.rev Quelldatei zur eigenen Webfunktionen
     
...+-- old -- rtrevweb              rtrevweb-Arbeitsverzeichnis mit Funktione
                    |
                    +-- sta.txt, ste.txt, end.txt, delcopy.awk, umlaute.awk,
                          ausblend.awk, twebnum.awk, start.awk, tohtm.awk,
                          markup.exe, gawk.exe, nt.exe, iconx.exe, totex.exe, noidx.exe,
                          rtrevweb.sch
\end{verbatim}


@
Erwähnenswert ist nur noch die mitgelieferte Readme-Datei:

\begin{verbatim}
Installationshinweise:

 1. am besten installieren unter

     ..\rw2001\library

    bei anderen Versionen entsprechend.

 2. Der Autor übernimmt keine Gewaehr dafür, 
 dass die Software das, was beschrieben wurde, tut und
 dass die Eigenschaften wirklich so wie beschrieben sind.
 Er übernimmt auch keine Haftung für irgendwelche Fehler oder
 Probleme die aus dem Gebrauch oder dem Umgang mit der
 Software resultieren.

 Hans Peter Wolf
\end{verbatim}

@
\subsection{Eine Kurzbeschreibung im Ansatz}
<<zeige Kurzbeschreibung>>=
cat(  "Installationsleitfaden fuer Linux und Windows: Version vom 28.02.05",
      "=========================================================",
      "install R", "  how to get it?  http://www.r-project.org/", 
      "install relax-package","  how to get it?  ",  
      "    http://www.wiwi.uni-bielefeld.de/~wolf/software/relax/relax.html/",
      "start R: ",  " click R-icon or  R --vanilla",  "load relax packages",  "  > library(relax)",
      "start report manager",  "  > relax()    ",sep="\n")

@
\section{Zum Schluß}
<<*>>=
## DEBUG<<-T
cat("relax geladen!\n")
cat("R-Editor  mit  relax()  starten!\n")
## cat("Soll der Manager gestartet werden? (n=nein)\n")
## if("n"!=substring(readline(),1,1)) r()

@
\section{Anhang: Übersicht der [[noweb]] Code-Chunks}

\nowebchunks


@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
